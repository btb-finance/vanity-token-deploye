import { OmniPoint, OmniSDKFactory, IOmniSDK, OmniAddress, OmniTransaction, Bytes } from '@layerzerolabs/devtools';
import { IOwnable, ILzApp, LzAppFactory, IOApp, OAppEnforcedOptionParam, OAppFactory, IOAppRead, OwnableFactory, IComputerEVM, ResolvedTimeMarker, RequestResponsePair, ISingleViewFunctionCallerEVM, ITimeMarkerResolverChain, ITimeMarkerValidatorChain, ResolvedTimestampTimeMarker } from '@layerzerolabs/ua-devtools';
import { OmniSDK, OmniContractFactory, OmniContract } from '@layerzerolabs/devtools-evm';
import { EndpointId } from '@layerzerolabs/lz-definitions';
import { IEndpointV2 } from '@layerzerolabs/protocol-devtools';
import { JsonRpcProvider } from '@ethersproject/providers';
import { Logger } from '@layerzerolabs/io-devtools';
import { ComputeEVM, SingleViewFunctionEVMCall } from '@layerzerolabs/lz-v2-utilities';
import { z } from 'zod';

type ERC20Factory<TERC20 extends IERC20 = IERC20, TOmniPoint = OmniPoint> = OmniSDKFactory<TERC20, TOmniPoint>;
interface IERC20 extends IOmniSDK, IOwnable {
    getDecimals(): Promise<number>;
    getName(): Promise<string>;
    getSymbol(): Promise<string>;
    getBalanceOf(user: OmniAddress): Promise<bigint>;
    getAllowance(owner: OmniAddress, spender: OmniAddress): Promise<bigint>;
    approve(spender: OmniAddress, amount: bigint): Promise<OmniTransaction>;
    mint(spender: OmniAddress, amount: bigint): Promise<OmniTransaction>;
}

declare class Ownable extends OmniSDK implements IOwnable {
    getOwner(): Promise<OmniAddress | undefined>;
    hasOwner(address: string): Promise<boolean>;
    setOwner(address: string): Promise<OmniTransaction>;
}

declare class ERC20 extends Ownable implements IERC20 {
    getDecimals(): Promise<number>;
    getName(): Promise<string>;
    getSymbol(): Promise<string>;
    getBalanceOf(user: OmniAddress): Promise<bigint>;
    getAllowance(owner: OmniAddress, spender: OmniAddress): Promise<bigint>;
    approve(spender: OmniAddress, amount: bigint): Promise<OmniTransaction>;
    mint(account: OmniAddress, amount: bigint): Promise<OmniTransaction>;
}

/**
 * Syntactic sugar that creates an instance of EVM `ERC20` SDK
 * based on an `OmniPoint` with help of an `OmniContractFactory`
 *
 * @param {OmniContractFactory} contractFactory
 * @returns {ERC20Factory<ERC20>}
 */
declare const createERC20Factory: <TOmniPoint = never>(contractFactory: OmniContractFactory<TOmniPoint | OmniPoint>) => ERC20Factory<ERC20, TOmniPoint>;

declare class LzApp extends OmniSDK implements ILzApp {
    constructor(contract: OmniContract);
    getTrustedRemote(eid: EndpointId): Promise<OmniAddress | undefined>;
    hasTrustedRemote(eid: EndpointId, address: OmniAddress | null | undefined): Promise<boolean>;
    setTrustedRemote(eid: EndpointId, address: OmniAddress | null | undefined): Promise<OmniTransaction>;
}

/**
 * Syntactic sugar that creates an instance of EVM `LZApp` SDK
 * based on an `OmniPoint` with help of an `OmniContractFactory`
 *
 * @param {OmniContractFactory} contractFactory
 * @returns {LzAppFactory<LZApp>}
 */
declare const createLzAppFactory: (contractFactory: OmniContractFactory) => LzAppFactory<LzApp>;

declare class OApp extends Ownable implements IOApp {
    getEndpointSDK(): Promise<IEndpointV2>;
    getPeer(eid: EndpointId): Promise<OmniAddress | undefined>;
    hasPeer(eid: EndpointId, address: OmniAddress | null | undefined): Promise<boolean>;
    setPeer(eid: EndpointId, address: OmniAddress | null | undefined): Promise<OmniTransaction>;
    getDelegate(): Promise<OmniAddress | undefined>;
    isDelegate(delegate: OmniAddress): Promise<boolean>;
    setDelegate(delegate: OmniAddress): Promise<OmniTransaction>;
    getEnforcedOptions(eid: EndpointId, msgType: number): Promise<Bytes>;
    setEnforcedOptions(enforcedOptions: OAppEnforcedOptionParam[]): Promise<OmniTransaction>;
    setCallerBpsCap(callerBpsCap: bigint): Promise<OmniTransaction | undefined>;
    getCallerBpsCap(): Promise<bigint | undefined>;
    /**
     * Prepares the Executor config to be sent to the contract
     *
     * @param {OAppEnforcedOptionParam[]} oappEnforcedOptionParam
     * @returns {SerializedEnforcedOptions[]}
     */
    protected serializeExecutorOptions(oappEnforcedOptionParam: OAppEnforcedOptionParam[]): SerializedEnforcedOptions[];
}
/**
 * Helper type that matches the solidity implementation
 */
interface SerializedEnforcedOptions {
    eid: number;
    msgType: number;
    options: string;
}

/**
 * Syntactic sugar that creates an instance of EVM `OApp` SDK
 * based on an `OmniPoint` with help of an `OmniContractFactory`
 * and an (optional) `EndpointV2Factory`
 *
 * @param {OmniContractFactory} contractFactory
 * @param {EndpointV2Factory} [EndpointV2Factory]
 * @returns {EndpointV2Factory<EndpointV2>}
 */
declare const createOAppFactory: (contractFactory: OmniContractFactory) => OAppFactory<OApp>;

declare class OAppRead extends OApp implements IOAppRead {
    setReadChannel(channelId: number, active: boolean): Promise<OmniTransaction>;
    isReadChannelActive(channelId: number): Promise<boolean>;
}

/**
 * Syntactic sugar that creates an instance of EVM `OApp` SDK
 * based on an `OmniPoint` with help of an `OmniContractFactory`
 * and an (optional) `EndpointV2Factory`
 *
 * @param {OmniContractFactory} contractFactory
 * @param {EndpointV2Factory} [EndpointV2Factory]
 * @returns {EndpointV2Factory<EndpointV2>}
 */
declare const createOAppReadFactory: (contractFactory: OmniContractFactory) => OAppFactory<OAppRead>;

/**
 * Syntactic sugar that adds IOwnable functionality to an instance of OmniSDK
 *
 * @param {OmniSDKFactory<OApp>} sdkFactory
 * @returns {OwnableFactory<OApp & IOwnable>}
 */
declare const createOwnableFactory: (sdkFactory: OmniSDKFactory<OmniSDK>) => OwnableFactory<OmniSDK & IOwnable>;

declare const OwnableMixin: IOwnable;

declare class EVMViewFunctionBase {
    readonly eid: EndpointId;
    protected readonly provider: JsonRpcProvider;
    protected readonly logger: Logger;
    constructor(eid: EndpointId, provider: JsonRpcProvider, logger?: Logger);
    callContract(callData: string, toAddress: string, blockNumber: number): Promise<string>;
}

declare class ComputerEVM extends EVMViewFunctionBase implements IComputerEVM {
    resolve(cmd: string, compute: ComputeEVM, timeMarker: ResolvedTimeMarker, responses: RequestResponsePair[]): Promise<string>;
    private validateComputeSetting;
    private lzMap;
    private lzReduce;
}

declare class SingleViewFunctionCallerEVM extends EVMViewFunctionBase implements ISingleViewFunctionCallerEVM {
    resolve(request: SingleViewFunctionEVMCall, timeMarker: ResolvedTimeMarker): Promise<string>;
}

declare class ContractNotFoundError extends Error {
    constructor();
}

declare const BytesSchema: z.ZodString;

declare class EVMTimeMarkerResolverChain implements ITimeMarkerResolverChain {
    readonly eid: EndpointId;
    protected readonly provider: JsonRpcProvider;
    constructor(eid: EndpointId, provider: JsonRpcProvider);
    resolveTimestamps(timestamps: number[]): Promise<{
        [timestamp: number]: number;
    }>;
}

declare class EVMTimeMarkerValidatorChain implements ITimeMarkerValidatorChain {
    readonly eid: EndpointId;
    protected readonly provider: JsonRpcProvider;
    constructor(eid: EndpointId, provider: JsonRpcProvider);
    checkResolvedTimeMarkerValidity(tms: Omit<ResolvedTimestampTimeMarker, 'eid'>[]): Promise<void>;
    assertTimeMarkerBlockConfirmations(tms: Omit<ResolvedTimeMarker, 'eid'>[]): Promise<void>;
}

export { BytesSchema, ComputerEVM, ContractNotFoundError, ERC20, type ERC20Factory, EVMTimeMarkerResolverChain, EVMTimeMarkerValidatorChain, EVMViewFunctionBase, type IERC20, LzApp, OApp, OAppRead, Ownable, OwnableMixin, SingleViewFunctionCallerEVM, createERC20Factory, createLzAppFactory, createOAppFactory, createOAppReadFactory, createOwnableFactory };
