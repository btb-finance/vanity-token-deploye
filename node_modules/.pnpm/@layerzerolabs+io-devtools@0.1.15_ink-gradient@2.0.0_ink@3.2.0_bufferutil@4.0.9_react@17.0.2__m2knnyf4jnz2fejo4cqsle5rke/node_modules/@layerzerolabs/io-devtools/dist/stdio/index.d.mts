import { Format } from 'logform';
import { Logger } from 'winston';
export { Logger } from 'winston';
import chalk from 'chalk';
import { ZodError } from 'zod';

/**
 * Valid logging levels
 */
declare enum LogLevel {
    error = "error",
    warn = "warn",
    info = "info",
    http = "http",
    verbose = "verbose",
    debug = "debug",
    silly = "silly"
}
/**
 * Type assertion utility for `LogLevel`
 *
 * @param {unknown} value
 * @returns {boolean}
 */
declare const isLogLevel: (value: unknown) => value is LogLevel;
/**
 * Sets the default log level used when creating new loggers.
 *
 * @param {string} level
 */
declare const setDefaultLogLevel: (level: string) => void;
/**
 * Creates a general-purpose logger
 *
 * @param level `LogLevel` Default to the globally set log level (@see `setDefaultLogLevel`)
 * @param logFormat `LogFormat` Optional Winston LogForm.Format instance
 *
 * @returns `Logger`
 */
declare const createLogger: (level?: string, logFormat?: Format) => Logger;
/**
 * Creates a logger a module specific logging.
 *
 * The messages will be prefixed with the module name:
 *
 * `[module] Some message`
 *
 * @param {string} module
 * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)
 *
 * @returns {Logger}
 */
declare const createModuleLogger: (module: string, level?: string) => Logger;
/**
 * Creates a logger for network-to-network interactions.
 *
 * The messages will be prefixed with the network pair:
 *
 * `[ethereum-mainnet ➝ avalanche-mainnet] Some message`
 *
 * @param {string} sourceModule
 * @param {string} destinationModule
 * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)
 *
 * @returns {Logger}
 */
declare const createModuleInteractionLogger: (sourceModule: string, destinationModule: string, level?: string) => Logger;
interface CreateWithAsyncLoggerOptions<TArgs extends unknown[], TReturnValue> {
    onStart?: (logger: Logger, args: TArgs) => unknown;
    onSuccess?: (logger: Logger, args: TArgs, returnValue: TReturnValue) => unknown;
    onError?: (logger: Logger, args: TArgs, error: unknown) => unknown;
}
/**
 * Helper higher order function for creating wrappers that log
 * execution of async functions.
 *
 * ```
 * const myAsyncFunction = async (name: string): Promise<number> => 6;
 *
 * // We can go with the default logger
 * const withAsyncLogger = createWithAsyncLogger()
 *
 * // Or supply our own
 * const withAsyncLogger = createWithAsyncLogger(() => createModuleLogger('my-module'))
 *
 * const myAsyncFunctionWithLogging = withAsyncLogger(myAsyncFunction, {
 *   onStart: (logger, [name]) => logger.info(`Starting myAsyncFunction with argument ${name}`)
 *   onSuccess: (logger, [name], retrurnValue) => logger.info(`Finished myAsyncFunction with argument ${name}, will return ${returnValue}`)
 *   onError: (logger, [name], error) => logger.info(`myAsyncFunction errored out with argument ${name}: ${error}`)
 * })
 *
 * // The wrapper function has the same signature as the wrapped function
 * await myAsyncFunctionWithLogging('Boris')
 * ```
 *
 * @param {() => Logger} [loggerFactory] Function that returns a `Logger` instance
 * @returns
 */
declare const createWithAsyncLogger: (loggerFactory?: () => Logger) => <TArgs extends unknown[], TReturnValue>(fn: (...args: TArgs) => Promise<TReturnValue>, { onStart, onSuccess, onError }?: CreateWithAsyncLoggerOptions<TArgs, TReturnValue>) => (...args: TArgs) => Promise<TReturnValue>;

type Preprocess = (value: string) => string;
declare const COLORS: {
    TRUE: chalk.Chalk;
    FALSE: chalk.Chalk;
    NOT_APPLICABLE: chalk.Chalk;
    DEFAULT_KEY: chalk.Chalk;
    DEFAULT_VALUE: chalk.Chalk;
};
/**
 * Returns a JSON-serialized version of a string, replacing all `BigInt`
 * instances with strings
 *
 * ```
 * const json = printJson({ a: BigInt(1) }) // { "a": "1" }
 * ```
 *
 * @param {unknown} obj Object to serialize
 * @param {boolean} [pretty] Return a pretty, tab-delimited JSON string. Defaults to true.
 * @returns {string}
 */
declare const printJson: (obj: unknown, pretty?: boolean) => string;
declare const printRecord: <TRecord extends object>(obj: TRecord, title?: string | number, keyColor?: Preprocess, valueColor?: Preprocess) => string;
/**
 * Renders a cross table with rows labeled by object properties
 * and columns labeled by an optional header.
 *
 * If passed, the header should also account for the first column containing
 * the property name.
 *
 * @param {Record<string | number, unknown>} records
 * @param {string[]} [headers] - header row if provided
 * @param {boolean} [center] - center text if true
 * @param {Preprocess} [keyColor=COLORS.DEFAULT_KEY] keyColor - color of keys in table
 * @param {Preprocess} [valueColor=COLORS.DEFAULT_VALUE] valueColor - color of values in table
 * @returns {string}
 */
declare const printCrossTable: <TRecord extends Record<string | number, unknown>>(records: TRecord[], headers?: string[], center?: boolean, keyColor?: Preprocess, valueColor?: Preprocess) => string;
/**
 * Helper utility for printing out boolean values
 *
 * @param {boolean | null | undefined} value
 * @param {Preprocess} [nullColor=COLORS.NOT_APPLICABLE] nullColor
 * @param {Preprocess} [trueColor=COLORS.TRUE] trueColor
 * @param {Preprocess} [falseColor=COLORS.FALSE] falseColor
 * @returns {string}
 */
declare const printBoolean: (value: boolean | null | undefined, nullColor?: Preprocess, trueColor?: Preprocess, falseColor?: Preprocess) => string;
declare const printZodErrors: (error: ZodError<unknown>) => string;

/**
 * Helper utility to be used when raw access to prompts
 * is required.
 *
 * This should be passed to `onState` property of the options
 * to handle cases where the user sends a SIGTERM signal to the process
 * (ctrl + c) usually.
 *
 * If not passed in, the SIGTERM will cancel the prompt but the promise
 * will resolve with an invalid result and, what's more important,
 * if cursor had been hidden it will be swallowed and people will need to
 * restart their terminal to bring it back
 *
 * @param {{ aborted?: boolean}} state Prompts state object
 */
declare const handlePromptState: (state: {
    aborted?: boolean;
}) => void;
declare const promptToContinue: (message?: string, defaultValue?: boolean) => Promise<boolean>;
/**
 * Validation function for prompts (sync or async)
 *
 * Should return true if validation passed, false or an error message
 * if validation failed
 */
type PromptValidator<TValue extends string> = (value: TValue) => string | boolean | Promise<string | boolean>;
interface TextProps {
    /**
     * Additional message to show to the user
     */
    hint?: string;
    defaultValue?: string;
    validate?: PromptValidator<string>;
}
declare const promptForText: (message?: string, { defaultValue, hint, validate }?: TextProps) => Promise<any>;
interface PromptOption<TValue> {
    title: string;
    hint?: string;
    disabled?: boolean;
    selected?: boolean;
    value?: TValue;
}
interface SelectProps<TValue> {
    options: PromptOption<TValue>[];
    /**
     * A message displayed to the user if they focus on a disabled value
     */
    disabledHint?: string;
}
declare const promptToSelectOne: <TValue>(message: string, { options }: SelectProps<TValue>) => Promise<TValue>;
interface MultiSelectProps<TValue> extends SelectProps<TValue> {
    /**
     * Minimum number of options to select
     */
    min?: number;
    /**
     * Maximum number of options to select
     */
    max?: number;
}
declare const promptToSelectMultiple: <TValue>(message: string, { options, disabledHint, min, max }: MultiSelectProps<TValue>) => Promise<TValue[]>;

export { COLORS, type CreateWithAsyncLoggerOptions, LogLevel, type PromptOption, createLogger, createModuleInteractionLogger, createModuleLogger, createWithAsyncLogger, handlePromptState, isLogLevel, printBoolean, printCrossTable, printJson, printRecord, printZodErrors, promptForText, promptToContinue, promptToSelectMultiple, promptToSelectOne, setDefaultLogLevel };
