{"version":3,"sources":["../../src/stdio/logger.ts","../../src/stdio/printer.ts","../../src/stdio/prompts.ts"],"names":["LogLevel"],"mappings":";AACA,SAAS,gBAAgB,qBAAqB,QAAQ,kBAA+B;AACrF,SAAS,SAAS;AAUX,IAAK,WAAL,kBAAKA,cAAL;AACH,EAAAA,UAAA,WAAQ;AACR,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,aAAU;AACV,EAAAA,UAAA,WAAQ;AACR,EAAAA,UAAA,WAAQ;AAPA,SAAAA;AAAA,GAAA;AAUZ,IAAM,iBAAiB,EAAE,WAAW,QAAQ;AAQrC,IAAM,aAAa,CAAC,UAAsC,eAAe,UAAU,KAAK,EAAE;AAEjG,IAAI,oBAAoB;AAOjB,IAAM,qBAAqB,CAAC,UAAkB;AACjD,MAAI,CAAC,WAAW,KAAK,GAAG;AACpB,YAAQ;AAAA,MACJ,gCAAgC,KAAK,+CAA+C,iBAAiB;AAAA,IACzG;AAEA;AAAA,EACJ;AAEA,sBAAoB;AACxB;AAUO,IAAM,eAAe,CAAC,QAAgB,mBAAmB,YAAoB,OAAO,IAAI,MAC3F,oBAAoB;AAAA,EAChB;AAAA,EACA,QAAQ;AAAA,EACR,YAAY,CAAC,IAAI,WAAW,QAAQ,CAAC;AACzC,CAAC;AAcE,IAAM,qBAAqB,CAAC,QAAgB,QAAgB,sBAC/D,aAAa,OAAO,OAAO,QAAQ,OAAO,EAAE,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC;AAexE,IAAM,gCAAgC,CACzC,cACA,mBACA,QAAgB,sBAEhB,aAAa,OAAO,OAAO,QAAQ,OAAO,EAAE,OAAO,GAAG,YAAY,WAAM,iBAAiB,GAAG,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC;AAkC1G,IAAM,wBACT,CAAC,gBAA8B,iBAC/B,CACI,IACA,EAAE,SAAS,WAAW,QAAQ,IAAuD,CAAC,MACrF;AAED,MAAI;AAEJ,SAAO,UAAU,SAAuC;AAEpD,aAAS,0BAAU,cAAc;AAGjC,uCAAU,QAAQ;AAGlB,QAAI;AAEA,YAAM,cAAc,MAAM,GAAG,GAAG,IAAI;AAGpC,UAAI;AACA,+CAAY,QAAQ,MAAM;AAAA,MAC9B,SAAQ;AAAA,MAER;AAGA,aAAO;AAAA,IACX,SAAS,OAAO;AAIZ,UAAI;AACA,2CAAU,QAAQ,MAAM;AAAA,MAC5B,SAAQ;AAAA,MAER;AAGA,YAAM;AAAA,IACV;AAAA,EACJ;AACJ;AAUJ,IAAM,SAAS,OAAO,CAAC,MAAM,EAAE,MAAM,OAAO;AAAA,EACxC,GAAG;AAAA,EACH,SAAS,GAAG,QAAQ,IAAI,KAAK,OAAO,EAAE,GAAG,KAAK,OAAO;AACzD,EAAE;;;AC9LF,SAA2B,qBAAqB,aAAa;AAC7D,OAAO,WAAW;AAIX,IAAM,SAAS;AAAA,EAClB,MAAM,MAAM,IAAI,GAAG,KAAK,CAAC;AAAA;AAAA,EACzB,OAAO,MAAM,IAAI,KAAK,GAAG,CAAC;AAAA;AAAA,EAC1B,gBAAgB,MAAM,IAAI,KAAK,KAAK,CAAC;AAAA;AAAA,EACrC,aAAa,MAAM,IAAI,KAAK,KAAK,GAAG;AAAA;AAAA,EACpC,eAAe,MAAM,IAAI,KAAK,KAAK,GAAG;AAAA;AAC1C;AAcO,IAAM,YAAY,CAAC,KAAc,SAAS,SAC7C,KAAK;AAAA,EACD;AAAA,EACA,CAAC,KAAK,UAAW,OAAO,UAAU,WAAW,MAAM,SAAS,EAAE,IAAI;AAAA,EAClE,SAAS,MAAO;AACpB;AAeJ,IAAM,aAAa,CACf,OACA,WAAuB,OAAO,aAC9B,aAAyB,OAAO,kBACvB;AACT,UAAQ,MAAM;AAAA,IACV,KAAK,SAAS;AAAA,IACd,KAAK,iBAAiB;AAAA,IACtB,KAAK,OAAO,UAAU;AAClB,aAAO,WAAW,OAAO,KAAK,CAAC;AAAA,IAEnC;AACI,aAAO,YAAY,OAAO,QAAW,UAAU,UAAU;AAAA,EACjE;AACJ;AAEO,IAAM,cAAc,CACvB,KACA,OACA,WAAuB,OAAO,aAC9B,aAAyB,OAAO,kBACvB;AACT,QAAM,OAAO,OAAO,QAAQ,GAAG,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAgB;AAAA,IAC7D,SAAS,GAAG;AAAA,IACZ,WAAW,OAAO,UAAU,UAAU;AAAA,EAC1C,CAAC;AAED,MAAI,SAAS,MAAM;AACf,SAAK,QAAQ,CAAC,SAAS,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;AAAA,EAC9C;AAGA,MAAI,KAAK,WAAW,GAAG;AACnB,WAAO;AAAA,EACX;AAEA,SAAO,MAAM,MAAM;AAAA,IACf,QAAQ,oBAAoB,MAAM;AAAA,IAClC,eAAe,SAAS,OAAO,SAAY,CAAC,EAAE,KAAK,GAAG,KAAK,GAAG,SAAS,EAAE,CAAC;AAAA,EAC9E,CAAC;AACL;AAgBO,IAAM,kBAAkB,CAC3B,SACA,SACA,QACA,WAAuB,OAAO,aAC9B,aAAyB,OAAO,kBACvB;AA3Gb;AA4GI,QAAM,UAA8B,SAC7B,CAAC,QAAQ,GAAG,QAAQ,IAAI,MAAM,QAAQ,CAAC,EAAE,IAAI,CAAC,eAAe,EAAE,UAAU,EAAE,IAC5E,CAAC;AAEP,QAAM,aAAsB,wCAAS,IAAI,CAAC,WAAW,SAAS,MAAM,OAAxC,YAA8C,CAAC;AAC3E,QAAM,OAAmB,CAAC,SAAS;AAQnC,QAAM,aAAa,QAAQ,QAAQ,OAAO,IAAI;AAC9C,QAAM,iBAA8B,IAAI,IAAI,UAAU;AAEtD,aAAW,YAAY,YAAY;AAE/B,QAAI,CAAC,eAAe,IAAI,QAAQ,GAAG;AAC/B;AAAA,IACJ;AAGA,mBAAe,OAAO,QAAQ;AAG9B,UAAM,SAAS,QAAQ,IAAI,CAAC,WAAW,WAAW,OAAO,QAAQ,GAAG,UAAU,UAAU,CAAC;AAGzF,UAAM,MAAM,CAAC,SAAS,QAAQ,GAAG,GAAG,MAAM;AAG1C,SAAK,KAAK,GAAG;AAAA,EACjB;AAEA,SAAO,MAAM,MAAM,EAAE,QAAQ,oBAAoB,MAAM,GAAG,QAAQ,CAAC;AACvE;AAWO,IAAM,eAAe,CACxB,OACA,YAAwB,OAAO,gBAC/B,YAAwB,OAAO,MAC/B,aAAyB,OAAO,UACtB,SAAS,OAAO,UAAU,QAAG,IAAI,QAAQ,UAAU,QAAG,IAAI,WAAW,QAAG;AAE/E,IAAM,iBAAiB,CAAC,UAAqC;AAGhE,QAAM,SAAS,MAAM,QAAQ,CAAC,UAAU;AArK5C;AAsKQ,UAAM,gBAAe,iBAAM,SAAN,mBAAY,KAAK,SAAjB,YAAyB;AAC9C,QAAI,iBAAiB,IAAI;AACrB,aAAO,MAAM;AAAA,IACjB;AAEA,WAAO,aAAa,YAAY,MAAM,MAAM,OAAO;AAAA,EACvD,CAAC;AAGD,QAAM,aAAa,OAAO;AAG1B,QAAM,cAAc,OAAO,OAAkB,OAAO,WAAW,EAAE,KAAK;AAGtE,QAAM,YAAY,CAAC,GAAG,YAAY,GAAG,WAAW;AAGhD,SAAO,UAAU,KAAK;AAAA,CAAI;AAC9B;;;ACzLA,OAAO,YAAY;AACnB,OAAO,aAAa;AAiBb,IAAM,oBAAoB,CAAC,UAAiC;AAC/D,MAAI,MAAM,SAAS;AAGf,YAAQ,OAAO,MAAM,WAAW;AAChC,YAAQ,OAAO,MAAM,IAAI;AACzB,YAAQ,KAAK,CAAC;AAAA,EAClB;AACJ;AAEO,IAAM,mBAAmB,OAC5B,UAAkB,4BAClB,eAAe,SACI;AACnB,QAAM,EAAE,MAAM,IAAI,MAAM,QAAQ;AAAA,IAC5B,MAAM;AAAA,IACN,MAAM;AAAA,IACN;AAAA,IACA,SAAS;AAAA,IACT,SAAS;AAAA,EACb,CAAC;AAED,SAAO,OAAO,UAAU,WAAW,qDAAqD,KAAK,EAAE;AAE/F,SAAO;AACX;AAmBO,IAAM,gBAAgB,OACzB,UAAkB,4BAClB,EAAE,cAAc,MAAM,SAAS,IAAe,CAAC,MAC9C;AACD,QAAM,EAAE,MAAM,IAAI,MAAM,QAAQ;AAAA,IAC5B,MAAM;AAAA,IACN,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACb,CAAC;AAED,SAAO;AACX;AAkBO,IAAM,oBAAoB,OAAe,SAAiB,EAAE,QAAQ,MAA4C;AACnH,QAAM,EAAE,MAAM,IAAI,MAAM,QAAQ;AAAA,IAC5B,MAAM;AAAA,IACN,MAAM;AAAA,IACN;AAAA,IACA,SAAS;AAAA,IACT,SAAS;AAAA,EACb,CAAC;AAED,SAAO;AACX;AAaO,IAAM,yBAAyB,OAClC,SACA,EAAE,SAAS,cAAc,KAAK,IAAI,MACd;AACpB,QAAM,EAAE,MAAM,IAAI,MAAM,QAAQ;AAAA,IAC5B,MAAM;AAAA,IACN,MAAM;AAAA,IACN;AAAA,IACA,SAAS;AAAA,IACT,SAAS;AAAA,IACT,MAAM;AAAA,IACN;AAAA,IACA;AAAA,EACJ,CAAC;AAED,SAAO;AACX","sourcesContent":["import type { Format } from 'logform'\nimport { createLogger as createWinstonLogger, format, transports, type Logger } from 'winston'\nimport { z } from 'zod'\n\n/**\n * Re-export for ease of use\n */\nexport { type Logger } from 'winston'\n\n/**\n * Valid logging levels\n */\nexport enum LogLevel {\n    error = 'error',\n    warn = 'warn',\n    info = 'info',\n    http = 'http',\n    verbose = 'verbose',\n    debug = 'debug',\n    silly = 'silly',\n}\n\nconst LogLevelSchema = z.nativeEnum(LogLevel)\n\n/**\n * Type assertion utility for `LogLevel`\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isLogLevel = (value: unknown): value is LogLevel => LogLevelSchema.safeParse(value).success\n\nlet DEFAULT_LOG_LEVEL = LogLevel.info\n\n/**\n * Sets the default log level used when creating new loggers.\n *\n * @param {string} level\n */\nexport const setDefaultLogLevel = (level: string) => {\n    if (!isLogLevel(level)) {\n        console.warn(\n            `Invalid log level specified: ${level}. Ignoring and keeping the current value of ${DEFAULT_LOG_LEVEL}`\n        )\n\n        return\n    }\n\n    DEFAULT_LOG_LEVEL = level\n}\n\n/**\n * Creates a general-purpose logger\n *\n * @param level `LogLevel` Default to the globally set log level (@see `setDefaultLogLevel`)\n * @param logFormat `LogFormat` Optional Winston LogForm.Format instance\n *\n * @returns `Logger`\n */\nexport const createLogger = (level: string = DEFAULT_LOG_LEVEL, logFormat: Format = format.cli()): Logger =>\n    createWinstonLogger({\n        level,\n        format: logFormat,\n        transports: [new transports.Console()],\n    })\n\n/**\n * Creates a logger a module specific logging.\n *\n * The messages will be prefixed with the module name:\n *\n * `[module] Some message`\n *\n * @param {string} module\n * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)\n *\n * @returns {Logger}\n */\nexport const createModuleLogger = (module: string, level: string = DEFAULT_LOG_LEVEL): Logger =>\n    createLogger(level, format.combine(prefix({ label: module }), format.cli()))\n\n/**\n * Creates a logger for network-to-network interactions.\n *\n * The messages will be prefixed with the network pair:\n *\n * `[ethereum-mainnet ➝ avalanche-mainnet] Some message`\n *\n * @param {string} sourceModule\n * @param {string} destinationModule\n * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)\n *\n * @returns {Logger}\n */\nexport const createModuleInteractionLogger = (\n    sourceModule: string,\n    destinationModule: string,\n    level: string = DEFAULT_LOG_LEVEL\n): Logger =>\n    createLogger(level, format.combine(prefix({ label: `${sourceModule} ➝ ${destinationModule}` }), format.cli()))\n\nexport interface CreateWithAsyncLoggerOptions<TArgs extends unknown[], TReturnValue> {\n    onStart?: (logger: Logger, args: TArgs) => unknown\n    onSuccess?: (logger: Logger, args: TArgs, returnValue: TReturnValue) => unknown\n    onError?: (logger: Logger, args: TArgs, error: unknown) => unknown\n}\n\n/**\n * Helper higher order function for creating wrappers that log\n * execution of async functions.\n *\n * ```\n * const myAsyncFunction = async (name: string): Promise<number> => 6;\n *\n * // We can go with the default logger\n * const withAsyncLogger = createWithAsyncLogger()\n *\n * // Or supply our own\n * const withAsyncLogger = createWithAsyncLogger(() => createModuleLogger('my-module'))\n *\n * const myAsyncFunctionWithLogging = withAsyncLogger(myAsyncFunction, {\n *   onStart: (logger, [name]) => logger.info(`Starting myAsyncFunction with argument ${name}`)\n *   onSuccess: (logger, [name], retrurnValue) => logger.info(`Finished myAsyncFunction with argument ${name}, will return ${returnValue}`)\n *   onError: (logger, [name], error) => logger.info(`myAsyncFunction errored out with argument ${name}: ${error}`)\n * })\n *\n * // The wrapper function has the same signature as the wrapped function\n * await myAsyncFunctionWithLogging('Boris')\n * ```\n *\n * @param {() => Logger} [loggerFactory] Function that returns a `Logger` instance\n * @returns\n */\nexport const createWithAsyncLogger =\n    (loggerFactory: () => Logger = createLogger) =>\n    <TArgs extends unknown[], TReturnValue>(\n        fn: (...args: TArgs) => Promise<TReturnValue>,\n        { onStart, onSuccess, onError }: CreateWithAsyncLoggerOptions<TArgs, TReturnValue> = {}\n    ) => {\n        // We'll create the logger only when needed\n        let logger: Logger\n\n        return async (...args: TArgs): Promise<TReturnValue> => {\n            // If we don't have a logger yet, now is a great time to make one\n            logger = logger ?? loggerFactory()\n\n            // Let the consumer know that the execution has started\n            onStart?.(logger, args)\n\n            // Now try executing the actual function\n            try {\n                // In the happy case, the function gives us a return value back\n                const returnValue = await fn(...args)\n\n                // We try logging the return value\n                try {\n                    onSuccess?.(logger, args, returnValue)\n                } catch {\n                    // If the logger errors out, we ignore it\n                }\n\n                // And we return it\n                return returnValue\n            } catch (error) {\n                // In the unhappy, saddening and most disappointing case the function errors out\n\n                // We try logging the error\n                try {\n                    onError?.(logger, args, error)\n                } catch {\n                    // If the logger errors out, we ignore it\n                }\n\n                // And we rethrow\n                throw error\n            }\n        }\n    }\n\n/**\n * Helper utility that prefixes logged messages\n * with label (wrapped in square brackets)\n *\n * An example of logged message with `ethereum-mainnet` label:\n *\n * `[ethereum-mainnet] Some message`\n */\nconst prefix = format((info, { label }) => ({\n    ...info,\n    message: `${label ? `[${label}] ` : ''}${info.message}`,\n}))\n","import { ColumnUserConfig, getBorderCharacters, table } from 'table'\nimport chalk from 'chalk'\nimport type { ZodError } from 'zod'\n\ntype Preprocess = (value: string) => string\nexport const COLORS = {\n    TRUE: chalk.rgb(0, 153, 0), // GREEN\n    FALSE: chalk.rgb(255, 0, 0), // RED\n    NOT_APPLICABLE: chalk.rgb(255, 128, 0), // ORANGE\n    DEFAULT_KEY: chalk.rgb(255, 255, 255), // WHITE\n    DEFAULT_VALUE: chalk.rgb(167, 125, 255), // MAGENTA\n}\n\n/**\n * Returns a JSON-serialized version of a string, replacing all `BigInt`\n * instances with strings\n *\n * ```\n * const json = printJson({ a: BigInt(1) }) // { \"a\": \"1\" }\n * ```\n *\n * @param {unknown} obj Object to serialize\n * @param {boolean} [pretty] Return a pretty, tab-delimited JSON string. Defaults to true.\n * @returns {string}\n */\nexport const printJson = (obj: unknown, pretty = true): string =>\n    JSON.stringify(\n        obj,\n        (key, value) => (typeof value === 'bigint' ? value.toString(10) : value),\n        pretty ? '\\t' : undefined\n    )\n\n/**\n * Helper function for the other printers.\n *\n * Will check for the value type and either print a string representation\n * of the value or use `printRecord` if possible.\n *\n * @see {@link printRecord}\n *\n * @param value\n * @param keyColor - color of keys in table (DEFAULT: WHITE)\n * @param valueColor - color of values in table (DEFAULT: MAGENTA)\n * @returns\n */\nconst printValue = (\n    value: unknown,\n    keyColor: Preprocess = COLORS.DEFAULT_KEY,\n    valueColor: Preprocess = COLORS.DEFAULT_VALUE\n): string => {\n    switch (true) {\n        case value == null:\n        case value instanceof Date:\n        case typeof value !== 'object':\n            return valueColor(String(value))\n\n        default:\n            return printRecord(value, undefined, keyColor, valueColor)\n    }\n}\n\nexport const printRecord = <TRecord extends object>(\n    obj: TRecord,\n    title?: string | number,\n    keyColor: Preprocess = COLORS.DEFAULT_KEY,\n    valueColor: Preprocess = COLORS.DEFAULT_VALUE\n): string => {\n    const rows = Object.entries(obj).map(([key, value]): string[] => [\n        keyColor(key),\n        printValue(value, keyColor, valueColor),\n    ])\n\n    if (title != null) {\n        rows.unshift([keyColor(String(title)), ''])\n    }\n\n    // The table library throws if there are no rows so we need to take care of that possibility\n    if (rows.length === 0) {\n        return ''\n    }\n\n    return table(rows, {\n        border: getBorderCharacters('norc'),\n        spanningCells: title == null ? undefined : [{ col: 0, row: 0, colSpan: 2 }],\n    })\n}\n\n/**\n * Renders a cross table with rows labeled by object properties\n * and columns labeled by an optional header.\n *\n * If passed, the header should also account for the first column containing\n * the property name.\n *\n * @param {Record<string | number, unknown>} records\n * @param {string[]} [headers] - header row if provided\n * @param {boolean} [center] - center text if true\n * @param {Preprocess} [keyColor=COLORS.DEFAULT_KEY] keyColor - color of keys in table\n * @param {Preprocess} [valueColor=COLORS.DEFAULT_VALUE] valueColor - color of values in table\n * @returns {string}\n */\nexport const printCrossTable = <TRecord extends Record<string | number, unknown>>(\n    records: TRecord[],\n    headers?: string[],\n    center?: boolean,\n    keyColor: Preprocess = COLORS.DEFAULT_KEY,\n    valueColor: Preprocess = COLORS.DEFAULT_VALUE\n): string => {\n    const columns: ColumnUserConfig[] = center\n        ? (['left', ...records.map(() => 'center')].map((alignment) => ({ alignment })) as ColumnUserConfig[])\n        : []\n    // Set the colored headers if provided\n    const headerRow: string[] = headers?.map((header) => keyColor(header)) ?? []\n    const rows: string[][] = [headerRow]\n\n    // We'll gather all the properties of all the records in this array\n    //\n    // We do this in case some of the objects were missing any properties -\n    // we take all the properties of all the objects, then mark the ones we already added\n    // to our table in the set below. That way, if there is a property present on one object only,\n    // it will still be added to the table\n    const properties = records.flatMap(Object.keys)\n    const propertiesLeft: Set<string> = new Set(properties)\n\n    for (const property of properties) {\n        // If we already added this one, we continue\n        if (!propertiesLeft.has(property)) {\n            continue\n        }\n\n        // Now we mark the property as added\n        propertiesLeft.delete(property)\n\n        // Get all the values and print them\n        const values = records.map((record) => printValue(record[property], keyColor, valueColor))\n\n        // Create a row with the property label first\n        const row = [keyColor(property), ...values]\n\n        // And add to the table\n        rows.push(row)\n    }\n\n    return table(rows, { border: getBorderCharacters('norc'), columns })\n}\n\n/**\n * Helper utility for printing out boolean values\n *\n * @param {boolean | null | undefined} value\n * @param {Preprocess} [nullColor=COLORS.NOT_APPLICABLE] nullColor\n * @param {Preprocess} [trueColor=COLORS.TRUE] trueColor\n * @param {Preprocess} [falseColor=COLORS.FALSE] falseColor\n * @returns {string}\n */\nexport const printBoolean = (\n    value: boolean | null | undefined,\n    nullColor: Preprocess = COLORS.NOT_APPLICABLE,\n    trueColor: Preprocess = COLORS.TRUE,\n    falseColor: Preprocess = COLORS.FALSE\n): string => (value == null ? nullColor('∅') : value ? trueColor('✓') : falseColor('⤫'))\n\nexport const printZodErrors = (error: ZodError<unknown>): string => {\n    // Here we will go through all the errors and prefix them with the name\n    // of the property on which they happened, if any\n    const errors = error.flatten((issue) => {\n        const propertyPath = issue.path?.join('.') ?? ''\n        if (propertyPath === '') {\n            return issue.message\n        }\n\n        return `Property '${propertyPath}': ${issue.message}`\n    })\n\n    // These are the errors coming from a mismatch on the root object - e.g. when a whole object is completely missing\n    const formErrors = errors.formErrors\n\n    // These are errors coming from object properties\n    const fieldErrors = Object.values<unknown[]>(errors.fieldErrors).flat()\n\n    // Now we take all the errors we got\n    const allErrors = [...formErrors, ...fieldErrors]\n\n    // And concatenate\n    return allErrors.join(`\\n`)\n}\n","import assert from 'assert'\nimport prompts from 'prompts'\n\n/**\n * Helper utility to be used when raw access to prompts\n * is required.\n *\n * This should be passed to `onState` property of the options\n * to handle cases where the user sends a SIGTERM signal to the process\n * (ctrl + c) usually.\n *\n * If not passed in, the SIGTERM will cancel the prompt but the promise\n * will resolve with an invalid result and, what's more important,\n * if cursor had been hidden it will be swallowed and people will need to\n * restart their terminal to bring it back\n *\n * @param {{ aborted?: boolean}} state Prompts state object\n */\nexport const handlePromptState = (state: { aborted?: boolean }) => {\n    if (state.aborted) {\n        // If we don't re-enable the terminal cursor before exiting\n        // the program, the cursor will remain hidden\n        process.stdout.write('\\x1B[?25h')\n        process.stdout.write('\\n')\n        process.exit(1)\n    }\n}\n\nexport const promptToContinue = async (\n    message: string = 'Do you want to continue?',\n    defaultValue = true\n): Promise<boolean> => {\n    const { value } = await prompts({\n        type: 'confirm',\n        name: 'value',\n        message,\n        initial: defaultValue,\n        onState: handlePromptState,\n    })\n\n    assert(typeof value === 'boolean', `Invariant error: Expected a boolean response, got ${value}`)\n\n    return value\n}\n\n/**\n * Validation function for prompts (sync or async)\n *\n * Should return true if validation passed, false or an error message\n * if validation failed\n */\ntype PromptValidator<TValue extends string> = (value: TValue) => string | boolean | Promise<string | boolean>\n\ninterface TextProps {\n    /**\n     * Additional message to show to the user\n     */\n    hint?: string\n    defaultValue?: string\n    validate?: PromptValidator<string>\n}\n\nexport const promptForText = async (\n    message: string = 'Do you want to continue?',\n    { defaultValue, hint, validate }: TextProps = {}\n) => {\n    const { value } = await prompts({\n        type: 'text',\n        name: 'value',\n        hint,\n        message,\n        onState: handlePromptState,\n        validate,\n        initial: defaultValue,\n    })\n\n    return value\n}\n\nexport interface PromptOption<TValue> {\n    title: string\n    hint?: string\n    disabled?: boolean\n    selected?: boolean\n    value?: TValue\n}\n\ninterface SelectProps<TValue> {\n    options: PromptOption<TValue>[]\n    /**\n     * A message displayed to the user if they focus on a disabled value\n     */\n    disabledHint?: string\n}\n\nexport const promptToSelectOne = async <TValue>(message: string, { options }: SelectProps<TValue>): Promise<TValue> => {\n    const { value } = await prompts({\n        type: 'select',\n        name: 'value',\n        message,\n        choices: options,\n        onState: handlePromptState,\n    })\n\n    return value\n}\n\ninterface MultiSelectProps<TValue> extends SelectProps<TValue> {\n    /**\n     * Minimum number of options to select\n     */\n    min?: number\n    /**\n     * Maximum number of options to select\n     */\n    max?: number\n}\n\nexport const promptToSelectMultiple = async <TValue>(\n    message: string,\n    { options, disabledHint, min, max }: MultiSelectProps<TValue>\n): Promise<TValue[]> => {\n    const { value } = await prompts({\n        type: 'autocompleteMultiselect',\n        name: 'value',\n        message,\n        choices: options,\n        onState: handlePromptState,\n        warn: disabledHint,\n        min,\n        max,\n    })\n\n    return value\n}\n"]}