import { format, createLogger as createLogger$1, transports } from 'winston';
import { z } from 'zod';
import { table, getBorderCharacters } from 'table';
import chalk from 'chalk';
import assert from 'assert';
import prompts from 'prompts';

// src/stdio/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["error"] = "error";
  LogLevel2["warn"] = "warn";
  LogLevel2["info"] = "info";
  LogLevel2["http"] = "http";
  LogLevel2["verbose"] = "verbose";
  LogLevel2["debug"] = "debug";
  LogLevel2["silly"] = "silly";
  return LogLevel2;
})(LogLevel || {});
var LogLevelSchema = z.nativeEnum(LogLevel);
var isLogLevel = (value) => LogLevelSchema.safeParse(value).success;
var DEFAULT_LOG_LEVEL = "info" /* info */;
var setDefaultLogLevel = (level) => {
  if (!isLogLevel(level)) {
    console.warn(
      `Invalid log level specified: ${level}. Ignoring and keeping the current value of ${DEFAULT_LOG_LEVEL}`
    );
    return;
  }
  DEFAULT_LOG_LEVEL = level;
};
var createLogger = (level = DEFAULT_LOG_LEVEL, logFormat = format.cli()) => createLogger$1({
  level,
  format: logFormat,
  transports: [new transports.Console()]
});
var createModuleLogger = (module, level = DEFAULT_LOG_LEVEL) => createLogger(level, format.combine(prefix({ label: module }), format.cli()));
var createModuleInteractionLogger = (sourceModule, destinationModule, level = DEFAULT_LOG_LEVEL) => createLogger(level, format.combine(prefix({ label: `${sourceModule} \u279D ${destinationModule}` }), format.cli()));
var createWithAsyncLogger = (loggerFactory = createLogger) => (fn, { onStart, onSuccess, onError } = {}) => {
  let logger;
  return async (...args) => {
    logger = logger != null ? logger : loggerFactory();
    onStart == null ? void 0 : onStart(logger, args);
    try {
      const returnValue = await fn(...args);
      try {
        onSuccess == null ? void 0 : onSuccess(logger, args, returnValue);
      } catch (e) {
      }
      return returnValue;
    } catch (error) {
      try {
        onError == null ? void 0 : onError(logger, args, error);
      } catch (e) {
      }
      throw error;
    }
  };
};
var prefix = format((info, { label }) => ({
  ...info,
  message: `${label ? `[${label}] ` : ""}${info.message}`
}));
var COLORS = {
  TRUE: chalk.rgb(0, 153, 0),
  // GREEN
  FALSE: chalk.rgb(255, 0, 0),
  // RED
  NOT_APPLICABLE: chalk.rgb(255, 128, 0),
  // ORANGE
  DEFAULT_KEY: chalk.rgb(255, 255, 255),
  // WHITE
  DEFAULT_VALUE: chalk.rgb(167, 125, 255)
  // MAGENTA
};
var printJson = (obj, pretty = true) => JSON.stringify(
  obj,
  (key, value) => typeof value === "bigint" ? value.toString(10) : value,
  pretty ? "	" : void 0
);
var printValue = (value, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  switch (true) {
    case value == null:
    case value instanceof Date:
    case typeof value !== "object":
      return valueColor(String(value));
    default:
      return printRecord(value, void 0, keyColor, valueColor);
  }
};
var printRecord = (obj, title, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  const rows = Object.entries(obj).map(([key, value]) => [
    keyColor(key),
    printValue(value, keyColor, valueColor)
  ]);
  if (title != null) {
    rows.unshift([keyColor(String(title)), ""]);
  }
  if (rows.length === 0) {
    return "";
  }
  return table(rows, {
    border: getBorderCharacters("norc"),
    spanningCells: title == null ? void 0 : [{ col: 0, row: 0, colSpan: 2 }]
  });
};
var printCrossTable = (records, headers, center, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  var _a;
  const columns = center ? ["left", ...records.map(() => "center")].map((alignment) => ({ alignment })) : [];
  const headerRow = (_a = headers == null ? void 0 : headers.map((header) => keyColor(header))) != null ? _a : [];
  const rows = [headerRow];
  const properties = records.flatMap(Object.keys);
  const propertiesLeft = new Set(properties);
  for (const property of properties) {
    if (!propertiesLeft.has(property)) {
      continue;
    }
    propertiesLeft.delete(property);
    const values = records.map((record) => printValue(record[property], keyColor, valueColor));
    const row = [keyColor(property), ...values];
    rows.push(row);
  }
  return table(rows, { border: getBorderCharacters("norc"), columns });
};
var printBoolean = (value, nullColor = COLORS.NOT_APPLICABLE, trueColor = COLORS.TRUE, falseColor = COLORS.FALSE) => value == null ? nullColor("\u2205") : value ? trueColor("\u2713") : falseColor("\u292B");
var printZodErrors = (error) => {
  const errors = error.flatten((issue) => {
    var _a, _b;
    const propertyPath = (_b = (_a = issue.path) == null ? void 0 : _a.join(".")) != null ? _b : "";
    if (propertyPath === "") {
      return issue.message;
    }
    return `Property '${propertyPath}': ${issue.message}`;
  });
  const formErrors = errors.formErrors;
  const fieldErrors = Object.values(errors.fieldErrors).flat();
  const allErrors = [...formErrors, ...fieldErrors];
  return allErrors.join(`
`);
};
var handlePromptState = (state) => {
  if (state.aborted) {
    process.stdout.write("\x1B[?25h");
    process.stdout.write("\n");
    process.exit(1);
  }
};
var promptToContinue = async (message = "Do you want to continue?", defaultValue = true) => {
  const { value } = await prompts({
    type: "confirm",
    name: "value",
    message,
    initial: defaultValue,
    onState: handlePromptState
  });
  assert(typeof value === "boolean", `Invariant error: Expected a boolean response, got ${value}`);
  return value;
};
var promptForText = async (message = "Do you want to continue?", { defaultValue, hint, validate } = {}) => {
  const { value } = await prompts({
    type: "text",
    name: "value",
    hint,
    message,
    onState: handlePromptState,
    validate,
    initial: defaultValue
  });
  return value;
};
var promptToSelectOne = async (message, { options }) => {
  const { value } = await prompts({
    type: "select",
    name: "value",
    message,
    choices: options,
    onState: handlePromptState
  });
  return value;
};
var promptToSelectMultiple = async (message, { options, disabledHint, min, max }) => {
  const { value } = await prompts({
    type: "autocompleteMultiselect",
    name: "value",
    message,
    choices: options,
    onState: handlePromptState,
    warn: disabledHint,
    min,
    max
  });
  return value;
};

export { COLORS, LogLevel, createLogger, createModuleInteractionLogger, createModuleLogger, createWithAsyncLogger, handlePromptState, isLogLevel, printBoolean, printCrossTable, printJson, printRecord, printZodErrors, promptForText, promptToContinue, promptToSelectMultiple, promptToSelectOne, setDefaultLogLevel };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map