'use strict';

var winston = require('winston');
var zod = require('zod');
var fs = require('fs');
var table = require('table');
var chalk = require('chalk');
var path = require('path');
var assert = require('assert');
var prompts = require('prompts');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefault(chalk);
var assert__default = /*#__PURE__*/_interopDefault(assert);
var prompts__default = /*#__PURE__*/_interopDefault(prompts);

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/async/time.ts
var sleep = (timeout) => new Promise((resolve2) => setTimeout(resolve2, timeout));
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["error"] = "error";
  LogLevel2["warn"] = "warn";
  LogLevel2["info"] = "info";
  LogLevel2["http"] = "http";
  LogLevel2["verbose"] = "verbose";
  LogLevel2["debug"] = "debug";
  LogLevel2["silly"] = "silly";
  return LogLevel2;
})(LogLevel || {});
var LogLevelSchema = zod.z.nativeEnum(LogLevel);
var isLogLevel = (value) => LogLevelSchema.safeParse(value).success;
var DEFAULT_LOG_LEVEL = "info" /* info */;
var setDefaultLogLevel = (level) => {
  if (!isLogLevel(level)) {
    console.warn(
      `Invalid log level specified: ${level}. Ignoring and keeping the current value of ${DEFAULT_LOG_LEVEL}`
    );
    return;
  }
  DEFAULT_LOG_LEVEL = level;
};
var createLogger = (level = DEFAULT_LOG_LEVEL, logFormat = winston.format.cli()) => winston.createLogger({
  level,
  format: logFormat,
  transports: [new winston.transports.Console()]
});
var createModuleLogger = (module, level = DEFAULT_LOG_LEVEL) => createLogger(level, winston.format.combine(prefix({ label: module }), winston.format.cli()));
var createModuleInteractionLogger = (sourceModule, destinationModule, level = DEFAULT_LOG_LEVEL) => createLogger(level, winston.format.combine(prefix({ label: `${sourceModule} \u279D ${destinationModule}` }), winston.format.cli()));
var createWithAsyncLogger = (loggerFactory = createLogger) => (fn, { onStart, onSuccess, onError } = {}) => {
  let logger;
  return async (...args) => {
    logger = logger != null ? logger : loggerFactory();
    onStart == null ? void 0 : onStart(logger, args);
    try {
      const returnValue = await fn(...args);
      try {
        onSuccess == null ? void 0 : onSuccess(logger, args, returnValue);
      } catch (e) {
      }
      return returnValue;
    } catch (error) {
      try {
        onError == null ? void 0 : onError(logger, args, error);
      } catch (e) {
      }
      throw error;
    }
  };
};
var prefix = winston.format((info, { label }) => ({
  ...info,
  message: `${label ? `[${label}] ` : ""}${info.message}`
}));
var isDirectory = (path) => {
  try {
    return fs.lstatSync(path).isDirectory();
  } catch (e) {
    return false;
  }
};
var isFile = (path) => {
  try {
    return fs.lstatSync(path).isFile();
  } catch (e) {
    return false;
  }
};
var isReadable = (path) => {
  try {
    return fs.accessSync(path, fs.constants.R_OK), true;
  } catch (e) {
    return false;
  }
};
var importDefault = async (path) => {
  const logger = createModuleLogger("filesystem");
  try {
    logger.debug(`Importing default from '${path}' using dynamic import`);
    const result = await import(path);
    if (result != null && "default" in result) {
      return logger.debug(`Found default in '${path}' using dynamic import`), result.default;
    }
    return logger.debug(`Did not find default in '${path}' using dynamic import, returning the whole thing`), result;
  } catch (error) {
    logger.debug(`Failed to import from '${path}' using dynamic import: ${error}`);
  }
  try {
    logger.debug(`Importing default from '${path}' using require`);
    const result = await __require(path);
    if (result != null && result.__esModule) {
      return logger.debug(`Found default in '${path}' using require`), result.default;
    }
    return logger.debug(`Did not find default in '${path}' using require, returning the whole thing`), result;
  } catch (error) {
    logger.debug(`Failed to import from '${path}' using require: ${error}`);
    throw error;
  }
};
var COLORS = {
  TRUE: chalk__default.default.rgb(0, 153, 0),
  // GREEN
  FALSE: chalk__default.default.rgb(255, 0, 0),
  // RED
  NOT_APPLICABLE: chalk__default.default.rgb(255, 128, 0),
  // ORANGE
  DEFAULT_KEY: chalk__default.default.rgb(255, 255, 255),
  // WHITE
  DEFAULT_VALUE: chalk__default.default.rgb(167, 125, 255)
  // MAGENTA
};
var printJson = (obj, pretty = true) => JSON.stringify(
  obj,
  (key, value) => typeof value === "bigint" ? value.toString(10) : value,
  pretty ? "	" : void 0
);
var printValue = (value, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  switch (true) {
    case value == null:
    case value instanceof Date:
    case typeof value !== "object":
      return valueColor(String(value));
    default:
      return printRecord(value, void 0, keyColor, valueColor);
  }
};
var printRecord = (obj, title, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  const rows = Object.entries(obj).map(([key, value]) => [
    keyColor(key),
    printValue(value, keyColor, valueColor)
  ]);
  if (title != null) {
    rows.unshift([keyColor(String(title)), ""]);
  }
  if (rows.length === 0) {
    return "";
  }
  return table.table(rows, {
    border: table.getBorderCharacters("norc"),
    spanningCells: title == null ? void 0 : [{ col: 0, row: 0, colSpan: 2 }]
  });
};
var printCrossTable = (records, headers, center, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  var _a;
  const columns = center ? ["left", ...records.map(() => "center")].map((alignment) => ({ alignment })) : [];
  const headerRow = (_a = headers == null ? void 0 : headers.map((header) => keyColor(header))) != null ? _a : [];
  const rows = [headerRow];
  const properties = records.flatMap(Object.keys);
  const propertiesLeft = new Set(properties);
  for (const property of properties) {
    if (!propertiesLeft.has(property)) {
      continue;
    }
    propertiesLeft.delete(property);
    const values = records.map((record) => printValue(record[property], keyColor, valueColor));
    const row = [keyColor(property), ...values];
    rows.push(row);
  }
  return table.table(rows, { border: table.getBorderCharacters("norc"), columns });
};
var printBoolean = (value, nullColor = COLORS.NOT_APPLICABLE, trueColor = COLORS.TRUE, falseColor = COLORS.FALSE) => value == null ? nullColor("\u2205") : value ? trueColor("\u2713") : falseColor("\u292B");
var printZodErrors = (error) => {
  const errors = error.flatten((issue) => {
    var _a, _b;
    const propertyPath = (_b = (_a = issue.path) == null ? void 0 : _a.join(".")) != null ? _b : "";
    if (propertyPath === "") {
      return issue.message;
    }
    return `Property '${propertyPath}': ${issue.message}`;
  });
  const formErrors = errors.formErrors;
  const fieldErrors = Object.values(errors.fieldErrors).flat();
  const allErrors = [...formErrors, ...fieldErrors];
  return allErrors.join(`
`);
};
var createConfigLoader = (schema, logger = createModuleLogger("config loader")) => async (path$1) => {
  const absolutePath = path.resolve(path$1);
  logger.verbose(`Resolved config file location for '${path$1}': '${absolutePath}'`);
  logger.verbose(`Checking config file '${absolutePath}' for existence & readability`);
  const isConfigReadable = isFile(absolutePath) && isReadable(absolutePath);
  if (!isConfigReadable) {
    throw new Error(
      `Unable to read config file '${path$1}'. Check that the file exists and is readable to your terminal user`
    );
  }
  logger.verbose(`Config file '${absolutePath}' exists & is readable`);
  let rawConfig;
  try {
    logger.verbose(`Loading config file '${absolutePath}'`);
    rawConfig = await importDefault(absolutePath);
  } catch (error) {
    throw new Error(`Unable to read config file '${path$1}': ${error}`);
  }
  logger.verbose(`Loaded config file '${absolutePath}'`);
  let rawConfigMaterialized;
  if (typeof rawConfig === "function") {
    logger.verbose(`Executing configuration function from config file '${absolutePath}'`);
    try {
      rawConfigMaterialized = await rawConfig();
    } catch (error) {
      throw new Error(`Got an exception while executing config funtion from file '${path$1}': ${error}`);
    }
  } else {
    logger.verbose(`Using exported value from config file '${absolutePath}'`);
    rawConfigMaterialized = rawConfig;
  }
  logger.verbose(`Validating the structure of config file '${absolutePath}'`);
  const configParseResult = await schema.safeParseAsync(rawConfigMaterialized);
  if (configParseResult.success === false) {
    const userFriendlyErrors = printZodErrors(configParseResult.error);
    throw new Error(
      `Config from file '${path$1}' is malformed. Please fix the following errors:

${userFriendlyErrors}`
    );
  }
  return configParseResult.data;
};

// src/language/plurals.ts
var cardinalRules = new Intl.PluralRules("en-US");
var ordinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });
var ordinals = {
  one: "st",
  two: "nd",
  few: "rd",
  other: "th",
  zero: "th",
  many: "th"
};
var pluralizeOrdinal = (n) => {
  const rule = ordinalRules.select(n);
  const suffix = ordinals[rule];
  return `${n}${suffix}`;
};
var pluralizeNoun = (n, singular, plural = `${singular}s`) => {
  const rule = cardinalRules.select(n);
  if (rule === "one") {
    return singular;
  }
  return plural;
};
var handlePromptState = (state) => {
  if (state.aborted) {
    process.stdout.write("\x1B[?25h");
    process.stdout.write("\n");
    process.exit(1);
  }
};
var promptToContinue = async (message = "Do you want to continue?", defaultValue = true) => {
  const { value } = await prompts__default.default({
    type: "confirm",
    name: "value",
    message,
    initial: defaultValue,
    onState: handlePromptState
  });
  assert__default.default(typeof value === "boolean", `Invariant error: Expected a boolean response, got ${value}`);
  return value;
};
var promptForText = async (message = "Do you want to continue?", { defaultValue, hint, validate } = {}) => {
  const { value } = await prompts__default.default({
    type: "text",
    name: "value",
    hint,
    message,
    onState: handlePromptState,
    validate,
    initial: defaultValue
  });
  return value;
};
var promptToSelectOne = async (message, { options }) => {
  const { value } = await prompts__default.default({
    type: "select",
    name: "value",
    message,
    choices: options,
    onState: handlePromptState
  });
  return value;
};
var promptToSelectMultiple = async (message, { options, disabledHint, min, max }) => {
  const { value } = await prompts__default.default({
    type: "autocompleteMultiselect",
    name: "value",
    message,
    choices: options,
    onState: handlePromptState,
    warn: disabledHint,
    min,
    max
  });
  return value;
};

exports.COLORS = COLORS;
exports.LogLevel = LogLevel;
exports.createConfigLoader = createConfigLoader;
exports.createLogger = createLogger;
exports.createModuleInteractionLogger = createModuleInteractionLogger;
exports.createModuleLogger = createModuleLogger;
exports.createWithAsyncLogger = createWithAsyncLogger;
exports.handlePromptState = handlePromptState;
exports.importDefault = importDefault;
exports.isDirectory = isDirectory;
exports.isFile = isFile;
exports.isLogLevel = isLogLevel;
exports.isReadable = isReadable;
exports.pluralizeNoun = pluralizeNoun;
exports.pluralizeOrdinal = pluralizeOrdinal;
exports.printBoolean = printBoolean;
exports.printCrossTable = printCrossTable;
exports.printJson = printJson;
exports.printRecord = printRecord;
exports.printZodErrors = printZodErrors;
exports.promptForText = promptForText;
exports.promptToContinue = promptToContinue;
exports.promptToSelectMultiple = promptToSelectMultiple;
exports.promptToSelectOne = promptToSelectOne;
exports.setDefaultLogLevel = setDefaultLogLevel;
exports.sleep = sleep;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map