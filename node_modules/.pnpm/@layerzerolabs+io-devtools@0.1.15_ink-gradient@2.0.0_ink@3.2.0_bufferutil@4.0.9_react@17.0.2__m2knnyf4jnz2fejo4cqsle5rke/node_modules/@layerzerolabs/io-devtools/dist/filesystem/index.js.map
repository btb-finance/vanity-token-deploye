{"version":3,"sources":["../../src/stdio/logger.ts","../../src/filesystem/filesystem.ts"],"names":["LogLevel"],"mappings":";;;;;;;;;AACA,SAAS,gBAAgB,qBAAqB,QAAQ,kBAA+B;AACrF,SAAS,SAAS;AAUX,IAAK,WAAL,kBAAKA,cAAL;AACH,EAAAA,UAAA,WAAQ;AACR,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,aAAU;AACV,EAAAA,UAAA,WAAQ;AACR,EAAAA,UAAA,WAAQ;AAPA,SAAAA;AAAA,GAAA;AAUZ,IAAM,iBAAiB,EAAE,WAAW,QAAQ;AAU5C,IAAI,oBAAoB;AA2BjB,IAAM,eAAe,CAAC,QAAgB,mBAAmB,YAAoB,OAAO,IAAI,MAC3F,oBAAoB;AAAA,EAChB;AAAA,EACA,QAAQ;AAAA,EACR,YAAY,CAAC,IAAI,WAAW,QAAQ,CAAC;AACzC,CAAC;AAcE,IAAM,qBAAqB,CAAC,QAAgB,QAAgB,sBAC/D,aAAa,OAAO,OAAO,QAAQ,OAAO,EAAE,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC;AA4G/E,IAAM,SAAS,OAAO,CAAC,MAAM,EAAE,MAAM,OAAO;AAAA,EACxC,GAAG;AAAA,EACH,SAAS,GAAG,QAAQ,IAAI,KAAK,OAAO,EAAE,GAAG,KAAK,OAAO;AACzD,EAAE;;;AC7LF,SAAS,YAAY,WAAW,iBAAiB;AAE1C,IAAM,cAAc,CAAC,SAA0B;AAClD,MAAI;AACA,WAAO,UAAU,IAAI,EAAE,YAAY;AAAA,EACvC,SAAQ;AACJ,WAAO;AAAA,EACX;AACJ;AAEO,IAAM,SAAS,CAAC,SAA0B;AAC7C,MAAI;AACA,WAAO,UAAU,IAAI,EAAE,OAAO;AAAA,EAClC,SAAQ;AACJ,WAAO;AAAA,EACX;AACJ;AAEO,IAAM,aAAa,CAAC,SAA0B;AACjD,MAAI;AACA,WAAO,WAAW,MAAM,UAAU,IAAI,GAAG;AAAA,EAC7C,SAAQ;AACJ,WAAO;AAAA,EACX;AACJ;AAWO,IAAM,gBAAgB,OAAO,SAAmC;AACnE,QAAM,SAAS,mBAAmB,YAAY;AAK9C,MAAI;AACA,WAAO,MAAM,2BAA2B,IAAI,wBAAwB;AACpE,UAAM,SAAS,MAAM,OAAO;AAE5B,QAAI,UAAU,QAAQ,aAAa,QAAQ;AACvC,aAAO,OAAO,MAAM,qBAAqB,IAAI,wBAAwB,GAAG,OAAO;AAAA,IACnF;AAGA,WAAO,OAAO,MAAM,4BAA4B,IAAI,mDAAmD,GAAG;AAAA,EAC9G,SAAS,OAAO;AACZ,WAAO,MAAM,0BAA0B,IAAI,2BAA2B,KAAK,EAAE;AAAA,EACjF;AAGA,MAAI;AACA,WAAO,MAAM,2BAA2B,IAAI,iBAAiB;AAC7D,UAAM,SAAS,MAAM,UAAQ,IAAI;AAEjC,QAAI,UAAU,QAAQ,OAAO,YAAY;AACrC,aAAO,OAAO,MAAM,qBAAqB,IAAI,iBAAiB,GAAG,OAAO;AAAA,IAC5E;AAGA,WAAO,OAAO,MAAM,4BAA4B,IAAI,4CAA4C,GAAG;AAAA,EACvG,SAAS,OAAO;AACZ,WAAO,MAAM,0BAA0B,IAAI,oBAAoB,KAAK,EAAE;AAGtE,UAAM;AAAA,EACV;AACJ","sourcesContent":["import type { Format } from 'logform'\nimport { createLogger as createWinstonLogger, format, transports, type Logger } from 'winston'\nimport { z } from 'zod'\n\n/**\n * Re-export for ease of use\n */\nexport { type Logger } from 'winston'\n\n/**\n * Valid logging levels\n */\nexport enum LogLevel {\n    error = 'error',\n    warn = 'warn',\n    info = 'info',\n    http = 'http',\n    verbose = 'verbose',\n    debug = 'debug',\n    silly = 'silly',\n}\n\nconst LogLevelSchema = z.nativeEnum(LogLevel)\n\n/**\n * Type assertion utility for `LogLevel`\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isLogLevel = (value: unknown): value is LogLevel => LogLevelSchema.safeParse(value).success\n\nlet DEFAULT_LOG_LEVEL = LogLevel.info\n\n/**\n * Sets the default log level used when creating new loggers.\n *\n * @param {string} level\n */\nexport const setDefaultLogLevel = (level: string) => {\n    if (!isLogLevel(level)) {\n        console.warn(\n            `Invalid log level specified: ${level}. Ignoring and keeping the current value of ${DEFAULT_LOG_LEVEL}`\n        )\n\n        return\n    }\n\n    DEFAULT_LOG_LEVEL = level\n}\n\n/**\n * Creates a general-purpose logger\n *\n * @param level `LogLevel` Default to the globally set log level (@see `setDefaultLogLevel`)\n * @param logFormat `LogFormat` Optional Winston LogForm.Format instance\n *\n * @returns `Logger`\n */\nexport const createLogger = (level: string = DEFAULT_LOG_LEVEL, logFormat: Format = format.cli()): Logger =>\n    createWinstonLogger({\n        level,\n        format: logFormat,\n        transports: [new transports.Console()],\n    })\n\n/**\n * Creates a logger a module specific logging.\n *\n * The messages will be prefixed with the module name:\n *\n * `[module] Some message`\n *\n * @param {string} module\n * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)\n *\n * @returns {Logger}\n */\nexport const createModuleLogger = (module: string, level: string = DEFAULT_LOG_LEVEL): Logger =>\n    createLogger(level, format.combine(prefix({ label: module }), format.cli()))\n\n/**\n * Creates a logger for network-to-network interactions.\n *\n * The messages will be prefixed with the network pair:\n *\n * `[ethereum-mainnet ➝ avalanche-mainnet] Some message`\n *\n * @param {string} sourceModule\n * @param {string} destinationModule\n * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)\n *\n * @returns {Logger}\n */\nexport const createModuleInteractionLogger = (\n    sourceModule: string,\n    destinationModule: string,\n    level: string = DEFAULT_LOG_LEVEL\n): Logger =>\n    createLogger(level, format.combine(prefix({ label: `${sourceModule} ➝ ${destinationModule}` }), format.cli()))\n\nexport interface CreateWithAsyncLoggerOptions<TArgs extends unknown[], TReturnValue> {\n    onStart?: (logger: Logger, args: TArgs) => unknown\n    onSuccess?: (logger: Logger, args: TArgs, returnValue: TReturnValue) => unknown\n    onError?: (logger: Logger, args: TArgs, error: unknown) => unknown\n}\n\n/**\n * Helper higher order function for creating wrappers that log\n * execution of async functions.\n *\n * ```\n * const myAsyncFunction = async (name: string): Promise<number> => 6;\n *\n * // We can go with the default logger\n * const withAsyncLogger = createWithAsyncLogger()\n *\n * // Or supply our own\n * const withAsyncLogger = createWithAsyncLogger(() => createModuleLogger('my-module'))\n *\n * const myAsyncFunctionWithLogging = withAsyncLogger(myAsyncFunction, {\n *   onStart: (logger, [name]) => logger.info(`Starting myAsyncFunction with argument ${name}`)\n *   onSuccess: (logger, [name], retrurnValue) => logger.info(`Finished myAsyncFunction with argument ${name}, will return ${returnValue}`)\n *   onError: (logger, [name], error) => logger.info(`myAsyncFunction errored out with argument ${name}: ${error}`)\n * })\n *\n * // The wrapper function has the same signature as the wrapped function\n * await myAsyncFunctionWithLogging('Boris')\n * ```\n *\n * @param {() => Logger} [loggerFactory] Function that returns a `Logger` instance\n * @returns\n */\nexport const createWithAsyncLogger =\n    (loggerFactory: () => Logger = createLogger) =>\n    <TArgs extends unknown[], TReturnValue>(\n        fn: (...args: TArgs) => Promise<TReturnValue>,\n        { onStart, onSuccess, onError }: CreateWithAsyncLoggerOptions<TArgs, TReturnValue> = {}\n    ) => {\n        // We'll create the logger only when needed\n        let logger: Logger\n\n        return async (...args: TArgs): Promise<TReturnValue> => {\n            // If we don't have a logger yet, now is a great time to make one\n            logger = logger ?? loggerFactory()\n\n            // Let the consumer know that the execution has started\n            onStart?.(logger, args)\n\n            // Now try executing the actual function\n            try {\n                // In the happy case, the function gives us a return value back\n                const returnValue = await fn(...args)\n\n                // We try logging the return value\n                try {\n                    onSuccess?.(logger, args, returnValue)\n                } catch {\n                    // If the logger errors out, we ignore it\n                }\n\n                // And we return it\n                return returnValue\n            } catch (error) {\n                // In the unhappy, saddening and most disappointing case the function errors out\n\n                // We try logging the error\n                try {\n                    onError?.(logger, args, error)\n                } catch {\n                    // If the logger errors out, we ignore it\n                }\n\n                // And we rethrow\n                throw error\n            }\n        }\n    }\n\n/**\n * Helper utility that prefixes logged messages\n * with label (wrapped in square brackets)\n *\n * An example of logged message with `ethereum-mainnet` label:\n *\n * `[ethereum-mainnet] Some message`\n */\nconst prefix = format((info, { label }) => ({\n    ...info,\n    message: `${label ? `[${label}] ` : ''}${info.message}`,\n}))\n","import { createModuleLogger } from '@/stdio/logger'\nimport { accessSync, constants, lstatSync } from 'fs'\n\nexport const isDirectory = (path: string): boolean => {\n    try {\n        return lstatSync(path).isDirectory()\n    } catch {\n        return false\n    }\n}\n\nexport const isFile = (path: string): boolean => {\n    try {\n        return lstatSync(path).isFile()\n    } catch {\n        return false\n    }\n}\n\nexport const isReadable = (path: string): boolean => {\n    try {\n        return accessSync(path, constants.R_OK), true\n    } catch {\n        return false\n    }\n}\n\n/**\n * CJS/ESM interoperable utility for importing JS/TS/JSON files\n *\n * This utility is not safe in a sense that it will not check for file existence\n * before trying to import it, consumers need to do that\n *\n * @param {string} path\n * @returns {unknown} imported module\n */\nexport const importDefault = async (path: string): Promise<unknown> => {\n    const logger = createModuleLogger('filesystem')\n\n    // Let's use a dynamic import first\n    //\n    // This will not work in new node versions without experimental ESM module support\n    try {\n        logger.debug(`Importing default from '${path}' using dynamic import`)\n        const result = await import(path)\n\n        if (result != null && 'default' in result) {\n            return logger.debug(`Found default in '${path}' using dynamic import`), result.default\n        }\n\n        // If not let's just return the whole export\n        return logger.debug(`Did not find default in '${path}' using dynamic import, returning the whole thing`), result\n    } catch (error) {\n        logger.debug(`Failed to import from '${path}' using dynamic import: ${error}`)\n    }\n\n    // If dynamic import fails, let's use good ol' require\n    try {\n        logger.debug(`Importing default from '${path}' using require`)\n        const result = await require(path)\n\n        if (result != null && result.__esModule) {\n            return logger.debug(`Found default in '${path}' using require`), result.default\n        }\n\n        // If not let's just return the whole export\n        return logger.debug(`Did not find default in '${path}' using require, returning the whole thing`), result\n    } catch (error) {\n        logger.debug(`Failed to import from '${path}' using require: ${error}`)\n\n        // We'll just rethrow the second error\n        throw error\n    }\n}\n"]}