{"version":3,"sources":["../src/async/time.ts","../src/stdio/logger.ts","../src/filesystem/filesystem.ts","../src/stdio/printer.ts","../src/config/loading.ts","../src/language/plurals.ts","../src/stdio/prompts.ts"],"names":["resolve","LogLevel"],"mappings":"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","sourcesContent":["/**\n * Returns a promise that resolves after the specified number of milliseconds\n *\n * @param {number} timeout Nap time in milliseconds\n * @returns {Promise<void>}\n */\nexport const sleep = (timeout: number): Promise<void> => new Promise<void>((resolve) => setTimeout(resolve, timeout))\n","import type { Format } from 'logform'\nimport { createLogger as createWinstonLogger, format, transports, type Logger } from 'winston'\nimport { z } from 'zod'\n\n/**\n * Re-export for ease of use\n */\nexport { type Logger } from 'winston'\n\n/**\n * Valid logging levels\n */\nexport enum LogLevel {\n    error = 'error',\n    warn = 'warn',\n    info = 'info',\n    http = 'http',\n    verbose = 'verbose',\n    debug = 'debug',\n    silly = 'silly',\n}\n\nconst LogLevelSchema = z.nativeEnum(LogLevel)\n\n/**\n * Type assertion utility for `LogLevel`\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isLogLevel = (value: unknown): value is LogLevel => LogLevelSchema.safeParse(value).success\n\nlet DEFAULT_LOG_LEVEL = LogLevel.info\n\n/**\n * Sets the default log level used when creating new loggers.\n *\n * @param {string} level\n */\nexport const setDefaultLogLevel = (level: string) => {\n    if (!isLogLevel(level)) {\n        console.warn(\n            `Invalid log level specified: ${level}. Ignoring and keeping the current value of ${DEFAULT_LOG_LEVEL}`\n        )\n\n        return\n    }\n\n    DEFAULT_LOG_LEVEL = level\n}\n\n/**\n * Creates a general-purpose logger\n *\n * @param level `LogLevel` Default to the globally set log level (@see `setDefaultLogLevel`)\n * @param logFormat `LogFormat` Optional Winston LogForm.Format instance\n *\n * @returns `Logger`\n */\nexport const createLogger = (level: string = DEFAULT_LOG_LEVEL, logFormat: Format = format.cli()): Logger =>\n    createWinstonLogger({\n        level,\n        format: logFormat,\n        transports: [new transports.Console()],\n    })\n\n/**\n * Creates a logger a module specific logging.\n *\n * The messages will be prefixed with the module name:\n *\n * `[module] Some message`\n *\n * @param {string} module\n * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)\n *\n * @returns {Logger}\n */\nexport const createModuleLogger = (module: string, level: string = DEFAULT_LOG_LEVEL): Logger =>\n    createLogger(level, format.combine(prefix({ label: module }), format.cli()))\n\n/**\n * Creates a logger for network-to-network interactions.\n *\n * The messages will be prefixed with the network pair:\n *\n * `[ethereum-mainnet ➝ avalanche-mainnet] Some message`\n *\n * @param {string} sourceModule\n * @param {string} destinationModule\n * @param {string} [level] Default to the globally set log level (@see `setDefaultLogLevel`)\n *\n * @returns {Logger}\n */\nexport const createModuleInteractionLogger = (\n    sourceModule: string,\n    destinationModule: string,\n    level: string = DEFAULT_LOG_LEVEL\n): Logger =>\n    createLogger(level, format.combine(prefix({ label: `${sourceModule} ➝ ${destinationModule}` }), format.cli()))\n\nexport interface CreateWithAsyncLoggerOptions<TArgs extends unknown[], TReturnValue> {\n    onStart?: (logger: Logger, args: TArgs) => unknown\n    onSuccess?: (logger: Logger, args: TArgs, returnValue: TReturnValue) => unknown\n    onError?: (logger: Logger, args: TArgs, error: unknown) => unknown\n}\n\n/**\n * Helper higher order function for creating wrappers that log\n * execution of async functions.\n *\n * ```\n * const myAsyncFunction = async (name: string): Promise<number> => 6;\n *\n * // We can go with the default logger\n * const withAsyncLogger = createWithAsyncLogger()\n *\n * // Or supply our own\n * const withAsyncLogger = createWithAsyncLogger(() => createModuleLogger('my-module'))\n *\n * const myAsyncFunctionWithLogging = withAsyncLogger(myAsyncFunction, {\n *   onStart: (logger, [name]) => logger.info(`Starting myAsyncFunction with argument ${name}`)\n *   onSuccess: (logger, [name], retrurnValue) => logger.info(`Finished myAsyncFunction with argument ${name}, will return ${returnValue}`)\n *   onError: (logger, [name], error) => logger.info(`myAsyncFunction errored out with argument ${name}: ${error}`)\n * })\n *\n * // The wrapper function has the same signature as the wrapped function\n * await myAsyncFunctionWithLogging('Boris')\n * ```\n *\n * @param {() => Logger} [loggerFactory] Function that returns a `Logger` instance\n * @returns\n */\nexport const createWithAsyncLogger =\n    (loggerFactory: () => Logger = createLogger) =>\n    <TArgs extends unknown[], TReturnValue>(\n        fn: (...args: TArgs) => Promise<TReturnValue>,\n        { onStart, onSuccess, onError }: CreateWithAsyncLoggerOptions<TArgs, TReturnValue> = {}\n    ) => {\n        // We'll create the logger only when needed\n        let logger: Logger\n\n        return async (...args: TArgs): Promise<TReturnValue> => {\n            // If we don't have a logger yet, now is a great time to make one\n            logger = logger ?? loggerFactory()\n\n            // Let the consumer know that the execution has started\n            onStart?.(logger, args)\n\n            // Now try executing the actual function\n            try {\n                // In the happy case, the function gives us a return value back\n                const returnValue = await fn(...args)\n\n                // We try logging the return value\n                try {\n                    onSuccess?.(logger, args, returnValue)\n                } catch {\n                    // If the logger errors out, we ignore it\n                }\n\n                // And we return it\n                return returnValue\n            } catch (error) {\n                // In the unhappy, saddening and most disappointing case the function errors out\n\n                // We try logging the error\n                try {\n                    onError?.(logger, args, error)\n                } catch {\n                    // If the logger errors out, we ignore it\n                }\n\n                // And we rethrow\n                throw error\n            }\n        }\n    }\n\n/**\n * Helper utility that prefixes logged messages\n * with label (wrapped in square brackets)\n *\n * An example of logged message with `ethereum-mainnet` label:\n *\n * `[ethereum-mainnet] Some message`\n */\nconst prefix = format((info, { label }) => ({\n    ...info,\n    message: `${label ? `[${label}] ` : ''}${info.message}`,\n}))\n","import { createModuleLogger } from '@/stdio/logger'\nimport { accessSync, constants, lstatSync } from 'fs'\n\nexport const isDirectory = (path: string): boolean => {\n    try {\n        return lstatSync(path).isDirectory()\n    } catch {\n        return false\n    }\n}\n\nexport const isFile = (path: string): boolean => {\n    try {\n        return lstatSync(path).isFile()\n    } catch {\n        return false\n    }\n}\n\nexport const isReadable = (path: string): boolean => {\n    try {\n        return accessSync(path, constants.R_OK), true\n    } catch {\n        return false\n    }\n}\n\n/**\n * CJS/ESM interoperable utility for importing JS/TS/JSON files\n *\n * This utility is not safe in a sense that it will not check for file existence\n * before trying to import it, consumers need to do that\n *\n * @param {string} path\n * @returns {unknown} imported module\n */\nexport const importDefault = async (path: string): Promise<unknown> => {\n    const logger = createModuleLogger('filesystem')\n\n    // Let's use a dynamic import first\n    //\n    // This will not work in new node versions without experimental ESM module support\n    try {\n        logger.debug(`Importing default from '${path}' using dynamic import`)\n        const result = await import(path)\n\n        if (result != null && 'default' in result) {\n            return logger.debug(`Found default in '${path}' using dynamic import`), result.default\n        }\n\n        // If not let's just return the whole export\n        return logger.debug(`Did not find default in '${path}' using dynamic import, returning the whole thing`), result\n    } catch (error) {\n        logger.debug(`Failed to import from '${path}' using dynamic import: ${error}`)\n    }\n\n    // If dynamic import fails, let's use good ol' require\n    try {\n        logger.debug(`Importing default from '${path}' using require`)\n        const result = await require(path)\n\n        if (result != null && result.__esModule) {\n            return logger.debug(`Found default in '${path}' using require`), result.default\n        }\n\n        // If not let's just return the whole export\n        return logger.debug(`Did not find default in '${path}' using require, returning the whole thing`), result\n    } catch (error) {\n        logger.debug(`Failed to import from '${path}' using require: ${error}`)\n\n        // We'll just rethrow the second error\n        throw error\n    }\n}\n","import { ColumnUserConfig, getBorderCharacters, table } from 'table'\nimport chalk from 'chalk'\nimport type { ZodError } from 'zod'\n\ntype Preprocess = (value: string) => string\nexport const COLORS = {\n    TRUE: chalk.rgb(0, 153, 0), // GREEN\n    FALSE: chalk.rgb(255, 0, 0), // RED\n    NOT_APPLICABLE: chalk.rgb(255, 128, 0), // ORANGE\n    DEFAULT_KEY: chalk.rgb(255, 255, 255), // WHITE\n    DEFAULT_VALUE: chalk.rgb(167, 125, 255), // MAGENTA\n}\n\n/**\n * Returns a JSON-serialized version of a string, replacing all `BigInt`\n * instances with strings\n *\n * ```\n * const json = printJson({ a: BigInt(1) }) // { \"a\": \"1\" }\n * ```\n *\n * @param {unknown} obj Object to serialize\n * @param {boolean} [pretty] Return a pretty, tab-delimited JSON string. Defaults to true.\n * @returns {string}\n */\nexport const printJson = (obj: unknown, pretty = true): string =>\n    JSON.stringify(\n        obj,\n        (key, value) => (typeof value === 'bigint' ? value.toString(10) : value),\n        pretty ? '\\t' : undefined\n    )\n\n/**\n * Helper function for the other printers.\n *\n * Will check for the value type and either print a string representation\n * of the value or use `printRecord` if possible.\n *\n * @see {@link printRecord}\n *\n * @param value\n * @param keyColor - color of keys in table (DEFAULT: WHITE)\n * @param valueColor - color of values in table (DEFAULT: MAGENTA)\n * @returns\n */\nconst printValue = (\n    value: unknown,\n    keyColor: Preprocess = COLORS.DEFAULT_KEY,\n    valueColor: Preprocess = COLORS.DEFAULT_VALUE\n): string => {\n    switch (true) {\n        case value == null:\n        case value instanceof Date:\n        case typeof value !== 'object':\n            return valueColor(String(value))\n\n        default:\n            return printRecord(value, undefined, keyColor, valueColor)\n    }\n}\n\nexport const printRecord = <TRecord extends object>(\n    obj: TRecord,\n    title?: string | number,\n    keyColor: Preprocess = COLORS.DEFAULT_KEY,\n    valueColor: Preprocess = COLORS.DEFAULT_VALUE\n): string => {\n    const rows = Object.entries(obj).map(([key, value]): string[] => [\n        keyColor(key),\n        printValue(value, keyColor, valueColor),\n    ])\n\n    if (title != null) {\n        rows.unshift([keyColor(String(title)), ''])\n    }\n\n    // The table library throws if there are no rows so we need to take care of that possibility\n    if (rows.length === 0) {\n        return ''\n    }\n\n    return table(rows, {\n        border: getBorderCharacters('norc'),\n        spanningCells: title == null ? undefined : [{ col: 0, row: 0, colSpan: 2 }],\n    })\n}\n\n/**\n * Renders a cross table with rows labeled by object properties\n * and columns labeled by an optional header.\n *\n * If passed, the header should also account for the first column containing\n * the property name.\n *\n * @param {Record<string | number, unknown>} records\n * @param {string[]} [headers] - header row if provided\n * @param {boolean} [center] - center text if true\n * @param {Preprocess} [keyColor=COLORS.DEFAULT_KEY] keyColor - color of keys in table\n * @param {Preprocess} [valueColor=COLORS.DEFAULT_VALUE] valueColor - color of values in table\n * @returns {string}\n */\nexport const printCrossTable = <TRecord extends Record<string | number, unknown>>(\n    records: TRecord[],\n    headers?: string[],\n    center?: boolean,\n    keyColor: Preprocess = COLORS.DEFAULT_KEY,\n    valueColor: Preprocess = COLORS.DEFAULT_VALUE\n): string => {\n    const columns: ColumnUserConfig[] = center\n        ? (['left', ...records.map(() => 'center')].map((alignment) => ({ alignment })) as ColumnUserConfig[])\n        : []\n    // Set the colored headers if provided\n    const headerRow: string[] = headers?.map((header) => keyColor(header)) ?? []\n    const rows: string[][] = [headerRow]\n\n    // We'll gather all the properties of all the records in this array\n    //\n    // We do this in case some of the objects were missing any properties -\n    // we take all the properties of all the objects, then mark the ones we already added\n    // to our table in the set below. That way, if there is a property present on one object only,\n    // it will still be added to the table\n    const properties = records.flatMap(Object.keys)\n    const propertiesLeft: Set<string> = new Set(properties)\n\n    for (const property of properties) {\n        // If we already added this one, we continue\n        if (!propertiesLeft.has(property)) {\n            continue\n        }\n\n        // Now we mark the property as added\n        propertiesLeft.delete(property)\n\n        // Get all the values and print them\n        const values = records.map((record) => printValue(record[property], keyColor, valueColor))\n\n        // Create a row with the property label first\n        const row = [keyColor(property), ...values]\n\n        // And add to the table\n        rows.push(row)\n    }\n\n    return table(rows, { border: getBorderCharacters('norc'), columns })\n}\n\n/**\n * Helper utility for printing out boolean values\n *\n * @param {boolean | null | undefined} value\n * @param {Preprocess} [nullColor=COLORS.NOT_APPLICABLE] nullColor\n * @param {Preprocess} [trueColor=COLORS.TRUE] trueColor\n * @param {Preprocess} [falseColor=COLORS.FALSE] falseColor\n * @returns {string}\n */\nexport const printBoolean = (\n    value: boolean | null | undefined,\n    nullColor: Preprocess = COLORS.NOT_APPLICABLE,\n    trueColor: Preprocess = COLORS.TRUE,\n    falseColor: Preprocess = COLORS.FALSE\n): string => (value == null ? nullColor('∅') : value ? trueColor('✓') : falseColor('⤫'))\n\nexport const printZodErrors = (error: ZodError<unknown>): string => {\n    // Here we will go through all the errors and prefix them with the name\n    // of the property on which they happened, if any\n    const errors = error.flatten((issue) => {\n        const propertyPath = issue.path?.join('.') ?? ''\n        if (propertyPath === '') {\n            return issue.message\n        }\n\n        return `Property '${propertyPath}': ${issue.message}`\n    })\n\n    // These are the errors coming from a mismatch on the root object - e.g. when a whole object is completely missing\n    const formErrors = errors.formErrors\n\n    // These are errors coming from object properties\n    const fieldErrors = Object.values<unknown[]>(errors.fieldErrors).flat()\n\n    // Now we take all the errors we got\n    const allErrors = [...formErrors, ...fieldErrors]\n\n    // And concatenate\n    return allErrors.join(`\\n`)\n}\n","import { importDefault, isFile, isReadable } from '@/filesystem/filesystem'\nimport { createModuleLogger } from '@/stdio/logger'\nimport { printZodErrors } from '@/stdio/printer'\nimport { resolve } from 'path'\nimport { z } from 'zod'\n\n/**\n * @deprecated Please use `createConfigLoadFlow` from `@layerzerolabs/devtools`\n */\nexport const createConfigLoader =\n    <TConfig>(schema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>, logger = createModuleLogger('config loader')) =>\n    async (path: string): Promise<TConfig> => {\n        const absolutePath = resolve(path)\n        logger.verbose(`Resolved config file location for '${path}': '${absolutePath}'`)\n\n        // First we check that the config file is indeed there and we can read it\n        logger.verbose(`Checking config file '${absolutePath}' for existence & readability`)\n        const isConfigReadable = isFile(absolutePath) && isReadable(absolutePath)\n        if (!isConfigReadable) {\n            throw new Error(\n                `Unable to read config file '${path}'. Check that the file exists and is readable to your terminal user`\n            )\n        }\n\n        // Keep talking to the user\n        logger.verbose(`Config file '${absolutePath}' exists & is readable`)\n\n        // Now let's see if we can load the config file\n        let rawConfig: unknown\n        try {\n            logger.verbose(`Loading config file '${absolutePath}'`)\n\n            rawConfig = await importDefault(absolutePath)\n        } catch (error) {\n            throw new Error(`Unable to read config file '${path}': ${error}`)\n        }\n\n        logger.verbose(`Loaded config file '${absolutePath}'`)\n\n        // Now let's check whether the config file contains a function\n        //\n        // If so, we'll execute this function and will expect a config as a result\n        let rawConfigMaterialized: unknown\n        if (typeof rawConfig === 'function') {\n            logger.verbose(`Executing configuration function from config file '${absolutePath}'`)\n\n            try {\n                rawConfigMaterialized = await rawConfig()\n            } catch (error) {\n                throw new Error(`Got an exception while executing config funtion from file '${path}': ${error}`)\n            }\n        } else {\n            logger.verbose(`Using exported value from config file '${absolutePath}'`)\n            rawConfigMaterialized = rawConfig\n        }\n\n        // It's time to make sure that the config is not malformed\n        //\n        // At this stage we are only interested in the shape of the data,\n        // we are not checking whether the information makes sense (e.g.\n        // whether there are no missing nodes etc)\n        logger.verbose(`Validating the structure of config file '${absolutePath}'`)\n\n        const configParseResult = await schema.safeParseAsync(rawConfigMaterialized)\n        if (configParseResult.success === false) {\n            const userFriendlyErrors = printZodErrors(configParseResult.error)\n\n            throw new Error(\n                `Config from file '${path}' is malformed. Please fix the following errors:\\n\\n${userFriendlyErrors}`\n            )\n        }\n\n        return configParseResult.data\n    }\n","const cardinalRules = new Intl.PluralRules('en-US')\n\nconst ordinalRules = new Intl.PluralRules('en-US', { type: 'ordinal' })\nconst ordinals: Record<Intl.LDMLPluralRule, string> = {\n    one: 'st',\n    two: 'nd',\n    few: 'rd',\n    other: 'th',\n    zero: 'th',\n    many: 'th',\n}\n\n/**\n * Turn a number into an ordinal.\n *\n * ```typescript\n * pluralizeOrdinal(7) // 7th\n * pluralizeOrdinal(1) // 1st\n * pluralizeOrdinal(19) // 19th\n * ```\n *\n * @param {number} n\n * @returns {string}\n */\nexport const pluralizeOrdinal = (n: number): string => {\n    const rule = ordinalRules.select(n)\n    const suffix = ordinals[rule]\n\n    return `${n}${suffix}`\n}\n\n/**\n * Choose a correct form of a noun based on cardinality.\n *\n * ```typescript\n * pluralizeNoun(7, 'cat') // cats\n * pluralizeNoun(1, 'cat') // cat\n * pluralizeNoun(19, 'cactus', 'cacti') // cacti\n * ```\n *\n * @param {number} n\n * @param {string} singular The singular form of the english noun\n * @param {string} [plural] Plural version of the noun for irregular cases\n * @returns {string}\n */\nexport const pluralizeNoun = (n: number, singular: string, plural: string = `${singular}s`): string => {\n    const rule = cardinalRules.select(n)\n    if (rule === 'one') {\n        return singular\n    }\n\n    return plural\n}\n","import assert from 'assert'\nimport prompts from 'prompts'\n\n/**\n * Helper utility to be used when raw access to prompts\n * is required.\n *\n * This should be passed to `onState` property of the options\n * to handle cases where the user sends a SIGTERM signal to the process\n * (ctrl + c) usually.\n *\n * If not passed in, the SIGTERM will cancel the prompt but the promise\n * will resolve with an invalid result and, what's more important,\n * if cursor had been hidden it will be swallowed and people will need to\n * restart their terminal to bring it back\n *\n * @param {{ aborted?: boolean}} state Prompts state object\n */\nexport const handlePromptState = (state: { aborted?: boolean }) => {\n    if (state.aborted) {\n        // If we don't re-enable the terminal cursor before exiting\n        // the program, the cursor will remain hidden\n        process.stdout.write('\\x1B[?25h')\n        process.stdout.write('\\n')\n        process.exit(1)\n    }\n}\n\nexport const promptToContinue = async (\n    message: string = 'Do you want to continue?',\n    defaultValue = true\n): Promise<boolean> => {\n    const { value } = await prompts({\n        type: 'confirm',\n        name: 'value',\n        message,\n        initial: defaultValue,\n        onState: handlePromptState,\n    })\n\n    assert(typeof value === 'boolean', `Invariant error: Expected a boolean response, got ${value}`)\n\n    return value\n}\n\n/**\n * Validation function for prompts (sync or async)\n *\n * Should return true if validation passed, false or an error message\n * if validation failed\n */\ntype PromptValidator<TValue extends string> = (value: TValue) => string | boolean | Promise<string | boolean>\n\ninterface TextProps {\n    /**\n     * Additional message to show to the user\n     */\n    hint?: string\n    defaultValue?: string\n    validate?: PromptValidator<string>\n}\n\nexport const promptForText = async (\n    message: string = 'Do you want to continue?',\n    { defaultValue, hint, validate }: TextProps = {}\n) => {\n    const { value } = await prompts({\n        type: 'text',\n        name: 'value',\n        hint,\n        message,\n        onState: handlePromptState,\n        validate,\n        initial: defaultValue,\n    })\n\n    return value\n}\n\nexport interface PromptOption<TValue> {\n    title: string\n    hint?: string\n    disabled?: boolean\n    selected?: boolean\n    value?: TValue\n}\n\ninterface SelectProps<TValue> {\n    options: PromptOption<TValue>[]\n    /**\n     * A message displayed to the user if they focus on a disabled value\n     */\n    disabledHint?: string\n}\n\nexport const promptToSelectOne = async <TValue>(message: string, { options }: SelectProps<TValue>): Promise<TValue> => {\n    const { value } = await prompts({\n        type: 'select',\n        name: 'value',\n        message,\n        choices: options,\n        onState: handlePromptState,\n    })\n\n    return value\n}\n\ninterface MultiSelectProps<TValue> extends SelectProps<TValue> {\n    /**\n     * Minimum number of options to select\n     */\n    min?: number\n    /**\n     * Maximum number of options to select\n     */\n    max?: number\n}\n\nexport const promptToSelectMultiple = async <TValue>(\n    message: string,\n    { options, disabledHint, min, max }: MultiSelectProps<TValue>\n): Promise<TValue[]> => {\n    const { value } = await prompts({\n        type: 'autocompleteMultiselect',\n        name: 'value',\n        message,\n        choices: options,\n        onState: handlePromptState,\n        warn: disabledHint,\n        min,\n        max,\n    })\n\n    return value\n}\n"]}