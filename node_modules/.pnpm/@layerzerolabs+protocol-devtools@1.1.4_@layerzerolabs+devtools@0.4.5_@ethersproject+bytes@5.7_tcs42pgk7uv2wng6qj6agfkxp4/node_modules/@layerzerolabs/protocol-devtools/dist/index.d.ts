import { IOmniSDK, OmniTransaction, OmniGraph, OmniPoint, OmniSDKFactory, Configurator, OmniAddress, Bytes32, PossiblyBytes } from '@layerzerolabs/devtools';
import { EndpointId } from '@layerzerolabs/lz-definitions';
import { z } from 'zod';

interface IDVN extends IOmniSDK {
    getDstConfig(eid: EndpointId): Promise<DVNDstConfig>;
    setDstConfig(eid: EndpointId, value: DVNDstConfig): Promise<OmniTransaction>;
}
interface DVNDstConfig {
    gas: bigint;
    multiplierBps: bigint;
    floorMarginUSD: bigint;
}
interface DVNEdgeConfig {
    dstConfig: DVNDstConfig;
}
type DVNOmniGraph = OmniGraph<unknown, DVNEdgeConfig>;
type DVNFactory<TDVN extends IDVN = IDVN, TOmniPoint = OmniPoint> = OmniSDKFactory<TDVN, TOmniPoint>;
type DVNConfigurator<TDVN extends IDVN = IDVN> = Configurator<DVNOmniGraph, TDVN>;

declare const configureDVN: DVNConfigurator;
declare const configureDVNDstConfig: DVNConfigurator;

declare const DVNDstConfigSchema: z.ZodObject<{
    gas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    multiplierBps: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    floorMarginUSD: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    gas: bigint;
    multiplierBps: bigint;
    floorMarginUSD: bigint;
}, {
    gas?: unknown;
    multiplierBps?: unknown;
    floorMarginUSD?: unknown;
}>;

declare enum Uln302ConfigType {
    Send = "send",
    Receive = "receive"
}
interface IUln302 extends IOmniSDK {
    /**
     * Gets the ULN config for a given endpoint ID and an address.
     *
     * If there is no executor config specified, this function will return the default
     * config set for this library and EndpointID
     *
     * @see {@link getAppUlnConfig}
     *
     * @param {EndpointId} eid Endpoint ID
     * @param {OmniAddress | null | undefined} address
     * @param {Uln302ConfigType} type
     */
    getUlnConfig(eid: EndpointId, address: OmniAddress | null | undefined, type: Uln302ConfigType): Promise<Uln302UlnConfig>;
    /**
     * Gets the ULN config for a given endpoint ID and an address.
     *
     * This function will not take the default executor config into account
     * as opposed to `getUlnConfig`
     *
     * @see {@link getUlnConfig}
     *
     * @param {EndpointId} eid Endpoint ID
     * @param {OmniAddress} address
     * @param {Uln302ConfigType} type
     */
    getAppUlnConfig(eid: EndpointId, address: OmniAddress, type: Uln302ConfigType): Promise<Uln302UlnConfig>;
    /**
     * Checks whether a given `config` is set explicitly on a given OApp.
     *
     * This method makes it easy to take the specifics of a particular VM implementation
     * into account when checking for differences in ULN configuration.
     *
     * @param {EndpointId} eid
     * @param {OmniAddress} oapp
     * @param {Uln302UlnUserConfig} config
     * @param {Uln302ConfigType} type
     * @returns {Promise<boolean>} `true` if the config has been explicitly set, `false` otherwise
     */
    hasAppUlnConfig(eid: EndpointId, oapp: OmniAddress, config: Uln302UlnUserConfig, type: Uln302ConfigType): Promise<boolean>;
    setDefaultUlnConfig(eid: EndpointId, config: Uln302UlnUserConfig): Promise<OmniTransaction>;
    /**
     * Gets the Executor config for a given endpoint ID and an address.
     *
     * If there is no executor config specified, this function will return the default
     * config set for this library and EndpointID
     *
     * @see {@link getAppExecutorConfig}
     *
     * @param {EndpointId} eid Endpoint ID
     * @param {PossiblyBytes | null} address
     */
    getExecutorConfig(eid: EndpointId, address?: OmniAddress | null | undefined): Promise<Uln302ExecutorConfig>;
    /**
     * Gets the Executor config for a given endpoint ID and an address.
     *
     * This function will not take the default executor config into account
     * as opposed to `getUlnConfig`
     *
     * @see {@link getExecutorConfig}
     *
     * @param {EndpointId} eid Endpoint ID
     * @param {PossiblyBytes} address
     */
    getAppExecutorConfig(eid: EndpointId, address: OmniAddress): Promise<Uln302ExecutorConfig>;
    /**
     * Checks whether a given `config` is set explicitly on a given OApp.
     *
     * This method makes it easy to take the specifics of a particular VM implementation
     * into account when checking for differences in Executor configuration.
     *
     * @param {EndpointId} eid
     * @param {OmniAddress} oapp
     * @param {Uln302ExecutorConfig} config
     * @returns {Promise<boolean>} `true` if the config has been explicitly set, `false` otherwise
     */
    hasAppExecutorConfig(eid: EndpointId, oapp: OmniAddress, config: Uln302ExecutorConfig): Promise<boolean>;
    setDefaultExecutorConfig(eid: EndpointId, config: Uln302ExecutorConfig): Promise<OmniTransaction>;
}
interface Uln302ExecutorConfig {
    maxMessageSize: number;
    executor: string;
}
interface Uln302UlnConfig {
    confirmations: bigint;
    optionalDVNThreshold: number;
    requiredDVNs: string[];
    optionalDVNs: string[];
}
/**
 * Uln302UlnConfig interface with optional properties left out
 * for user convenience.
 */
interface Uln302UlnUserConfig {
    confirmations?: bigint;
    optionalDVNThreshold?: number;
    requiredDVNs: string[];
    optionalDVNs?: string[];
}
interface Uln302NodeConfig {
    defaultExecutorConfigs: [eid: EndpointId, config: Uln302ExecutorConfig][];
    defaultUlnConfigs: [eid: EndpointId, config: Uln302UlnUserConfig][];
}
type Uln302OmniGraph = OmniGraph<Uln302NodeConfig, unknown>;
type Uln302Factory<TUln302 extends IUln302 = IUln302, TOmniPoint = OmniPoint> = OmniSDKFactory<TUln302, TOmniPoint>;
type Uln302Configurator<TUln302 extends IUln302 = IUln302> = Configurator<Uln302OmniGraph, TUln302>;

interface IUlnRead extends IOmniSDK {
    /**
     * Gets the ULN config for a given channel ID and an address.
     *
     * If executor, requiredDVNs, and optionalDVNs are not set, the default values for the library
     * and channel ID will be returned.
     *
     * @see {@link getAppUlnConfig}
     *
     * @param {number} channelId Channel Id
     * @param {OmniAddress | null | undefined} address
     */
    getUlnConfig(channelId: number, address: OmniAddress | null | undefined): Promise<UlnReadUlnConfig>;
    /**
     * Gets the ULN config for a given channel ID and an address.
     *
     * Returns only the user-configured values and doesn't take the default values into account.
     *
     * @see {@link getUlnConfig}
     *
     * @param {number} channelId Channel Id
     * @param {OmniAddress} address
     */
    getAppUlnConfig(channelId: number, address: OmniAddress): Promise<UlnReadUlnConfig>;
    /**
     * Checks whether a given `config` is set explicitly on a given OApp.
     *
     * This method makes it easy to take the specifics of a particular VM implementation
     * into account when checking for differences in ULN configuration.
     *
     * @param {number} channelId
     * @param {OmniAddress} oapp
     * @param {UlnReadUlnUserConfig} config
     * @returns {Promise<boolean>} `true` if the config has been explicitly set, `false` otherwise
     */
    hasAppUlnConfig(channelId: number, oapp: OmniAddress, config: UlnReadUlnUserConfig): Promise<boolean>;
    setDefaultUlnConfig(channelId: number, config: UlnReadUlnUserConfig): Promise<OmniTransaction>;
}
interface UlnReadUlnConfig {
    executor: string;
    optionalDVNThreshold: number;
    requiredDVNs: string[];
    optionalDVNs: string[];
}
/**
 * UlnReadUlnConfig interface with optional properties left out
 * for user convenience.
 */
interface UlnReadUlnUserConfig {
    executor?: string;
    optionalDVNThreshold?: number;
    requiredDVNs: string[];
    optionalDVNs?: string[];
}
interface UlnReadNodeConfig {
    defaultUlnConfigs: [channelId: number, config: UlnReadUlnUserConfig][];
}
type UlnReadOmniGraph = OmniGraph<UlnReadNodeConfig, unknown>;
type UlnReadFactory<TUlnRead extends IUlnRead = IUlnRead, TOmniPoint = OmniPoint> = OmniSDKFactory<TUlnRead, TOmniPoint>;
type UlnReadConfigurator<TUlnRead extends IUlnRead = IUlnRead> = Configurator<UlnReadOmniGraph, TUlnRead>;

interface IEndpointV2 extends IOmniSDK {
    getUln302SDK(address: OmniAddress): Promise<IUln302>;
    getUlnReadSDK(address: OmniAddress): Promise<IUlnRead>;
    getDelegate(oapp: OmniAddress): Promise<OmniAddress | undefined>;
    isDelegate(oapp: OmniAddress, delegate: OmniAddress): Promise<boolean>;
    getDefaultReceiveLibrary(eid: EndpointId): Promise<OmniAddress | undefined>;
    setDefaultReceiveLibrary(eid: EndpointId, uln: OmniAddress | null | undefined, gracePeriod?: bigint): Promise<OmniTransaction>;
    getDefaultSendLibrary(eid: EndpointId): Promise<OmniAddress | undefined>;
    setDefaultSendLibrary(eid: EndpointId, uln: OmniAddress | null | undefined): Promise<OmniTransaction>;
    isRegisteredLibrary(uln: OmniAddress): Promise<boolean>;
    registerLibrary(uln: OmniAddress): Promise<OmniTransaction>;
    getSendLibrary(sender: OmniAddress, dstEid: EndpointId): Promise<OmniAddress | undefined>;
    getReceiveLibrary(receiver: OmniAddress, srcEid: EndpointId): Promise<[address: Bytes32 | undefined, isDefault: boolean]>;
    getDefaultReceiveLibraryTimeout(eid: EndpointId): Promise<Timeout>;
    getReceiveLibraryTimeout(receiver: OmniAddress, srcEid: EndpointId): Promise<Timeout>;
    setSendLibrary(oapp: OmniAddress, eid: EndpointId, uln: OmniAddress): Promise<OmniTransaction>;
    /**
     * Returns the default send library for a given OApp and a destination
     * endpoint ID.
     *
     * This function will not throw if passed a zero address.
     *
     * @param {OmniAddress | Bytes32} sender OmniAddress of the OApp
     * @param {EndpointId} dstEid Destination endpoint ID
     */
    isDefaultSendLibrary(sender: PossiblyBytes, dstEid: EndpointId): Promise<boolean>;
    setReceiveLibrary(oapp: OmniAddress, eid: EndpointId, uln: OmniAddress, gracePeriod: bigint): Promise<OmniTransaction>;
    setReceiveLibraryTimeout(oapp: OmniAddress, eid: EndpointId, uln: OmniAddress, expiry: bigint): Promise<OmniTransaction>;
    /**
     * Gets the executor config for a given OApp, library and a destination
     * endpoint ID.
     *
     * If there is no executor config specified, this function will return the default
     * config set for this library and EndpointID
     *
     * @see {@link getAppExecutorConfig}
     *
     * @param {PossiblyBytes} oapp OApp address
     * @param {PossiblyBytes} uln Library address
     * @param {EndpointId} eid Endpoint ID
     */
    getExecutorConfig(oapp: PossiblyBytes, uln: OmniAddress, eid: EndpointId): Promise<Uln302ExecutorConfig>;
    /**
     * Gets the executor config for a given OApp, library and a destination
     * endpoint ID.
     *
     * This function will not take the default executor config into account
     * as opposed to `getExecutorConfig`
     *
     * @see {@link getExecutorConfig}
     *
     * @param {PossiblyBytes} oapp OApp address
     * @param {PossiblyBytes} uln Library address
     * @param {EndpointId} eid Endpoint ID
     */
    getAppExecutorConfig(oapp: PossiblyBytes, uln: OmniAddress, eid: EndpointId): Promise<Uln302ExecutorConfig>;
    /**
     * Checks whether a given `config` is set explicitly for a given OApp
     * on a particular ULN
     *
     * This method makes it easy to take the specifics of a particular VM implementation
     * into account when checking for differences in Executor configuration.
     *
     * @see {@link IUln302.hasAppExecutorConfig}
     *
     * @param {OmniAddress} oapp
     * @param {OmniAddress} uln
     * @param {EndpointId} eid
     * @param {Uln302ExecutorConfig} config
     * @returns {Promise<boolean>} `true` if the config has been explicitly set, `false` otherwise
     */
    hasAppExecutorConfig(oapp: OmniAddress, uln: OmniAddress, eid: EndpointId, config: Uln302ExecutorConfig): Promise<boolean>;
    setExecutorConfig(oapp: PossiblyBytes, uln: PossiblyBytes, setExecutorConfig: Uln302SetExecutorConfig[]): Promise<OmniTransaction[]>;
    /**
     * Gets the ULN config for a given OApp, library and a destination
     * endpoint ID.
     *
     * If there is no ULN config specified, this function will return the default
     * config set for this library and EndpointID
     *
     * @see {@link getAppUlnConfig}
     *
     * @param {PossiblyBytes} oapp OApp address
     * @param {PossiblyBytes} uln Library address
     * @param {EndpointId} eid Endpoint ID
     * @param {Uln302ConfigType} type
     */
    getUlnConfig(oapp: OmniAddress, uln: OmniAddress, eid: EndpointId, type: Uln302ConfigType): Promise<Uln302UlnConfig>;
    /**
     * Gets the ULN config for a given OApp, library and a destination
     * endpoint ID.
     *
     * This function will not take the default executor config into account
     * as opposed to `getUlnConfig`
     *
     * @see {@link getUlnConfig}
     *
     * @param {PossiblyBytes} oapp OApp address
     * @param {PossiblyBytes} uln Library address
     * @param {EndpointId} eid Endpoint ID
     * @param {Uln302ConfigType} type
     */
    getAppUlnConfig(oapp: OmniAddress, uln: OmniAddress, eid: EndpointId, type: Uln302ConfigType): Promise<Uln302UlnConfig>;
    /**
     * Gets the Read ULN config for a given OApp, library and a destination
     * channel ID.
     *
     * This function will not take the default configs into account
     * as opposed to `getUlnReadConfig`
     *
     * @see {@link getUlnReadConfig}
     *
     * @param {PossiblyBytes} oapp OApp address
     * @param {PossiblyBytes} uln Library address
     * @param {number} channelId Channel ID
     */
    getAppUlnReadConfig(oapp: OmniAddress, uln: OmniAddress, channelId: number): Promise<UlnReadUlnConfig>;
    /**
     * Checks whether a given `config` is set explicitly for a given OApp
     * on a particular ULN
     *
     * @see {@link IUln302.hasAppUlnConfig}
     *
     * @param {OmniAddress} oapp
     * @param {OmniAddress} uln
     * @param {EndpointId} eid
     * @param {Uln302UlnUserConfig} config
     * @param {Uln302ConfigType} type
     * @returns {Promise<boolean>} `true` if the config has been explicitly set, `false` otherwise
     */
    hasAppUlnConfig(oapp: OmniAddress, uln: OmniAddress, eid: EndpointId, config: Uln302UlnUserConfig, type: Uln302ConfigType): Promise<boolean>;
    /**
     * Checks whether a given `config` is set explicitly for a given OApp
     * on a particular ULN
     *
     * @see {@link IUlnRead.hasAppUlnConfig}
     *
     * @param {OmniAddress} oapp
     * @param {OmniAddress} uln
     * @param {number} channelId
     * @param {UlnReadUlnUserConfig} config
     * @returns {Promise<boolean>} `true` if the config has been explicitly set, `false` otherwise
     */
    hasAppUlnReadConfig(oapp: OmniAddress, uln: OmniAddress, channelId: number, config: UlnReadUlnUserConfig): Promise<boolean>;
    setUlnConfig(oapp: OmniAddress, uln: OmniAddress, setUlnConfig: Uln302SetUlnConfig[]): Promise<OmniTransaction[]>;
    setUlnReadConfig(oapp: OmniAddress, uln: OmniAddress, setUlnConfig: UlnReadSetUlnConfig[]): Promise<OmniTransaction[]>;
    getUlnConfigParams(uln: OmniAddress, setUlnConfig: Uln302SetUlnConfig[]): Promise<SetConfigParam[]>;
    getUlnReadConfigParams(uln: OmniAddress, setUlnConfig: UlnReadSetUlnConfig[]): Promise<SetConfigParam[]>;
    getExecutorConfigParams(uln: OmniAddress, setExecutorConfig: Uln302SetExecutorConfig[]): Promise<SetConfigParam[]>;
    setConfig(oapp: OmniAddress, uln: OmniAddress, setConfigParam: SetConfigParam[]): Promise<OmniTransaction[]>;
    quote(params: MessageParams, sender: OmniAddress): Promise<MessagingFee>;
}
interface Uln302SetExecutorConfig {
    eid: EndpointId;
    executorConfig: Uln302ExecutorConfig;
}
interface Uln302SetUlnConfig {
    type: Uln302ConfigType;
    eid: EndpointId;
    ulnConfig: Uln302UlnUserConfig;
}
interface UlnReadSetUlnConfig {
    channelId: number;
    ulnConfig: UlnReadUlnUserConfig;
}
interface SetConfigParam {
    eid: EndpointId;
    configType: number;
    config: unknown;
}
interface MessageParams {
    dstEid: EndpointId;
    receiver: OmniAddress;
    message: string | Uint8Array;
    options: string | Uint8Array;
    payInLzToken: boolean;
}
interface MessagingFee {
    nativeFee: bigint;
    lzTokenFee: bigint;
}
interface Timeout {
    lib: string;
    expiry: bigint;
}
interface EndpointV2EdgeConfig {
    defaultReceiveLibrary: OmniAddress;
    defaultReceiveLibraryGracePeriod?: bigint;
    defaultSendLibrary: OmniAddress;
}
interface ReadChannelConfig {
    channelId: number;
    defaultReadLibrary: OmniAddress;
}
interface EndpointV2NodeConfig {
    readChannelConfigs?: ReadChannelConfig[];
}
type EndpointV2OmniGraph = OmniGraph<EndpointV2NodeConfig | undefined, EndpointV2EdgeConfig>;
type EndpointV2Factory<TEndpointV2 extends IEndpointV2 = IEndpointV2, TOmniPoint = OmniPoint> = OmniSDKFactory<TEndpointV2, TOmniPoint>;
type EndpointV2Configurator<TEndpointV2 extends IEndpointV2 = IEndpointV2> = Configurator<EndpointV2OmniGraph, TEndpointV2>;

declare const configureEndpointV2RegisterLibraries: EndpointV2Configurator;
declare const configureEndpointV2DefaultReceiveLibraries: EndpointV2Configurator;
declare const configureEndpointV2DefaultSendLibraries: EndpointV2Configurator;
declare const configureEndpointV2DefaultReadLibraries: EndpointV2Configurator;
declare const configureEndpointV2: EndpointV2Configurator;

declare const TimeoutSchema: z.ZodObject<{
    lib: z.ZodString;
    expiry: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    lib: string;
    expiry: bigint;
}, {
    lib: string;
    expiry?: unknown;
}>;

interface IExecutor extends IOmniSDK {
    getDstConfig(eid: EndpointId): Promise<ExecutorDstConfig>;
    setDstConfig(eid: EndpointId, value: ExecutorDstConfig): Promise<OmniTransaction>;
}
interface ExecutorDstConfigPre2_1_27 {
    baseGas: bigint;
    lzComposeBaseGas?: never;
    lzReceiveBaseGas?: never;
    multiplierBps: bigint;
    floorMarginUSD: bigint;
    nativeCap: bigint;
}
interface ExecutorDstConfigPost2_1_27 {
    baseGas?: never;
    lzComposeBaseGas: bigint;
    lzReceiveBaseGas: bigint;
    multiplierBps: bigint;
    floorMarginUSD: bigint;
    nativeCap: bigint;
}
type ExecutorDstConfig = ExecutorDstConfigPre2_1_27 | ExecutorDstConfigPost2_1_27;
interface ExecutorEdgeConfig {
    dstConfig: ExecutorDstConfig;
}
type ExecutorOmniGraph = OmniGraph<unknown, ExecutorEdgeConfig>;
type ExecutorFactory<TExecutor extends IExecutor = IExecutor, TOmniPoint = OmniPoint> = OmniSDKFactory<TExecutor, TOmniPoint>;
type ExecutorConfigurator<TExecutor extends IExecutor = IExecutor> = Configurator<ExecutorOmniGraph, TExecutor>;

declare const configureExecutor: ExecutorConfigurator;
declare const configureExecutorDstConfig: ExecutorConfigurator;

declare const ExecutorDstConfigPre2_1_27Schema: z.ZodObject<{
    baseGas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    multiplierBps: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    floorMarginUSD: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    nativeCap: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    multiplierBps: bigint;
    floorMarginUSD: bigint;
    baseGas: bigint;
    nativeCap: bigint;
}, {
    baseGas?: unknown;
    multiplierBps?: unknown;
    floorMarginUSD?: unknown;
    nativeCap?: unknown;
}>;
declare const ExecutorDstConfigPost2_1_27Schema: z.ZodObject<{
    lzComposeBaseGas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    lzReceiveBaseGas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    multiplierBps: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    floorMarginUSD: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    nativeCap: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    multiplierBps: bigint;
    floorMarginUSD: bigint;
    nativeCap: bigint;
    lzComposeBaseGas: bigint;
    lzReceiveBaseGas: bigint;
}, {
    lzComposeBaseGas?: unknown;
    lzReceiveBaseGas?: unknown;
    multiplierBps?: unknown;
    floorMarginUSD?: unknown;
    nativeCap?: unknown;
}>;
declare const ExecutorDstConfigSchema: z.ZodUnion<[z.ZodObject<{
    baseGas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    multiplierBps: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    floorMarginUSD: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    nativeCap: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    multiplierBps: bigint;
    floorMarginUSD: bigint;
    baseGas: bigint;
    nativeCap: bigint;
}, {
    baseGas?: unknown;
    multiplierBps?: unknown;
    floorMarginUSD?: unknown;
    nativeCap?: unknown;
}>, z.ZodObject<{
    lzComposeBaseGas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    lzReceiveBaseGas: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    multiplierBps: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    floorMarginUSD: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    nativeCap: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    multiplierBps: bigint;
    floorMarginUSD: bigint;
    nativeCap: bigint;
    lzComposeBaseGas: bigint;
    lzReceiveBaseGas: bigint;
}, {
    lzComposeBaseGas?: unknown;
    lzReceiveBaseGas?: unknown;
    multiplierBps?: unknown;
    floorMarginUSD?: unknown;
    nativeCap?: unknown;
}>]>;

interface IPriceFeed extends IOmniSDK {
    getPrice(eid: EndpointId): Promise<PriceData>;
    setPrice(eid: EndpointId, priceData: PriceData): Promise<OmniTransaction>;
}
interface PriceData {
    priceRatio: bigint;
    gasPriceInUnit: bigint;
    gasPerByte: bigint;
}
interface PriceFeedEdgeConfig {
    priceData: PriceData;
}
type PriceFeedOmniGraph = OmniGraph<unknown, PriceFeedEdgeConfig>;
type PriceFeedFactory<TPriceFeed extends IPriceFeed = IPriceFeed, TOmniPoint = OmniPoint> = OmniSDKFactory<TPriceFeed, TOmniPoint>;
type PriceFeedConfigurator<TPriceFeed extends IPriceFeed = IPriceFeed> = Configurator<PriceFeedOmniGraph, TPriceFeed>;

declare const configurePriceFeed: PriceFeedConfigurator;
declare const configurePriceFeedPriceData: PriceFeedConfigurator;

declare const PriceDataSchema: z.ZodObject<{
    priceRatio: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    gasPriceInUnit: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    gasPerByte: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    priceRatio: bigint;
    gasPriceInUnit: bigint;
    gasPerByte: bigint;
}, {
    priceRatio?: unknown;
    gasPriceInUnit?: unknown;
    gasPerByte?: unknown;
}>;

declare const configureUln302: Uln302Configurator;
declare const configureUln302DefaultExecutorConfigs: Uln302Configurator;
declare const configureUln302DefaultUlnConfigs: Uln302Configurator;

declare const Uln302ExecutorConfigSchema: z.ZodObject<{
    executor: z.ZodString;
    maxMessageSize: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, number, unknown>, z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    executor: string;
    maxMessageSize: number;
}, {
    executor: string;
    maxMessageSize?: unknown;
}>;
declare const Uln302UlnConfigSchema: z.ZodObject<{
    confirmations: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
    requiredDVNs: z.ZodArray<z.ZodString, "many">;
    optionalDVNs: z.ZodArray<z.ZodString, "many">;
    optionalDVNThreshold: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, number, unknown>, z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    confirmations: bigint;
    requiredDVNs: string[];
    optionalDVNs: string[];
    optionalDVNThreshold: number;
}, {
    requiredDVNs: string[];
    optionalDVNs: string[];
    confirmations?: unknown;
    optionalDVNThreshold?: unknown;
}>;
declare const Uln302UlnUserConfigSchema: z.ZodObject<{
    confirmations: z.ZodOptional<z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>>;
    requiredDVNs: z.ZodArray<z.ZodString, "many">;
    optionalDVNs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    optionalDVNThreshold: z.ZodOptional<z.ZodPipeline<z.ZodEffects<z.ZodUnknown, number, unknown>, z.ZodNumber>>;
}, "strip", z.ZodTypeAny, {
    requiredDVNs: string[];
    confirmations?: bigint | undefined;
    optionalDVNs?: string[] | undefined;
    optionalDVNThreshold?: number | undefined;
}, {
    requiredDVNs: string[];
    confirmations?: unknown;
    optionalDVNs?: string[] | undefined;
    optionalDVNThreshold?: unknown;
}>;

declare const configureUlnReadDefaultUlnConfigs: UlnReadConfigurator;
declare const configureUlnRead: UlnReadConfigurator;

declare const UlnReadUlnConfigSchema: z.ZodObject<{
    executor: z.ZodString;
    requiredDVNs: z.ZodArray<z.ZodString, "many">;
    optionalDVNs: z.ZodArray<z.ZodString, "many">;
    optionalDVNThreshold: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, number, unknown>, z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    executor: string;
    requiredDVNs: string[];
    optionalDVNs: string[];
    optionalDVNThreshold: number;
}, {
    executor: string;
    requiredDVNs: string[];
    optionalDVNs: string[];
    optionalDVNThreshold?: unknown;
}>;
declare const UlnReadUlnUserConfigSchema: z.ZodObject<{
    executor: z.ZodOptional<z.ZodString>;
    requiredDVNs: z.ZodArray<z.ZodString, "many">;
    optionalDVNs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    optionalDVNThreshold: z.ZodOptional<z.ZodPipeline<z.ZodEffects<z.ZodUnknown, number, unknown>, z.ZodNumber>>;
}, "strip", z.ZodTypeAny, {
    requiredDVNs: string[];
    executor?: string | undefined;
    optionalDVNs?: string[] | undefined;
    optionalDVNThreshold?: number | undefined;
}, {
    requiredDVNs: string[];
    executor?: string | undefined;
    optionalDVNs?: string[] | undefined;
    optionalDVNThreshold?: unknown;
}>;

export { type DVNConfigurator, type DVNDstConfig, DVNDstConfigSchema, type DVNEdgeConfig, type DVNFactory, type DVNOmniGraph, type EndpointV2Configurator, type EndpointV2EdgeConfig, type EndpointV2Factory, type EndpointV2NodeConfig, type EndpointV2OmniGraph, type ExecutorConfigurator, type ExecutorDstConfig, type ExecutorDstConfigPost2_1_27, ExecutorDstConfigPost2_1_27Schema, type ExecutorDstConfigPre2_1_27, ExecutorDstConfigPre2_1_27Schema, ExecutorDstConfigSchema, type ExecutorEdgeConfig, type ExecutorFactory, type ExecutorOmniGraph, type IDVN, type IEndpointV2, type IExecutor, type IPriceFeed, type IUln302, type IUlnRead, type MessageParams, type MessagingFee, type PriceData, PriceDataSchema, type PriceFeedConfigurator, type PriceFeedEdgeConfig, type PriceFeedFactory, type PriceFeedOmniGraph, type ReadChannelConfig, type SetConfigParam, type Timeout, TimeoutSchema, Uln302ConfigType, type Uln302Configurator, type Uln302ExecutorConfig, Uln302ExecutorConfigSchema, type Uln302Factory, type Uln302NodeConfig, type Uln302OmniGraph, type Uln302SetExecutorConfig, type Uln302SetUlnConfig, type Uln302UlnConfig, Uln302UlnConfigSchema, type Uln302UlnUserConfig, Uln302UlnUserConfigSchema, type UlnReadConfigurator, type UlnReadFactory, type UlnReadNodeConfig, type UlnReadOmniGraph, type UlnReadSetUlnConfig, type UlnReadUlnConfig, UlnReadUlnConfigSchema, type UlnReadUlnUserConfig, UlnReadUlnUserConfigSchema, configureDVN, configureDVNDstConfig, configureEndpointV2, configureEndpointV2DefaultReadLibraries, configureEndpointV2DefaultReceiveLibraries, configureEndpointV2DefaultSendLibraries, configureEndpointV2RegisterLibraries, configureExecutor, configureExecutorDstConfig, configurePriceFeed, configurePriceFeedPriceData, configureUln302, configureUln302DefaultExecutorConfigs, configureUln302DefaultUlnConfigs, configureUlnRead, configureUlnReadDefaultUlnConfigs };
