import { UIntBigIntSchema, createConfigureMultiple, OmniPointMap, formatOmniPoint, createConfigureEdges, formatOmniVector, createConfigureNodes, AddressSchema, UIntNumberSchema, flattenTransactions, isDeepEqual } from '@layerzerolabs/devtools';
import { z } from 'zod';
import { createWithAsyncLogger, printBoolean, createModuleLogger } from '@layerzerolabs/io-devtools';

// src/dvn/config.ts
var configureDVN = async (graph, createSdk) => flattenTransactions([await configureDVNDstConfig(graph, createSdk)]);
var configureDVNDstConfig = async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.connections.map(async ({ vector: { from, to }, config }) => {
      const sdk = await createSdk(from);
      const dstConfig = await sdk.getDstConfig(to.eid);
      if (isDeepEqual(dstConfig, config.dstConfig)) {
        return [];
      }
      return [await sdk.setDstConfig(to.eid, config.dstConfig)];
    })
  )
);
var DVNDstConfigSchema = z.object({
  gas: UIntBigIntSchema,
  multiplierBps: UIntBigIntSchema,
  floorMarginUSD: UIntBigIntSchema
});
var createEndpointV2Logger = () => createModuleLogger("EndpointV2");
var withEndpointV2Logger = createWithAsyncLogger(createEndpointV2Logger);
var configureEndpointV2RegisterLibraries = withEndpointV2Logger(
  createConfigureMultiple(
    withEndpointV2Logger(
      async (graph, createSdk) => {
        const logger = createEndpointV2Logger();
        const librariesByEndpoint = graph.connections.reduce(
          (librariesByEndpoint2, { vector: { from }, config }) => librariesByEndpoint2.set(
            from,
            librariesByEndpoint2.getOrElse(from, () => /* @__PURE__ */ new Set()).add(config.defaultReceiveLibrary).add(config.defaultSendLibrary)
          ),
          new OmniPointMap()
        );
        graph.contracts.forEach(({ point, config }) => {
          var _a;
          (_a = config == null ? void 0 : config.readChannelConfigs) == null ? void 0 : _a.forEach(
            ({ defaultReadLibrary }) => librariesByEndpoint.getOrElse(point, () => /* @__PURE__ */ new Set()).add(defaultReadLibrary)
          );
        });
        const omniTransactions = [];
        logger.verbose(`Checking libraries for registration`);
        for (const [from, libraries] of librariesByEndpoint) {
          const sdk = await createSdk(from);
          const label = formatOmniPoint(from);
          for (const address of libraries) {
            const isRegistered = await sdk.isRegisteredLibrary(address);
            logger.verbose(`Checking library ${address} for registration on ${label}`);
            if (isRegistered) {
              logger.verbose(`Library ${address} is already registered on ${label}`);
              continue;
            }
            logger.verbose(`Registering library ${address} on ${label}`);
            omniTransactions.push(await sdk.registerLibrary(address));
          }
        }
        return omniTransactions;
      },
      {
        onStart: (logger) => logger.verbose(`Checking register libraries configuration`),
        onSuccess: (logger) => logger.verbose(`${printBoolean(true)} Checked register libraries configuration`),
        onError: (logger, _graph, error) => logger.error(`Failed to check register libraries configuration: ${error}`)
      }
    )
  )
);
var configureEndpointV2DefaultReceiveLibraries = withEndpointV2Logger(
  createConfigureEdges(
    withEndpointV2Logger(
      async ({ vector: { from, to }, config }, sdk) => {
        const logger = createEndpointV2Logger();
        const label = formatOmniVector({ from, to });
        const address = await sdk.getDefaultReceiveLibrary(to.eid);
        logger.verbose(`Checking default receive library for ${label}`);
        if (config.defaultReceiveLibrary === address) {
          logger.verbose(`Default receive library is already set to ${address} for ${label}, skipping`);
          return [];
        }
        logger.info(`Setting default receive library to ${config.defaultReceiveLibrary} for ${label}`);
        return [
          await sdk.setDefaultReceiveLibrary(
            to.eid,
            config.defaultReceiveLibrary,
            config.defaultReceiveLibraryGracePeriod
          )
        ];
      },
      {
        onStart: (logger, [{ vector }]) => logger.verbose(`Checking default receive libraries for ${formatOmniVector(vector)}`),
        onSuccess: (logger, [{ vector }]) => logger.verbose(
          `${printBoolean(true)} Checked default receive libraries for ${formatOmniVector(vector)}`
        ),
        onError: (logger, [{ vector }], error) => logger.error(`Failed to check default receive libraries for ${formatOmniVector(vector)}: ${error}`)
      }
    )
  )
);
var configureEndpointV2DefaultSendLibraries = withEndpointV2Logger(
  createConfigureEdges(
    withEndpointV2Logger(
      async ({ vector: { from, to }, config }, sdk) => {
        const logger = createEndpointV2Logger();
        const label = formatOmniVector({ from, to });
        const address = await sdk.getDefaultSendLibrary(to.eid);
        logger.verbose(`Checking default send library for ${label}`);
        if (config.defaultSendLibrary === address) {
          logger.verbose(`Default send library is already set to ${address} for ${label}, skipping`);
          return [];
        }
        logger.info(`Setting default send library to ${config.defaultSendLibrary} for ${label}`);
        return [await sdk.setDefaultSendLibrary(to.eid, config.defaultSendLibrary)];
      },
      {
        onStart: (logger, [{ vector }]) => logger.verbose(`Checking default send libraries for ${formatOmniVector(vector)}`),
        onSuccess: (logger, [{ vector }]) => logger.verbose(
          `${printBoolean(true)} Checked default send libraries for ${formatOmniVector(vector)}`
        ),
        onError: (logger, [{ vector }], error) => logger.error(`Failed to check default send libraries for ${formatOmniVector(vector)}: ${error}`)
      }
    )
  )
);
var configureEndpointV2DefaultReadLibraries = withEndpointV2Logger(
  createConfigureNodes(
    withEndpointV2Logger(
      async ({ config, point }, sdk) => {
        const logger = createEndpointV2Logger();
        const label = formatOmniPoint(point);
        const transactions = [];
        if (!(config == null ? void 0 : config.readChannelConfigs)) {
          logger.verbose(`readChannelConfigs not defined for ${label}, skipping`);
          return [];
        }
        logger.verbose(`Checking read channels ${label}`);
        for (const { channelId, defaultReadLibrary } of config.readChannelConfigs) {
          const sendAddress = await sdk.getDefaultSendLibrary(channelId);
          logger.verbose(`Checking default send library for channel ${channelId} for ${label}`);
          if (defaultReadLibrary === sendAddress) {
            logger.verbose(
              `Default send library for channel ${channelId} is already set to ${defaultReadLibrary} for ${label}`
            );
            continue;
          } else {
            logger.verbose(
              `Setting default send library for channel ${channelId} to ${defaultReadLibrary} for ${label}`
            );
            transactions.push(await sdk.setDefaultSendLibrary(channelId, defaultReadLibrary));
          }
          const receiveAddress = await sdk.getDefaultReceiveLibrary(channelId);
          logger.verbose(`Checking default receive library for channel ${channelId} for ${label}`);
          if (defaultReadLibrary === receiveAddress) {
            logger.verbose(
              `Default receive library for channel ${channelId} is already set to ${defaultReadLibrary} for ${label}`
            );
            continue;
          } else {
            logger.verbose(
              `Setting default receive library for channel ${channelId} to ${defaultReadLibrary} for ${label}`
            );
            transactions.push(await sdk.setDefaultReceiveLibrary(channelId, defaultReadLibrary));
          }
        }
        return transactions;
      },
      {
        onStart: (logger, [{ point }]) => logger.verbose(`Checking Endpoint default read libraries for ${formatOmniPoint(point)}`),
        onSuccess: (logger, [{ point }]) => logger.verbose(
          `${printBoolean(true)} Checked Endpoint default read libraries for ${formatOmniPoint(point)}`
        ),
        onError: (logger, [{ point }], error) => logger.error(
          `Failed to check Endpoint default read libraries for ${formatOmniPoint(point)}: ${error}`
        )
      }
    )
  )
);
var configureEndpointV2 = withEndpointV2Logger(
  createConfigureMultiple(
    configureEndpointV2RegisterLibraries,
    configureEndpointV2DefaultReceiveLibraries,
    configureEndpointV2DefaultSendLibraries,
    configureEndpointV2DefaultReadLibraries
  ),
  {
    onStart: (logger) => logger.info(`Checking EndpointV2 configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked EndpointV2 configuration`),
    onError: (logger, args, error) => logger.error(`Failed to check EndpointV2 configuration: ${error}`)
  }
);
var TimeoutSchema = z.object({
  lib: AddressSchema,
  expiry: UIntBigIntSchema
});
var configureExecutor = async (graph, createSdk) => flattenTransactions([await configureExecutorDstConfig(graph, createSdk)]);
var configureExecutorDstConfig = async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.connections.map(async ({ vector: { from, to }, config }) => {
      const sdk = await createSdk(from);
      const dstConfig = await sdk.getDstConfig(to.eid);
      if (isDeepEqual(dstConfig, config.dstConfig)) {
        return [];
      }
      return [await sdk.setDstConfig(to.eid, config.dstConfig)];
    })
  )
);
var ExecutorDstConfigPre2_1_27Schema = z.object({
  baseGas: UIntBigIntSchema,
  multiplierBps: UIntBigIntSchema,
  floorMarginUSD: UIntBigIntSchema,
  nativeCap: UIntBigIntSchema
});
var ExecutorDstConfigPost2_1_27Schema = z.object({
  lzComposeBaseGas: UIntBigIntSchema,
  lzReceiveBaseGas: UIntBigIntSchema,
  multiplierBps: UIntBigIntSchema,
  floorMarginUSD: UIntBigIntSchema,
  nativeCap: UIntBigIntSchema
});
var ExecutorDstConfigSchema = z.union([
  ExecutorDstConfigPre2_1_27Schema,
  ExecutorDstConfigPost2_1_27Schema
]);
var configurePriceFeed = async (graph, createSdk) => flattenTransactions([await configurePriceFeedPriceData(graph, createSdk)]);
var configurePriceFeedPriceData = async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.connections.map(async ({ vector: { from, to }, config }) => {
      const sdk = await createSdk(from);
      const priceData = await sdk.getPrice(to.eid);
      if (isDeepEqual(priceData, config.priceData)) {
        return [];
      }
      return [await sdk.setPrice(to.eid, config.priceData)];
    })
  )
);
var PriceDataSchema = z.object({
  priceRatio: UIntBigIntSchema,
  gasPriceInUnit: UIntBigIntSchema,
  gasPerByte: UIntBigIntSchema
});
var configureUln302 = async (graph, createSdk) => flattenTransactions([
  ...await configureUln302DefaultExecutorConfigs(graph, createSdk),
  ...await configureUln302DefaultUlnConfigs(graph, createSdk)
]);
var configureUln302DefaultExecutorConfigs = async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.contracts.map(async ({ point, config }) => {
      const sdk = await createSdk(point);
      return Promise.all(
        config.defaultExecutorConfigs.map(([eid, config2]) => sdk.setDefaultExecutorConfig(eid, config2))
      );
    })
  )
);
var configureUln302DefaultUlnConfigs = async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.contracts.map(async ({ point, config }) => {
      const sdk = await createSdk(point);
      return Promise.all(
        config.defaultUlnConfigs.map(([eid, config2]) => sdk.setDefaultUlnConfig(eid, config2))
      );
    })
  )
);
var Uln302ExecutorConfigSchema = z.object({
  executor: AddressSchema,
  maxMessageSize: UIntNumberSchema
});
var Uln302UlnConfigSchema = z.object({
  confirmations: UIntBigIntSchema,
  requiredDVNs: z.array(AddressSchema),
  optionalDVNs: z.array(AddressSchema),
  optionalDVNThreshold: UIntNumberSchema
});
var Uln302UlnUserConfigSchema = z.object({
  confirmations: UIntBigIntSchema.optional(),
  requiredDVNs: z.array(AddressSchema),
  optionalDVNs: z.array(AddressSchema).optional(),
  optionalDVNThreshold: UIntNumberSchema.optional()
});

// src/uln302/types.ts
var Uln302ConfigType = /* @__PURE__ */ ((Uln302ConfigType2) => {
  Uln302ConfigType2["Send"] = "send";
  Uln302ConfigType2["Receive"] = "receive";
  return Uln302ConfigType2;
})(Uln302ConfigType || {});
var createUlnReadLogger = () => createModuleLogger("UlnRead");
var withUlnReadLogger = createWithAsyncLogger(createUlnReadLogger);
var configureUlnReadDefaultUlnConfigs = withUlnReadLogger(
  createConfigureNodes(
    withUlnReadLogger(async ({ config, point }, sdk) => {
      const logger = createUlnReadLogger();
      const label = formatOmniPoint(point);
      const omniTransactions = [];
      if (!config.defaultUlnConfigs) {
        logger.verbose(`defaultUln configuration not set for ${label}, skipping`);
        return [];
      }
      for (const [channelId, ulnConfig] of config.defaultUlnConfigs) {
        logger.verbose(`Setting defaultUln configuration for ${label} on channel ${channelId}`);
        const transaction = await sdk.setDefaultUlnConfig(channelId, ulnConfig);
        omniTransactions.push(transaction);
        logger.verbose(`Set defaultUln configuration for ${label} on channel ${channelId}`);
      }
      return omniTransactions;
    })
  )
);
var configureUlnRead = withUlnReadLogger(
  createConfigureMultiple(configureUlnReadDefaultUlnConfigs),
  {
    onStart: (logger) => logger.info(`Checking UlnRead configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked UlnRead configuration`),
    onError: (logger, args, error) => logger.error(`Failed to check UlnRead configuration: ${error}`)
  }
);
var UlnReadUlnConfigSchema = z.object({
  executor: AddressSchema,
  requiredDVNs: z.array(AddressSchema),
  optionalDVNs: z.array(AddressSchema),
  optionalDVNThreshold: UIntNumberSchema
});
var UlnReadUlnUserConfigSchema = z.object({
  executor: AddressSchema.optional(),
  requiredDVNs: z.array(AddressSchema),
  optionalDVNs: z.array(AddressSchema).optional(),
  optionalDVNThreshold: UIntNumberSchema.optional()
});

export { DVNDstConfigSchema, ExecutorDstConfigPost2_1_27Schema, ExecutorDstConfigPre2_1_27Schema, ExecutorDstConfigSchema, PriceDataSchema, TimeoutSchema, Uln302ConfigType, Uln302ExecutorConfigSchema, Uln302UlnConfigSchema, Uln302UlnUserConfigSchema, UlnReadUlnConfigSchema, UlnReadUlnUserConfigSchema, configureDVN, configureDVNDstConfig, configureEndpointV2, configureEndpointV2DefaultReadLibraries, configureEndpointV2DefaultReceiveLibraries, configureEndpointV2DefaultSendLibraries, configureEndpointV2RegisterLibraries, configureExecutor, configureExecutorDstConfig, configurePriceFeed, configurePriceFeedPriceData, configureUln302, configureUln302DefaultExecutorConfigs, configureUln302DefaultUlnConfigs, configureUlnRead, configureUlnReadDefaultUlnConfigs };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map