'use strict';

var assert = require('assert');
var lzDefinitions = require('@layerzerolabs/lz-definitions');
var ioDevtools = require('@layerzerolabs/io-devtools');
var exponentialBackoff = require('exponential-backoff');
var zod = require('zod');
var bytes = require('@ethersproject/bytes');
var bs58 = require('bs58');
var jsYaml = require('js-yaml');
var path = require('path');
var swag = require('@layerzerolabs/io-devtools/swag');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var assert__default = /*#__PURE__*/_interopDefault(assert);
var bs58__default = /*#__PURE__*/_interopDefault(bs58);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var isDeepEqual = (a, b) => {
  try {
    return assert.deepStrictEqual(a, b), true;
  } catch (e) {
    return false;
  }
};
var arePointsEqual = (a, b) => a.address === b.address && a.eid === b.eid && a.contractName === b.contractName;
var areSameEndpoint = (a, b) => a.eid === b.eid;
var areVectorsEqual = (a, b) => arePointsEqual(a.from, b.from) && arePointsEqual(a.to, b.to);
var isVectorPossible = ({ from, to }) => lzDefinitions.endpointIdToStage(from.eid) === lzDefinitions.endpointIdToStage(to.eid);
var serializePoint = ({ address, eid }) => `${eid}|${address}`;
var serializeVector = ({ from, to }) => `${serializePoint(from)} \u2192 ${serializePoint(to)}`;
var vectorFromNodes = (a, b) => ({ from: a.point, to: b.point });
var withEid = (eid) => (value) => ({ ...value, eid });
var formatEid = (eid) => {
  var _a4;
  return (_a4 = lzDefinitions.EndpointId[eid]) != null ? _a4 : `Unknown EndpointId (${eid})`;
};
var formatOmniPoint = ({ eid, address, contractName }) => `[${address}${contractName ? ` (${contractName})` : ``} @ ${formatEid(eid)}]`;
var formatOmniVector = ({ from, to }) => `${formatOmniPoint(from)} \u2192 ${formatOmniPoint(to)}`;

// src/common/map.ts
var _keys, _values, _entries, _a;
var AbstractMap = class {
  constructor(entries = []) {
    __privateAdd(this, _keys, /* @__PURE__ */ new Map());
    __privateAdd(this, _values, /* @__PURE__ */ new Map());
    __privateAdd(this, _entries, /* @__PURE__ */ new Map());
    __publicField(this, _a, "HashMap");
    for (const [key, value] of entries) {
      this.set(key, value);
    }
  }
  clear() {
    __privateGet(this, _keys).clear();
    __privateGet(this, _values).clear();
    __privateGet(this, _entries).clear();
  }
  delete(key) {
    const serialized = this.hash(key);
    return __privateGet(this, _keys).delete(serialized), __privateGet(this, _values).delete(serialized), __privateGet(this, _entries).delete(serialized);
  }
  forEach(callbackfn, thisArg) {
    for (const [_, [key, value]] of __privateGet(this, _entries)) {
      callbackfn.apply(thisArg, [value, key, this]);
    }
  }
  get(key) {
    return __privateGet(this, _values).get(this.hash(key));
  }
  getOrElse(key, orElse) {
    return this.has(key) ? this.get(key) : orElse();
  }
  has(key) {
    return __privateGet(this, _keys).has(this.hash(key));
  }
  set(key, value) {
    const serialized = this.hash(key);
    return __privateGet(this, _keys).set(serialized, key), __privateGet(this, _values).set(serialized, value), __privateGet(this, _entries).set(serialized, [key, value]), this;
  }
  get size() {
    return __privateGet(this, _entries).size;
  }
  entries() {
    return __privateGet(this, _entries).values();
  }
  keys() {
    return __privateGet(this, _keys).values();
  }
  values() {
    return __privateGet(this, _values).values();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
_a = Symbol.toStringTag;
_keys = new WeakMap();
_values = new WeakMap();
_entries = new WeakMap();

// src/omnigraph/map.ts
var _a2;
var OmniPointMap = class extends AbstractMap {
  constructor() {
    super(...arguments);
    __publicField(this, _a2, "OmniPointMap");
  }
  hash(point) {
    return serializePoint(point);
  }
};
_a2 = Symbol.toStringTag;
var _a3;
var OmniVectorMap = class extends AbstractMap {
  constructor() {
    super(...arguments);
    __publicField(this, _a3, "OmniVectorMap");
  }
  hash(vector) {
    return serializeVector(vector);
  }
};
_a3 = Symbol.toStringTag;

// src/omnigraph/builder.ts
var _nodes, _edges, _assertCanAddEdge, assertCanAddEdge_fn;
var _OmniGraphBuilder = class _OmniGraphBuilder {
  constructor() {
    __privateAdd(this, _assertCanAddEdge);
    __privateAdd(this, _nodes, new OmniPointMap());
    __privateAdd(this, _edges, new OmniVectorMap());
  }
  /**
   * Syntactic sugar utility for cloning graphs
   *
   * @param {OmniGraph<TNodeConfig, TEdgeConfig>} graph
   * @returns {OmniGraph<TNodeConfig, TEdgeConfig>}
   */
  static fromGraph(graph) {
    return new _OmniGraphBuilder().addNodes(...graph.contracts).addEdges(...graph.connections);
  }
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  //
  //                      The builder methods
  //
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  addNodes(...nodes) {
    return nodes.forEach((node) => __privateGet(this, _nodes).set(node.point, node)), this;
  }
  addEdges(...edges) {
    return edges.forEach((edge) => {
      __privateMethod(this, _assertCanAddEdge, assertCanAddEdge_fn).call(this, edge);
      __privateGet(this, _edges).set(edge.vector, edge);
    }), this;
  }
  removeNodeAt(point) {
    return (
      // First we remove all edges between this node and any other nodes
      [...this.getEdgesFrom(point)].forEach((edge) => this.removeEdgeAt(edge.vector)), // Only then we remove the node itself
      __privateGet(this, _nodes).delete(point), this
    );
  }
  removeEdgeAt(vector) {
    return __privateGet(this, _edges).delete(vector), this;
  }
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  //
  //                      The accessor methods
  //
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  getNodeAt(point) {
    return __privateGet(this, _nodes).get(point);
  }
  getEdgeAt(vector) {
    return __privateGet(this, _edges).get(vector);
  }
  getEdgesFrom(point) {
    return this.edges.filter(({ vector: { from } }) => arePointsEqual(point, from));
  }
  getEdgesTo(point) {
    return this.edges.filter(({ vector: { to } }) => arePointsEqual(point, to));
  }
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  //
  //                     The config accessors
  //
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  get nodes() {
    return Array.from(__privateGet(this, _nodes).values());
  }
  get edges() {
    return Array.from(__privateGet(this, _edges).values());
  }
  get graph() {
    return {
      contracts: this.nodes,
      connections: this.edges
    };
  }
};
_nodes = new WeakMap();
_edges = new WeakMap();
_assertCanAddEdge = new WeakSet();
assertCanAddEdge_fn = function(edge) {
  const label = formatOmniVector(edge.vector);
  const from = formatOmniPoint(edge.vector.from);
  assert__default.default(isVectorPossible(edge.vector), `Cannot add edge ${label}: cannot connect the two endpoints`);
  assert__default.default(this.getNodeAt(edge.vector.from), `Cannot add edge ${label}: ${from} is not in the graph`);
};
var OmniGraphBuilder = _OmniGraphBuilder;

// src/transactions/utils.ts
var isNonNullable = (value) => value != null;
var flattenTransactions = (transations) => transations.filter(isNonNullable).flat();
var groupTransactionsByEid = (transactions) => transactions.reduce(
  (transactionsByEid, transaction) => {
    var _a4;
    return transactionsByEid.set(transaction.point.eid, [
      ...(_a4 = transactionsByEid.get(transaction.point.eid)) != null ? _a4 : [],
      transaction
    ]);
  },
  /* @__PURE__ */ new Map()
);
var isFailedSignAndSendResult = ([, failed]) => failed.length > 0;
var sequence = async (tasks) => {
  const collector = [];
  for (const task of tasks) {
    collector.push(await task());
  }
  return collector;
};
var parallel = async (tasks) => await Promise.all(tasks.map((task) => task()));
var createDefaultApplicative = (logger) => process.env.LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION ? (logger == null ? void 0 : logger.warn(`You are using experimental parallel configuration`), parallel) : sequence;
var mapError = async (task, toError) => {
  try {
    return await task();
  } catch (error) {
    throw toError(error);
  }
};
var tapError = async (task, onError) => {
  try {
    return await task();
  } catch (error) {
    try {
      await onError(error);
    } catch (e) {
    }
    throw error;
  }
};
var first = async (tasks) => {
  assert__default.default(tasks.length !== 0, `Must have at least one task for first()`);
  let lastError;
  for (const task of tasks) {
    try {
      return await task();
    } catch (error) {
      lastError = error;
    }
  }
  throw lastError;
};
var firstFactory = (...factories) => async (...input) => await first(factories.map((factory) => () => factory(...input)));
var createRetryFactory = (strategy = createSimpleRetryStrategy(3)) => (task) => async (...input) => {
  let currentInput = input;
  return exponentialBackoff.backOff(async () => task(...currentInput), {
    // We'll effectively disable the numOfAttempts for exponential backoff
    // since we want the behavior to be completely controlled by the strategy
    numOfAttempts: Number.POSITIVE_INFINITY,
    // The retry callback is called after an unsuccessful attemp
    //
    // It allows us to decide whether we want to keep trying or give up
    // (we can give up by returning false)
    //
    // We'll use this callback to allow the strategy to effectively make changes
    // to the input, thus allowing it to accommodate for things such as gas price increase
    // for transactions
    async retry(error, attempt) {
      const strategyOutput = await strategy(attempt, error, currentInput, input);
      if (typeof strategyOutput === "boolean") {
        return strategyOutput;
      }
      return currentInput = strategyOutput, true;
    }
  });
};
var createSimpleRetryStrategy = (numAttempts, wrappedStrategy) => {
  assert__default.default(numAttempts > 0, `Number of attempts for a strategy must be larger than 0`);
  return (attempt, error, previousInput, originalInput) => {
    if (attempt > numAttempts) {
      return false;
    }
    if (wrappedStrategy == null) {
      return true;
    }
    return wrappedStrategy(attempt, error, previousInput, originalInput);
  };
};

// src/omnigraph/config.ts
var createConfigureNodes = (createTransactions) => async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.contracts.map(async (node) => {
      const sdk = await createSdk(node.point);
      return await createTransactions(node, sdk, graph, createSdk);
    })
  )
);
var createConfigureEdges = (createTransactions) => async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.connections.map(async (edge) => {
      const sdk = await createSdk(edge.vector.from);
      return await createTransactions(edge, sdk, graph, createSdk);
    })
  )
);
var createConfigureMultiple = (...configurators) => async (graph, createSdk) => {
  const logger = ioDevtools.createModuleLogger("configuration");
  const tasks = configurators.map((configurator) => () => configurator(graph, createSdk));
  const applicative = createDefaultApplicative(logger);
  return flattenTransactions(await applicative(tasks));
};
var UIntBigIntSchema = zod.z.unknown().transform((value, ctx) => {
  if (typeof value === "bigint") {
    return value;
  }
  try {
    return BigInt(String(value));
  } catch (e) {
    ctx.addIssue({
      code: zod.z.ZodIssueCode.custom,
      message: `Invalid BigInt-like value`
    });
    return zod.z.NEVER;
  }
}).pipe(zod.z.bigint().nonnegative());
var UIntNumberSchema = zod.z.unknown().transform((value, ctx) => {
  try {
    return Number(value);
  } catch (e) {
    ctx.addIssue({
      code: zod.z.ZodIssueCode.custom,
      message: `Invalid Number-like value`
    });
    return zod.z.NEVER;
  }
}).pipe(zod.z.number().nonnegative().int());
var AddressSchema = zod.z.string();
var EndpointIdSchema = zod.z.nativeEnum(lzDefinitions.EndpointId).pipe(zod.z.number());
var OmniPointSchema = zod.z.object({
  address: AddressSchema,
  eid: EndpointIdSchema,
  contractName: zod.z.string().nullish()
});
var OmniVectorSchema = zod.z.object({
  from: OmniPointSchema,
  to: OmniPointSchema
});
var EmptyOmniNodeSchema = zod.z.object({
  point: OmniPointSchema,
  config: zod.z.unknown().optional()
});
var EmptyOmniEdgeSchema = zod.z.object({
  vector: OmniVectorSchema,
  config: zod.z.unknown().optional()
});
var isOmniPoint = (value) => OmniPointSchema.safeParse(value).success;
var isOmniGraphEmpty = ({ contracts, connections }) => contracts.length === 0 && connections.length === 0;
var createOmniNodeSchema = (configSchema) => EmptyOmniNodeSchema.extend({
  config: configSchema
});
var createOmniEdgeSchema = (configSchema) => EmptyOmniEdgeSchema.extend({
  config: configSchema
});
var createOmniGraphSchema = (nodeSchema, edgeSchema) => zod.z.object({
  contracts: zod.z.array(nodeSchema),
  connections: zod.z.array(edgeSchema)
});
var makeBytes32 = (bytes$1) => bytes.hexZeroPad(bytes$1 || "0x0", 32);
var areBytes32Equal = (a, b) => BigInt(makeBytes32(a)) === BigInt(makeBytes32(b));
var isZero = (value) => {
  switch (true) {
    case value === "0x":
    case value == null:
      return true;
    case typeof value === "string":
    case typeof value === "number":
    case typeof value === "bigint":
      return BigInt(value) === BigInt(0);
    default:
      return value.every((byte) => byte === 0);
  }
};
var ignoreZero = (value) => isZero(value) ? void 0 : value != null ? value : void 0;
var compareBytes32Ascending = (a, b) => Number(BigInt(makeBytes32(a)) - BigInt(makeBytes32(b)));
var normalizePeer = (address, eid) => {
  if (address == null) {
    return new Uint8Array(32);
  }
  const chainType = lzDefinitions.endpointIdToChainType(eid);
  switch (chainType) {
    case lzDefinitions.ChainType.SOLANA:
      return bs58__default.default.decode(address);
    case lzDefinitions.ChainType.APTOS:
    case lzDefinitions.ChainType.EVM:
      return toBytes32(fromHex(address));
    case lzDefinitions.ChainType.TON:
      return fromHex(address);
    default:
      throw new Error(`normalizePeer: Unsupported chain type ${chainType} ${formatEid(eid)}`);
  }
};
var denormalizePeer = (bytes, eid) => {
  if (bytes == null || isZero(bytes)) {
    return void 0;
  }
  const chainType = lzDefinitions.endpointIdToChainType(eid);
  switch (chainType) {
    case lzDefinitions.ChainType.SOLANA:
      return bs58__default.default.encode(toBytes32(bytes));
    case lzDefinitions.ChainType.APTOS:
      return toHex(toBytes32(bytes));
    case lzDefinitions.ChainType.EVM:
      return toHex(toBytes20(bytes));
    case lzDefinitions.ChainType.TON:
      return toHex(bytes);
    default:
      throw new Error(`denormalizePeer: Unsupported chain type ${chainType} ${formatEid(eid)}`);
  }
};
var toBytes32 = (bytes) => {
  assertZeroBytes(
    getLeftPadding(bytes, 32),
    `Cannot convert an array with more than 32 non-zero bytes into Bytes32. Got ${bytes} with length ${bytes.length}`
  );
  const bytes32 = new Uint8Array(32);
  return bytes32.set(bytes, 32 - bytes.length), bytes32;
};
var toBytes20 = (bytes) => {
  assertZeroBytes(
    getLeftPadding(bytes, 20),
    `Cannot convert an array with more than 20 non-zero bytes into Bytes20. Got ${bytes} with length ${bytes.length}`
  );
  return new Uint8Array(bytes.slice(-20));
};
var toHex = (bytes) => `0x${Buffer.from(bytes).toString("hex")}`;
var fromHex = (hex) => Uint8Array.from(Buffer.from(hex.replace(/^0x/, ""), "hex"));
var getLeftPadding = (bytes, length) => bytes.subarray(0, Math.max(bytes.length - length, 0));
var assertZeroBytes = (bytes, message) => bytes.forEach((byte) => assert__default.default(byte === 0, message));
var createDefaultRetryHandler = (loggerName = "AsyncRetriable") => {
  const logger = ioDevtools.createModuleLogger(loggerName);
  return (attempt, numAttempts, error, target, method, args) => {
    logger.debug(`Attempt ${attempt}/${numAttempts}: ${method}() with arguments: ${ioDevtools.printJson(args)}: ${error}`);
  };
};
var AsyncRetriable = (overrides = {}) => {
  return function AsyncRetriableDecorator(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    assert__default.default(
      typeof originalMethod === "function",
      `AsyncRetriable must be applied to an instance method, ${propertyKey} property looks more like ${typeof originalMethod}`
    );
    const handleRetry = (args) => (error, attempt) => {
      var _a4, _b, _c;
      const numAttempts = (_a4 = overrides.numAttempts) != null ? _a4 : AsyncRetriable.config.numAttempts;
      const onRetry = (_b = overrides.onRetry) != null ? _b : AsyncRetriable.config.onRetry;
      return (_c = onRetry(attempt, numAttempts, error, target, propertyKey, args)) != null ? _c : true;
    };
    const retriedMethod = function(...args) {
      var _a4, _b, _c;
      const enabled = (_a4 = overrides.enabled) != null ? _a4 : AsyncRetriable.config.enabled;
      if (!enabled) {
        return originalMethod.apply(this, args);
      }
      const maxDelay = (_b = overrides.numAttempts) != null ? _b : AsyncRetriable.config.maxDelay;
      const numAttempts = (_c = overrides.numAttempts) != null ? _c : AsyncRetriable.config.numAttempts;
      return exponentialBackoff.backOff(() => originalMethod.apply(this, args), {
        // A typical problem in our case is 429 Too many requests
        // which would still happen if we didn't introduce a bit of randomness into the delay
        jitter: "full",
        maxDelay,
        numOfAttempts: numAttempts,
        retry: handleRetry(args)
      });
    };
    return descriptor.value = retriedMethod, descriptor;
  };
};
var DEFAULT_CONFIG = {
  enabled: true,
  numAttempts: 3,
  onRetry: createDefaultRetryHandler()
};
AsyncRetriable.config = { ...DEFAULT_CONFIG };
AsyncRetriable.reset = () => {
  AsyncRetriable.config = { ...DEFAULT_CONFIG };
};

// src/common/strings.ts
var splitCommaSeparated = (value) => value.trim().split(/\s*,\s*/).filter(Boolean);
var serializeDockerComposeSpec = (spec) => jsYaml.dump(spec);
var createConfigExecuteFlow = ({
  logger = ioDevtools.createLogger(),
  configurator,
  sdkFactory
}) => async ({ graph }) => {
  logger.verbose(`Executing graph:

${ioDevtools.printJson(graph)}`);
  try {
    logger.verbose(`Validating graph`);
    OmniGraphBuilder.fromGraph(graph);
  } catch (error) {
    logger.verbose(`Provided graph does not look valid: ${error}`);
    throw new Error(`An error occurred while validating OmniGraph configuration: ${error}`);
  }
  try {
    return await configurator(graph, sdkFactory);
  } catch (error) {
    logger.verbose(`Encountered an error: ${error}`);
    throw new Error(`An error occurred while getting the OApp configuration: ${error}`);
  }
};
var createConfigLoadFlow = ({
  configSchema,
  logger = ioDevtools.createLogger()
}) => async ({ configPath }) => {
  logger.verbose(`Loading config from ${configPath}`);
  const absolutePath = path.resolve(configPath);
  logger.verbose(`Resolved config file location for '${configPath}': '${absolutePath}'`);
  logger.verbose(`Checking config file '${absolutePath}' for existence & readability`);
  const isConfigReadable = ioDevtools.isFile(absolutePath) && ioDevtools.isReadable(absolutePath);
  if (!isConfigReadable) {
    throw new Error(
      `Unable to read config file '${configPath}'. Check that the file exists and is readable to your terminal user`
    );
  }
  logger.verbose(`Config file '${absolutePath}' exists & is readable`);
  let rawConfig;
  try {
    logger.verbose(`Loading config file '${absolutePath}'`);
    rawConfig = await ioDevtools.importDefault(absolutePath);
  } catch (error) {
    throw new Error(`Unable to read config file '${configPath}': ${error}`);
  }
  logger.verbose(`Loaded config file '${absolutePath}'`);
  let rawConfigMaterialized;
  if (typeof rawConfig === "function") {
    logger.verbose(`Executing configuration function from config file '${absolutePath}'`);
    try {
      rawConfigMaterialized = await rawConfig();
    } catch (error) {
      throw new Error(`Got an exception while executing config funtion from file '${configPath}': ${error}`);
    }
  } else {
    logger.verbose(`Using exported value from config file '${absolutePath}'`);
    rawConfigMaterialized = rawConfig;
  }
  logger.verbose(`Validating the structure of config file '${absolutePath}'`);
  let configParseResult;
  try {
    configParseResult = await configSchema.safeParseAsync(rawConfigMaterialized);
  } catch (error) {
    throw new Error(`Config from file '${configPath}' is invalid: ${error}`);
  }
  if (configParseResult.success === false) {
    const userFriendlyErrors = ioDevtools.printZodErrors(configParseResult.error);
    throw new Error(
      `Config from file '${configPath}' is malformed. Please fix the following errors:

${userFriendlyErrors}`
    );
  }
  return configParseResult.data;
};

// src/transactions/format.ts
var formatOmniTransaction = (transaction) => {
  var _a4, _b, _c;
  return {
    Endpoint: formatEid(transaction.point.eid),
    OmniAddress: transaction.point.address,
    OmniContract: (_a4 = transaction.metadata) == null ? void 0 : _a4.contractName,
    "Function Name": (_b = transaction.metadata) == null ? void 0 : _b.functionName,
    "Function Arguments": (_c = transaction.metadata) == null ? void 0 : _c.functionArgs,
    Description: transaction.description,
    Data: transaction.data,
    Value: transaction.value,
    "Gas Limit": transaction.gasLimit
  };
};
var OmniSignerBase = class {
  constructor(eid) {
    /**
     * @deprecated Use `OmniSigner.getPoint()` instead
     */
    __publicField(this, "eid");
    this.eid = eid;
  }
  /**
   * helper method to ensure that the transaction we are trying to sign is on a correct network
   *
   * @param {OmniTransaction} transaction
   */
  assertTransaction(transaction) {
    assert__default.default(
      transaction.point.eid === this.eid,
      `Could not use signer for ${formatEid(this.eid)} to sign a transaction for ${formatOmniPoint(
        transaction.point
      )}`
    );
  }
};
var createSignAndSend = (createSigner) => async (transactions, onProgress) => {
  const logger = ioDevtools.createModuleLogger("sign & send");
  const n = transactions.length;
  if (n === 0) {
    return logger.debug(`No transactions to sign, exiting`), [[], [], []];
  }
  logger.debug(`Signing ${n} ${ioDevtools.pluralizeNoun(n, "transaction")}`);
  const transactionGroups = Array.from(groupTransactionsByEid(transactions).entries());
  const successful = [];
  const errors = [];
  const handleSuccess = (result) => {
    successful.push(result);
    onProgress == null ? void 0 : onProgress(result, [...successful]);
  };
  const handleError = (error) => {
    errors.push(error);
  };
  const useBatchedWait = !!process.env.LZ_ENABLE_EXPERIMENTAL_BATCHED_WAIT;
  if (useBatchedWait) {
    logger.warn(`You are using experimental batched transaction waiting`);
  }
  const useBatchedSend = !!process.env.LZ_ENABLE_EXPERIMENTAL_BATCHED_SEND;
  if (useBatchedSend) {
    logger.warn(`You are using experimental batched transaction sending`);
  }
  const fallbackSignerLogic = useBatchedWait ? waitAfterSendingAll : waitBeforeSubmittingNext;
  const signerLogic = useBatchedSend ? sendBatchedIfAvailable(fallbackSignerLogic) : fallbackSignerLogic;
  await Promise.allSettled(
    transactionGroups.map(async ([eid, eidTransactions]) => {
      const eidName = formatEid(eid);
      logger.debug(
        `Signing ${eidTransactions.length} ${ioDevtools.pluralizeNoun(eidTransactions.length, "transaction")} for ${eidName}`
      );
      logger.debug(`Creating signer for ${eidName}`);
      let signer;
      try {
        signer = await createSigner(eid);
      } catch (error) {
        logger.error(`Failed to create a signer for ${eidName}: ${error}`);
        return handleError({
          error: new Error(`Failed to create a signer for ${eidName}: ${error}`),
          transaction: eidTransactions[0]
        });
      }
      await signerLogic(eid, logger, signer, eidTransactions, handleSuccess, handleError);
      logger.debug(`Successfully signed ${n} ${ioDevtools.pluralizeNoun(n, "transaction")} for ${eidName}`);
    })
  );
  const processed = new Set(successful.map(({ transaction }) => transaction));
  const pending = transactions.filter((transaction) => !processed.has(transaction));
  return [successful, errors, pending];
};
var sendBatchedIfAvailable = (fallbackLogic) => async (eid, logger, signer, transactions, onSuccess, onError) => {
  const eidName = formatEid(eid);
  if (signer.signAndSendBatch == null) {
    logger.warn(`Batched transaction sending is not available for ${eidName}, falling back on regular sending`);
    return await fallbackLogic(eid, logger, signer, transactions, onSuccess, onError);
  }
  const transactionsName = ioDevtools.pluralizeNoun(
    transactions.length,
    `1 transaction`,
    `${transactions.length} transactions`
  );
  try {
    logger.debug(`Signing a batch of ${transactionsName} for ${eidName}`);
    const response = await signer.signAndSendBatch(transactions);
    logger.debug(`Signed a batch of ${transactionsName} for ${eidName}, got hash ${response.transactionHash}`);
    const receipt = await response.wait();
    logger.debug(`Finished a batch of ${transactionsName} for ${eidName}`);
    for (const transaction of transactions) {
      onSuccess({ transaction, receipt });
    }
  } catch (error) {
    logger.debug(`Failed to process a batch of ${transactionsName} for ${eidName}: ${error}`);
    for (const transaction of transactions) {
      onError({ transaction, error });
    }
  }
};
var waitBeforeSubmittingNext = async (eid, logger, signer, transactions, onSuccess, onError) => {
  const eidName = formatEid(eid);
  for (const [index, transaction] of transactions.entries()) {
    const ordinal = ioDevtools.pluralizeOrdinal(index + 1);
    try {
      logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`);
      const response = await signer.signAndSend(transaction);
      logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`);
      const receipt = await response.wait();
      logger.debug(`Finished ${ordinal} transaction for ${eidName}`);
      onSuccess({ transaction, receipt });
    } catch (error) {
      logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`);
      onError({ transaction, error });
      return;
    }
  }
};
var waitAfterSendingAll = async (eid, logger, signer, transactions, onSuccess, onError) => {
  const eidName = formatEid(eid);
  const responses = [];
  for (const [index, transaction] of transactions.entries()) {
    const ordinal = ioDevtools.pluralizeOrdinal(index + 1);
    try {
      logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`);
      const response = await signer.signAndSend(transaction);
      logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`);
      responses.push({ transaction, response });
    } catch (error) {
      logger.debug(`Failed to sign ${ordinal} transaction for ${eidName}: ${error}`);
      onError({ transaction, error });
      break;
    }
  }
  for (const [index, { response, transaction }] of responses.entries()) {
    const ordinal = ioDevtools.pluralizeOrdinal(index + 1);
    try {
      logger.debug(`Waiting for ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`);
      const receipt = await response.wait();
      logger.debug(`Finished ${ordinal} transaction for ${eidName}`);
      onSuccess({ transaction, receipt });
    } catch (error) {
      logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`);
      onError({ transaction, error });
    }
  }
};
var createSignAndSendFlow = ({ ci = false, createSigner, logger = ioDevtools.createLogger() }) => async ({ transactions }) => {
  const isInteractive = !ci;
  const subtaskLogger = ioDevtools.createModuleLogger(`signAndSendFlow`);
  const previewTransactions = isInteractive ? await ioDevtools.promptToContinue(`Would you like to preview the transactions before continuing?`) : true;
  if (previewTransactions) {
    swag.printRecords(transactions.map(formatOmniTransaction));
  }
  const shouldSubmit = isInteractive ? await ioDevtools.promptToContinue(`Would you like to submit the required transactions?`) : true;
  if (!shouldSubmit) {
    return subtaskLogger.verbose(`User cancelled the operation, exiting`), [[], [], transactions];
  }
  subtaskLogger.verbose(`Signing and sending transactions:

${ioDevtools.printJson(transactions)}`);
  const signAndSend = createSignAndSend(createSigner);
  let transactionsToSign = transactions;
  let successfulTransactions = [];
  let errors = [];
  while (true) {
    const progressBar = swag.render(
      swag.createProgressBar({ before: "Signing... ", after: ` 0/${transactionsToSign.length}` })
    );
    subtaskLogger.verbose(`Sending the transactions`);
    const [successfulBatch, errorsBatch, pendingBatch] = await signAndSend(
      transactionsToSign,
      (result, results) => {
        progressBar.rerender(
          swag.createProgressBar({
            progress: results.length / transactionsToSign.length,
            before: "Signing... ",
            after: ` ${results.length}/${transactionsToSign.length}`
          })
        );
      }
    );
    progressBar.clear();
    successfulTransactions = [...successfulTransactions, ...successfulBatch];
    errors = errorsBatch;
    transactionsToSign = pendingBatch;
    subtaskLogger.verbose(`Sent the transactions`);
    subtaskLogger.debug(`Successfully sent the following transactions:

${ioDevtools.printJson(successfulBatch)}`);
    subtaskLogger.debug(`Failed to send the following transactions:

${ioDevtools.printJson(errorsBatch)}`);
    subtaskLogger.debug(`Did not send the following transactions:

${ioDevtools.printJson(pendingBatch)}`);
    logger.info(
      ioDevtools.pluralizeNoun(
        successfulBatch.length,
        `Successfully sent 1 transaction`,
        `Successfully sent ${successfulBatch.length} transactions`
      )
    );
    if (errors.length === 0) {
      logger.info(`${ioDevtools.printBoolean(true)} Your OApp is now configured`);
      break;
    }
    logger.error(
      ioDevtools.pluralizeNoun(
        errors.length,
        `Failed to send 1 transaction`,
        `Failed to send ${errors.length} transactions`
      )
    );
    const previewErrors = isInteractive ? await ioDevtools.promptToContinue(`Would you like to preview the failed transactions?`) : true;
    if (previewErrors) {
      swag.printRecords(
        errors.map(({ error, transaction }) => ({
          error: String(error),
          ...formatOmniTransaction(transaction)
        }))
      );
    }
    const retry = isInteractive ? await ioDevtools.promptToContinue(`Would you like to retry?`, true) : false;
    if (!retry) {
      logger.error(`${ioDevtools.printBoolean(false)} Failed to configure the OApp`);
      break;
    }
  }
  return [successfulTransactions, errors, transactionsToSign];
};
var createWireFlow = ({
  logger = ioDevtools.createLogger(),
  executeConfig,
  signAndSend
}) => async ({ graph, assert: assert6 = false, dryRun = false }) => {
  if (assert6) {
    logger.info(`Running in assertion mode`);
  } else if (dryRun) {
    logger.info(`Running in dry run mode`);
  }
  logger.verbose(`Creating a list of wiring transactions`);
  const transactions = await executeConfig({ graph });
  logger.verbose(`Created a list of wiring transactions`);
  logger.debug(`Following transactions are necessary:

${ioDevtools.printJson(transactions)}`);
  if (transactions.length === 0) {
    logger.info(`The OApp is wired, no action is necessary`);
    return [[], [], []];
  }
  if (dryRun) {
    swag.printRecords(transactions.map(formatOmniTransaction));
    return [[], [], transactions];
  }
  if (assert6) {
    logger.error(`The OApp is not fully wired, following transactions are necessary:`);
    swag.printRecords(transactions.map(formatOmniTransaction));
    process.exitCode = process.exitCode || 1;
    return [[], [], transactions];
  }
  logger.info(
    ioDevtools.pluralizeNoun(
      transactions.length,
      `There is 1 transaction required to configure the OApp`,
      `There are ${transactions.length} transactions required to configure the OApp`
    )
  );
  const signAndSendResult = await signAndSend({
    transactions
  });
  return signAndSendResult;
};

exports.AddressSchema = AddressSchema;
exports.AsyncRetriable = AsyncRetriable;
exports.EmptyOmniEdgeSchema = EmptyOmniEdgeSchema;
exports.EmptyOmniNodeSchema = EmptyOmniNodeSchema;
exports.EndpointIdSchema = EndpointIdSchema;
exports.OmniGraphBuilder = OmniGraphBuilder;
exports.OmniPointMap = OmniPointMap;
exports.OmniPointSchema = OmniPointSchema;
exports.OmniSignerBase = OmniSignerBase;
exports.OmniVectorMap = OmniVectorMap;
exports.OmniVectorSchema = OmniVectorSchema;
exports.UIntBigIntSchema = UIntBigIntSchema;
exports.UIntNumberSchema = UIntNumberSchema;
exports.areBytes32Equal = areBytes32Equal;
exports.arePointsEqual = arePointsEqual;
exports.areSameEndpoint = areSameEndpoint;
exports.areVectorsEqual = areVectorsEqual;
exports.compareBytes32Ascending = compareBytes32Ascending;
exports.createConfigExecuteFlow = createConfigExecuteFlow;
exports.createConfigLoadFlow = createConfigLoadFlow;
exports.createConfigureEdges = createConfigureEdges;
exports.createConfigureMultiple = createConfigureMultiple;
exports.createConfigureNodes = createConfigureNodes;
exports.createDefaultApplicative = createDefaultApplicative;
exports.createDefaultRetryHandler = createDefaultRetryHandler;
exports.createOmniEdgeSchema = createOmniEdgeSchema;
exports.createOmniGraphSchema = createOmniGraphSchema;
exports.createOmniNodeSchema = createOmniNodeSchema;
exports.createRetryFactory = createRetryFactory;
exports.createSignAndSend = createSignAndSend;
exports.createSignAndSendFlow = createSignAndSendFlow;
exports.createSimpleRetryStrategy = createSimpleRetryStrategy;
exports.createWireFlow = createWireFlow;
exports.denormalizePeer = denormalizePeer;
exports.first = first;
exports.firstFactory = firstFactory;
exports.flattenTransactions = flattenTransactions;
exports.formatEid = formatEid;
exports.formatOmniPoint = formatOmniPoint;
exports.formatOmniTransaction = formatOmniTransaction;
exports.formatOmniVector = formatOmniVector;
exports.fromHex = fromHex;
exports.groupTransactionsByEid = groupTransactionsByEid;
exports.ignoreZero = ignoreZero;
exports.isDeepEqual = isDeepEqual;
exports.isFailedSignAndSendResult = isFailedSignAndSendResult;
exports.isOmniGraphEmpty = isOmniGraphEmpty;
exports.isOmniPoint = isOmniPoint;
exports.isVectorPossible = isVectorPossible;
exports.isZero = isZero;
exports.makeBytes32 = makeBytes32;
exports.mapError = mapError;
exports.normalizePeer = normalizePeer;
exports.parallel = parallel;
exports.sequence = sequence;
exports.serializeDockerComposeSpec = serializeDockerComposeSpec;
exports.serializePoint = serializePoint;
exports.serializeVector = serializeVector;
exports.splitCommaSeparated = splitCommaSeparated;
exports.tapError = tapError;
exports.toHex = toHex;
exports.vectorFromNodes = vectorFromNodes;
exports.withEid = withEid;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map