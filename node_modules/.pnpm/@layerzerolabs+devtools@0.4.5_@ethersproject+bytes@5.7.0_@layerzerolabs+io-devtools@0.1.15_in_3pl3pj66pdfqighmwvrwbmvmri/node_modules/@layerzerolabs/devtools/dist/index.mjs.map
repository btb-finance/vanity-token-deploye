{"version":3,"sources":["../src/common/assertion.ts","../src/omnigraph/builder.ts","../src/omnigraph/coordinates.ts","../src/omnigraph/format.ts","../src/common/map.ts","../src/omnigraph/map.ts","../src/transactions/utils.ts","../src/omnigraph/config.ts","../src/common/promise.ts","../src/omnigraph/schema.ts","../src/common/bytes.ts","../src/common/retry.ts","../src/common/strings.ts","../src/docker/compose.ts","../src/flows/config.execute.ts","../src/flows/config.load.ts","../src/transactions/format.ts","../src/transactions/signer.ts","../src/flows/sign.and.send.ts","../src/flows/wire.ts"],"names":["EndpointId","_a","assert","createModuleLogger","backOff","printJson","createLogger","pluralizeNoun","printRecords"],"mappings":"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","sourcesContent":["import { deepStrictEqual } from 'assert'\n\n/**\n * Compares two object by value, returning `true` if they match\n *\n * ```\n * const theyMatch = isDeepEqual({ a: 1 }, { a: 1 }) // true\n * const theyDontMatch = isDeepEqual({ a: 1 }, { a: '1' }) // false\n * ```\n *\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport const isDeepEqual = (a: unknown, b: unknown): boolean => {\n    try {\n        return deepStrictEqual(a, b), true\n    } catch {\n        return false\n    }\n}\n","import assert from 'assert'\nimport { arePointsEqual, isVectorPossible } from './coordinates'\nimport type { OmniEdge, OmniGraph, OmniNode, OmniPoint, OmniVector } from './types'\nimport { formatOmniPoint, formatOmniVector } from './format'\nimport { OmniPointMap, OmniVectorMap } from './map'\n\nexport class OmniGraphBuilder<TNodeConfig = unknown, TEdgeConfig = unknown> {\n    /**\n     * Syntactic sugar utility for cloning graphs\n     *\n     * @param {OmniGraph<TNodeConfig, TEdgeConfig>} graph\n     * @returns {OmniGraph<TNodeConfig, TEdgeConfig>}\n     */\n    static fromGraph<TNodeConfig = unknown, TEdgeConfig = unknown>(\n        graph: OmniGraph<TNodeConfig, TEdgeConfig>\n    ): OmniGraphBuilder<TNodeConfig, TEdgeConfig> {\n        return new OmniGraphBuilder<TNodeConfig, TEdgeConfig>()\n            .addNodes(...graph.contracts)\n            .addEdges(...graph.connections)\n    }\n\n    #nodes: OmniPointMap<OmniNode<TNodeConfig>> = new OmniPointMap()\n\n    #edges: OmniVectorMap<OmniEdge<TEdgeConfig>> = new OmniVectorMap()\n\n    #assertCanAddEdge(edge: OmniEdge<TEdgeConfig>): void {\n        const label = formatOmniVector(edge.vector)\n        const from = formatOmniPoint(edge.vector.from)\n\n        assert(isVectorPossible(edge.vector), `Cannot add edge ${label}: cannot connect the two endpoints`)\n        assert(this.getNodeAt(edge.vector.from), `Cannot add edge ${label}: ${from} is not in the graph`)\n    }\n\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n    //\n    //                      The builder methods\n    //\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n\n    addNodes(...nodes: OmniNode<TNodeConfig>[]): this {\n        return nodes.forEach((node) => this.#nodes.set(node.point, node)), this\n    }\n\n    addEdges(...edges: OmniEdge<TEdgeConfig>[]): this {\n        return (\n            edges.forEach((edge) => {\n                // First we make sure we can add this edge\n                this.#assertCanAddEdge(edge)\n\n                // Only then we add it\n                this.#edges.set(edge.vector, edge)\n            }),\n            this\n        )\n    }\n\n    removeNodeAt(point: OmniPoint): this {\n        return (\n            // First we remove all edges between this node and any other nodes\n            [...this.getEdgesFrom(point)].forEach((edge) => this.removeEdgeAt(edge.vector)),\n            // Only then we remove the node itself\n            this.#nodes.delete(point),\n            this\n        )\n    }\n\n    removeEdgeAt(vector: OmniVector): this {\n        return this.#edges.delete(vector), this\n    }\n\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n    //\n    //                      The accessor methods\n    //\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n\n    getNodeAt(point: OmniPoint): OmniNode<TNodeConfig> | undefined {\n        return this.#nodes.get(point)\n    }\n\n    getEdgeAt(vector: OmniVector): OmniEdge<TEdgeConfig> | undefined {\n        return this.#edges.get(vector)\n    }\n\n    getEdgesFrom(point: OmniPoint): OmniEdge<TEdgeConfig>[] {\n        return this.edges.filter(({ vector: { from } }) => arePointsEqual(point, from))\n    }\n\n    getEdgesTo(point: OmniPoint): OmniEdge<TEdgeConfig>[] {\n        return this.edges.filter(({ vector: { to } }) => arePointsEqual(point, to))\n    }\n\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n    //\n    //                     The config accessors\n    //\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n\n    get nodes(): OmniNode<TNodeConfig>[] {\n        return Array.from(this.#nodes.values())\n    }\n\n    get edges(): OmniEdge<TEdgeConfig>[] {\n        return Array.from(this.#edges.values())\n    }\n\n    get graph(): OmniGraph<TNodeConfig, TEdgeConfig> {\n        return {\n            contracts: this.nodes,\n            connections: this.edges,\n        }\n    }\n}\n","import { EndpointId, endpointIdToStage } from '@layerzerolabs/lz-definitions'\nimport { OmniVector, OmniPoint, OmniNode, WithEid } from './types'\n\n/**\n * Compares two points by value\n *\n * @param a `OmniPoint`\n * @param b `OmniPoint`\n *\n * @returns `true` if the vector point to the same point in omniverse\n */\nexport const arePointsEqual = (a: OmniPoint, b: OmniPoint): boolean =>\n    a.address === b.address && a.eid === b.eid && a.contractName === b.contractName\n\n/**\n * Checks if two points are on the same endpoint\n *\n * @param a `OmniPoint`\n * @param b `OmniPoint`\n *\n * @returns `true` if the vector point to the same point in omniverse\n */\nexport const areSameEndpoint = (a: OmniPoint, b: OmniPoint): boolean => a.eid === b.eid\n\n/**\n * Compares two vectors by value\n *\n * @param a `OmniVector`\n * @param b `OmniVector`\n *\n * @returns `true` if the vector point from and to the same point in omniverse\n */\nexport const areVectorsEqual = (a: OmniVector, b: OmniVector): boolean =>\n    arePointsEqual(a.from, b.from) && arePointsEqual(a.to, b.to)\n\n/**\n * Checks that a vector is _possible_ - i.e. connects two endpoints\n * that can be connected in reality.\n *\n * @param vector `OmniVector`\n *\n * @returns `true` if two points of the vector can be connected in reality\n */\nexport const isVectorPossible = ({ from, to }: OmniVector): boolean =>\n    endpointIdToStage(from.eid) === endpointIdToStage(to.eid)\n\n/**\n * Serializes a point. Useful for when points need to be used in Map\n * where we cannot adjust the default behavior of using a reference equality\n *\n * @param point `OmniPoint`\n *\n * @returns `string`\n */\nexport const serializePoint = ({ address, eid }: OmniPoint): string => `${eid}|${address}`\n\n/**\n * Serializes a vector. Useful for when vectors need to be used in Map\n * where we cannot adjust the default behavior of using a reference equality\n *\n * @param point `OmniVector`\n *\n * @returns `string`\n */\nexport const serializeVector = ({ from, to }: OmniVector): string => `${serializePoint(from)} → ${serializePoint(to)}`\n\n/**\n * Helper function to quickly convert a pair of nodes to a vector\n *\n * @param a `OmniNode`\n * @param b `OmniNode`\n * @returns `OmniVector`\n */\nexport const vectorFromNodes = (a: OmniNode, b: OmniNode): OmniVector => ({ from: a.point, to: b.point })\n\n/**\n * Helper function to add an `eid` to arbitrary values, converting them to `WithEid`\n *\n * This is useful to reduce repetition when e.g. creating multiple `OmniPoint` instances on the same network:\n *\n * ```\n * const onMainnet = withEid(EndpointId.ETHEREUM_V2_MAINNET)\n *\n * const onePoint = onMainnet({ address: '0x0' })\n * const anotherPoint = onMainnet({ address: '0x1' })\n * ```\n */\nexport const withEid =\n    (eid: EndpointId) =>\n    <T>(value: T): WithEid<T> => ({ ...value, eid })\n","import { EndpointId } from '@layerzerolabs/lz-definitions'\nimport type { OmniPoint, OmniVector } from './types'\n\nexport const formatEid = (eid: EndpointId): string => EndpointId[eid] ?? `Unknown EndpointId (${eid})`\n\nexport const formatOmniPoint = ({ eid, address, contractName }: OmniPoint): string =>\n    `[${address}${contractName ? ` (${contractName})` : ``} @ ${formatEid(eid)}]`\n\nexport const formatOmniVector = ({ from, to }: OmniVector): string =>\n    `${formatOmniPoint(from)} → ${formatOmniPoint(to)}`\n","export type Hash = string | number | boolean | bigint\n\nexport type HashFunction<T, H extends Hash = Hash> = (value: T) => H\n\n/**\n * Data structure similar to the default ES6 Map\n * with one crucial difference - it requires a hash function\n * which allows it to store values not by reference, but by value\n *\n * The implementation is quite naive as it uses three additional maps\n * to be able to easily implement the ES6 Map interface. This comes at a small\n * storage price which, in our environment, is perfectly negligible.\n *\n * The interface matches the interface of Map with one syntactic sugar added:\n * the getOrElse method that prevents us from having to do null checks on get.\n */\nexport abstract class AbstractMap<K, V> implements Map<K, V> {\n    #keys: Map<Hash, K> = new Map()\n\n    #values: Map<Hash, V> = new Map()\n\n    #entries: Map<Hash, [K, V]> = new Map()\n\n    protected abstract hash(key: K): Hash\n\n    constructor(entries: Iterable<[K, V]> = []) {\n        for (const [key, value] of entries) {\n            this.set(key, value)\n        }\n    }\n\n    clear(): void {\n        this.#keys.clear()\n        this.#values.clear()\n        this.#entries.clear()\n    }\n\n    delete(key: K): boolean {\n        const serialized = this.hash(key)\n\n        return this.#keys.delete(serialized), this.#values.delete(serialized), this.#entries.delete(serialized)\n    }\n\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: unknown): void {\n        for (const [_, [key, value]] of this.#entries) {\n            callbackfn.apply(thisArg, [value, key, this])\n        }\n    }\n\n    get(key: K): V | undefined {\n        return this.#values.get(this.hash(key))\n    }\n\n    getOrElse(key: K, orElse: () => V): V {\n        return this.has(key) ? (this.get(key) as V) : orElse()\n    }\n\n    has(key: K): boolean {\n        return this.#keys.has(this.hash(key))\n    }\n\n    set(key: K, value: V): this {\n        const serialized = this.hash(key)\n\n        return (\n            this.#keys.set(serialized, key),\n            this.#values.set(serialized, value),\n            this.#entries.set(serialized, [key, value]),\n            this\n        )\n    }\n\n    get size(): number {\n        return this.#entries.size\n    }\n\n    entries(): IterableIterator<[K, V]> {\n        return this.#entries.values()\n    }\n\n    keys(): IterableIterator<K> {\n        return this.#keys.values()\n    }\n\n    values(): IterableIterator<V> {\n        return this.#values.values()\n    }\n\n    [Symbol.iterator](): IterableIterator<[K, V]> {\n        return this.entries()\n    }\n\n    [Symbol.toStringTag] = 'HashMap'\n}\n","import { AbstractMap } from '@/common/map'\nimport { serializePoint, serializeVector } from './coordinates'\nimport type { OmniPoint, OmniVector } from './types'\n\nexport class OmniPointMap<V, K extends OmniPoint = OmniPoint> extends AbstractMap<K, V> {\n    [Symbol.toStringTag] = 'OmniPointMap'\n\n    protected override hash(point: K) {\n        return serializePoint(point)\n    }\n}\n\nexport class OmniVectorMap<V, K extends OmniVector = OmniVector> extends AbstractMap<K, V> {\n    [Symbol.toStringTag] = 'OmniVectorMap'\n\n    protected override hash(vector: K) {\n        return serializeVector(vector)\n    }\n}\n","import type { EndpointId } from '@layerzerolabs/lz-definitions'\nimport type { OmniTransaction } from './types'\nimport { SignAndSendResult } from './signer'\n\nconst isNonNullable = <T>(value: T | null | undefined): value is T => value != null\n\nexport const flattenTransactions = (\n    transations: (OmniTransaction | OmniTransaction[] | null | undefined)[]\n): OmniTransaction[] => transations.filter(isNonNullable).flat()\n\n/**\n * Groups transactions by their `eid`, preserving the order per group\n *\n * @param {OmniTransaction[]} transactions\n * @returns {Map<EndpointId, OmniTransaction[]>}\n */\nexport const groupTransactionsByEid = (transactions: OmniTransaction[]): Map<EndpointId, OmniTransaction[]> =>\n    transactions.reduce(\n        (transactionsByEid, transaction) =>\n            transactionsByEid.set(transaction.point.eid, [\n                ...(transactionsByEid.get(transaction.point.eid) ?? []),\n                transaction,\n            ]),\n        new Map<EndpointId, OmniTransaction[]>()\n    )\n\nexport const isFailedSignAndSendResult = ([, failed]: SignAndSendResult): boolean => failed.length > 0\n","import type { Factory } from '@/types'\nimport type { Configurator, IOmniSDK, InferOmniEdge, InferOmniNode, OmniGraph, OmniSDKFactory } from './types'\nimport type { OmniTransaction } from '@/transactions/types'\nimport { flattenTransactions } from '@/transactions/utils'\nimport { createModuleLogger } from '@layerzerolabs/io-devtools'\nimport { createDefaultApplicative } from '@/common/promise'\n\nexport type CreateTransactionsFromOmniNodes<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = Factory<\n    [InferOmniNode<TOmniGraph>, TOmniSDK, TOmniGraph, OmniSDKFactory<TOmniSDK>],\n    OmniTransaction[] | OmniTransaction | null | undefined\n>\n\nexport type CreateTransactionsFromOmniEdges<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = Factory<\n    [InferOmniEdge<TOmniGraph>, TOmniSDK, TOmniGraph, OmniSDKFactory<TOmniSDK>],\n    OmniTransaction[] | OmniTransaction | null | undefined\n>\n\n/**\n * Function that takes care of the boilerplate for node configuration functions.\n *\n * It will create an SDK for every node in the graph, then call `createTransactions`\n * with the node itself, the created SDK, the whole graph and the SDK factory.\n *\n * ```\n * const configureSomething = createConfigureNodes(async ({ config }: OmniNode<{ something: string }>, sdk) => {\n *   const something = await sdk.getSomething()\n *   if (something !== config.something) return []\n *\n *   return sdk.setSomething(config.something)\n * })\n * ```\n *\n * @template TOmniGraph\n * @template TOmniSDK\n * @param {CreateTransactionsFromOmniNodes<TOmniGraph, TOmniSDK>} createTransactions\n * @returns {Configurator<TOmniGraph, TOmniSDK>}\n */\nexport const createConfigureNodes =\n    <TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK>(\n        createTransactions: CreateTransactionsFromOmniNodes<TOmniGraph, TOmniSDK>\n    ): Configurator<TOmniGraph, TOmniSDK> =>\n    async (graph, createSdk) =>\n        flattenTransactions(\n            await Promise.all(\n                graph.contracts.map(async (node) => {\n                    const sdk = await createSdk(node.point)\n\n                    return await createTransactions(node, sdk, graph, createSdk)\n                })\n            )\n        )\n\n/**\n * Function that takes care of the boilerplate for edge configuration functions.\n *\n * It will create an SDK for every edge (using the `from` field) in the graph, then call `createTransactions`\n * with the edge itself, the created SDK, the whole graph and the SDK factory.\n *\n * ```\n * const configureSomething = createConfigureEdges(async ({ config, vector: { to } }: OmniEdge<{ something: string }>, sdk) => {\n *   const something = await sdk.getSomethingFor(to.eid)\n *   if (something !== config.something) return []\n *\n *   return sdk.setSomething(to.eid, config.something)\n * })\n * ```\n *\n * @template TOmniGraph\n * @template TOmniSDK\n * @param {CreateTransactionsFromOmniEdges<TOmniGraph, TOmniSDK>} createTransactions\n * @returns {Configurator<TOmniGraph, TOmniSDK>}\n */\nexport const createConfigureEdges =\n    <TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK>(\n        createTransactions: CreateTransactionsFromOmniEdges<TOmniGraph, TOmniSDK>\n    ): Configurator<TOmniGraph, TOmniSDK> =>\n    async (graph, createSdk) =>\n        flattenTransactions(\n            await Promise.all(\n                graph.connections.map(async (edge) => {\n                    const sdk = await createSdk(edge.vector.from)\n\n                    return await createTransactions(edge, sdk, graph, createSdk)\n                })\n            )\n        )\n\n/**\n * Helper function that takes multiple configurators and executes them\n * (the execution is parallel or serial based on the LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION\n * feature flag at the moment)\n *\n * ```\n * const configureOApp = createConfigureMultiple(\n *   configureOAppPeers\n *   configureSendLibraries\n *   configureReceiveLibraries\n *   configureReceiveLibraryTimeouts\n *   configureSendConfig\n *   configureReceiveConfig\n *   configureEnforcedOptions,\n *   configureCallerBpsCap,\n *   configureOAppDelegates\n * )\n * ```\n *\n * @param {...Configurator<TOmniGraph, TOmniSDK>} configurators An array of configuration functions\n * @returns {Configurator<TOmniGraph, TOmniSDK>}\n */\nexport const createConfigureMultiple =\n    <TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK>(\n        ...configurators: Configurator<TOmniGraph, TOmniSDK>[]\n    ): Configurator<TOmniGraph, TOmniSDK> =>\n    async (graph, createSdk) => {\n        const logger = createModuleLogger('configuration')\n        const tasks = configurators.map((configurator) => () => configurator(graph, createSdk))\n\n        // For now we keep the parallel execution as an opt-in feature flag\n        // before we have a retry logic fully in place for the SDKs\n        //\n        // This is to avoid 429 too many requests errors from the RPCs\n        const applicative = createDefaultApplicative(logger)\n\n        return flattenTransactions(await applicative(tasks))\n    }\n","import { Factory } from '@/types'\nimport { Logger } from '@layerzerolabs/io-devtools'\nimport assert from 'assert'\nimport { backOff } from 'exponential-backoff'\n\n/**\n * Helper type for argumentless factories a.k.a. tasks\n */\ntype Task<T> = Factory<[], T>\n\n/**\n * Executes tasks in sequence, waiting for each one to finish before starting the next one\n *\n * Will resolve with the output of all tasks or reject with the first rejection.\n *\n * @param {Task<T>[]} tasks\n * @returns {Promise<T[]>}\n */\nexport const sequence = async <T>(tasks: Task<T>[]): Promise<T[]> => {\n    const collector: T[] = []\n\n    for (const task of tasks) {\n        collector.push(await task())\n    }\n\n    return collector\n}\n\n/**\n * Executes tasks in parallel\n *\n * Will resolve with the output of all tasks or reject with the any rejection.\n *\n * @param {Task<T>[]} tasks\n * @returns {Promise<T[]>}\n */\nexport const parallel = async <T>(tasks: Task<T>[]): Promise<T[]> => await Promise.all(tasks.map((task) => task()))\n\n/**\n * Creates a default applicative based on an environment feature flag.\n *\n * For now we keep the parallel execution as an opt-in feature flag\n * before we have a retry logic fully in place for the SDKs\n *\n * This is to avoid 429 too many requests errors from the RPCs\n *\n * @param logger\n * @returns\n */\nexport const createDefaultApplicative = (logger?: Logger) =>\n    process.env.LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION\n        ? (logger?.warn(`You are using experimental parallel configuration`), parallel)\n        : sequence\n\n/**\n * Maps the errors coming from a task. Errors thrown from the `toError`\n * callback will not be caught.\n *\n * ```\n * const functionThatMightThrow = () => sdk.getSomeAttribute()\n *\n * const result = await mapError(functionThatMightThrow, (error) => new Error(`Error produced: ${error}`))\n * ```\n *\n * @template T\n * @template E\n * @param {(error: unknown) => E} toError Error mapping function\n */\nexport const mapError = async <T, E = unknown>(task: Task<T>, toError: (error: unknown) => E): Promise<Awaited<T>> => {\n    try {\n        return await task()\n    } catch (error: unknown) {\n        throw toError(error)\n    }\n}\n\n/**\n * Intercepts any errors coming from a task. The return value\n * of this call will be the return value of the task\n * and the rejected value will be the original erorr.\n *\n * Any errors or rejections from the `onError` callback will be caught\n * and the original error will be rethrown.\n *\n * ```\n * const functionThatMightThrow = () => sdk.getSomeAttribute()\n *\n * // With custom logging\n * const result = await tapError(functionThatMightThrow, (error) => console.error('Something went wrong:', error))\n *\n * // For lazy people\n * const result = await tapError(functionThatMightThrow, console.error)\n * ```\n *\n * @param {Factory<[error: unknown], void>} onError Synchronous or asynchronous error callback\n */\nexport const tapError = async <T>(task: Task<T>, onError: Factory<[error: unknown], void>): Promise<Awaited<T>> => {\n    try {\n        return await task()\n    } catch (error: unknown) {\n        try {\n            await onError(error)\n        } catch {\n            // Ignore the error from the callback since the original error\n            // is probably more informative\n        }\n\n        throw error\n    }\n}\n\n/**\n * Executes tasks in a sequence until one resolves.\n *\n * Will resolve with the output of the first task that resolves\n * or reject with the last rejection.\n *\n * Will reject immediatelly if no tasks have been passed\n *\n * @param {Task<T>[]} tasks\n * @returns {Promise<T>}\n */\nexport const first = async <T>(tasks: Task<T>[]): Promise<T> => {\n    assert(tasks.length !== 0, `Must have at least one task for first()`)\n\n    let lastError: unknown\n\n    for (const task of tasks) {\n        try {\n            return await task()\n        } catch (error) {\n            lastError = error\n        }\n    }\n\n    throw lastError\n}\n\n/**\n * Helper utility for currying first() - creating a function\n * that behaves like first() but accepts arguments that will be passed to the factory functions\n *\n * @param {Factory<TInput, TOutput>[]} factories\n * @returns {Factory<TInput, TOutput>}\n */\nexport const firstFactory =\n    <TInput extends unknown[], TOutput>(...factories: Factory<TInput, TOutput>[]): Factory<TInput, TOutput> =>\n    async (...input) =>\n        await first(factories.map((factory) => () => factory(...input)))\n\n/**\n * RetryStrategy represents a function that, when passed to `createRetryFactory`,\n * controls the execution of a retried function.\n *\n * It will be executed on every failed attempt and has the ability to modify the\n * input originally passed to the retried function.\n *\n * In its simplest form, it will either return `true` (to retry again) or `false` (stop retrying).\n *\n * In its advanced form, it can use the parameters passed to it to create\n * a new set of arguments passed to the function being retried:\n *\n * ```\n * // As a simple example let's consider a function\n * // whose argument is the amount of money we want to pay for a service\n * const functionThatCanFail = (money: number): Promise<void> => { ... }\n *\n * // We can create a strategy that will keep adding 1 to the amount of money\n * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => [previousMoney + 1]\n *\n * // Or we can create a strategy that will adjust the money based on the initial value\n * //\n * // In this made up case it will take the original amount and will add 2 for every failed attempt\n * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => [originalMoney + attempt * 2]\n *\n * // Or we can go insane with our logic and can, because without objective morality\n * // everything is permissible, update the amount on every other attempt\n * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => attempt % 2 ? [previousMoney + 1] : true\n * ```\n *\n * @param {number} attempt The 0-indexed attempt that the retry function is performing\n * @param {unknown} error The error thrown from the previous execution of the retried function\n * @param {TInput} previousInput The input passed to the previous execution of the retried function\n * @param {TInput} originalInput The input passed to the first execution of the retried function\n */\ntype RetryStrategy<TInput extends unknown[]> = Factory<\n    [attempt: number, error: unknown, previousInput: TInput, originalInput: TInput],\n    TInput | boolean\n>\n\n/**\n * Uses the retry strategy to create a function that can wrap any function with retry logic.\n *\n * ```\n * // As a simple example let's consider a function\n * // whose argument is the amount of money we want to pay for a service\n * const functionThatCanFail = (money: number): Promise<void> => { ... }\n *\n * // By default, it will use a three-times-and-fail retry strategy\n * const retry = createRetryFactory()\n *\n * // It can wrap any function (sync or async) that can throw or reject\n * const retriedFunctionThatCanFail = retry(functionThatCanFail)\n *\n * // The function can then be called just like the original, wrapped function\n * retriedFunctionThatCanFail(1_000_000)\n *\n * // For advanced cases, you can use your own strategy\n * const strategy: RetryStrategy<[money: number]> = () => { ... }\n * const retry = createRetryFactory(strategy)\n * ```\n *\n * @see {@link createSimpleRetryStrategy}\n * @see {@link RetryStrategy}\n *\n * @param {RetryStrategy<TInput>} [strategy] `RetryStrategy` to use. Defaults to a simple strategy that retries three times\n * @returns {<TOutput>(task: Factory<TInput, TOutput>) => Factory<TInput, TOutput>}\n */\nexport const createRetryFactory =\n    <TInput extends unknown[]>(\n        strategy: RetryStrategy<TInput> = createSimpleRetryStrategy(3)\n    ): (<TOutput>(task: Factory<TInput, TOutput>) => Factory<TInput, TOutput>) =>\n    <TOutput>(task: Factory<TInput, TOutput>): Factory<TInput, TOutput> =>\n    async (...input) => {\n        // We'll store the last used input in this variable\n        let currentInput = input\n\n        return backOff(async () => task(...currentInput), {\n            // We'll effectively disable the numOfAttempts for exponential backoff\n            // since we want the behavior to be completely controlled by the strategy\n            numOfAttempts: Number.POSITIVE_INFINITY,\n            // The retry callback is called after an unsuccessful attemp\n            //\n            // It allows us to decide whether we want to keep trying or give up\n            // (we can give up by returning false)\n            //\n            // We'll use this callback to allow the strategy to effectively make changes\n            // to the input, thus allowing it to accommodate for things such as gas price increase\n            // for transactions\n            async retry(error, attempt) {\n                // We will evaluate the strategy first\n                const strategyOutput = await strategy(attempt, error, currentInput, input)\n\n                // The strategy can simply return true/false, in which case we'll not be adjusting the input at all\n                if (typeof strategyOutput === 'boolean') {\n                    return strategyOutput\n                }\n\n                // If we got an input back, we'll adjust it and keep trying\n                return (currentInput = strategyOutput), true\n            },\n        })\n    }\n\n/**\n * Creates a simple `RetryStrategy` that will retry N times.\n *\n * If you want to compose this strategy, you can pass `wrappedStrategy`:\n *\n * ```\n * const myVeryAdvancedStrategy: RetryStrategy<[string, number]> = () => { ... }\n * const myVeryAdvancedStrategyThatWillRetryThreeTimesOnly = createSimpleRetryStrategy(3, myVeryAdvancedStrategy)\n * ```\n *\n * @param {number} numAttempts Must be larger than 0\n * @param {RetryStrategy<TInput>} [wrappedStrategy] Strategy to use if the number of attempts has not been reached yet\n * @returns {RetryStrategy<TInput>}\n */\nexport const createSimpleRetryStrategy = <TInput extends unknown[]>(\n    numAttempts: number,\n    wrappedStrategy?: RetryStrategy<TInput>\n): RetryStrategy<TInput> => {\n    assert(numAttempts > 0, `Number of attempts for a strategy must be larger than 0`)\n\n    return (attempt, error, previousInput, originalInput) => {\n        if (attempt > numAttempts) {\n            return false\n        }\n        if (wrappedStrategy == null) {\n            return true\n        }\n\n        return wrappedStrategy(attempt, error, previousInput, originalInput)\n    }\n}\n","import { EndpointId } from '@layerzerolabs/lz-definitions'\nimport { z } from 'zod'\nimport type { OmniPoint, OmniNode, OmniVector, OmniEdge, OmniGraph } from './types'\n\n/**\n * Schema for parsing strings, bigints and numbers to uint backed by bigint\n *\n * It does not use z.coerce in order to avoid errors coming from BigInt() constructor\n */\nexport const UIntBigIntSchema = z\n    .unknown()\n    .transform((value, ctx): bigint => {\n        if (typeof value === 'bigint') {\n            return value\n        }\n\n        try {\n            return BigInt(String(value))\n        } catch {\n            ctx.addIssue({\n                code: z.ZodIssueCode.custom,\n                message: `Invalid BigInt-like value`,\n            })\n\n            return z.NEVER\n        }\n    })\n    .pipe(z.bigint().nonnegative())\n\nexport const UIntNumberSchema = z\n    .unknown()\n    .transform((value, ctx): number => {\n        try {\n            return Number(value)\n        } catch {\n            ctx.addIssue({\n                code: z.ZodIssueCode.custom,\n                message: `Invalid Number-like value`,\n            })\n\n            return z.NEVER\n        }\n    })\n    .pipe(z.number().nonnegative().int())\n\nexport const AddressSchema = z.string()\n\nexport const EndpointIdSchema: z.ZodSchema<EndpointId, z.ZodTypeDef, string | number> = z\n    .nativeEnum(EndpointId)\n    .pipe(z.number())\n\nexport const OmniPointSchema: z.ZodSchema<OmniPoint, z.ZodTypeDef, unknown> = z.object({\n    address: AddressSchema,\n    eid: EndpointIdSchema,\n    contractName: z.string().nullish(),\n})\n\nexport const OmniVectorSchema: z.ZodSchema<OmniVector, z.ZodTypeDef, unknown> = z.object({\n    from: OmniPointSchema,\n    to: OmniPointSchema,\n})\n\nexport const EmptyOmniNodeSchema = z.object({\n    point: OmniPointSchema,\n    config: z.unknown().optional(),\n})\n\nexport const EmptyOmniEdgeSchema = z.object({\n    vector: OmniVectorSchema,\n    config: z.unknown().optional(),\n})\n\n/**\n * Helper assertion utility for `OmniPoint` instances\n *\n * @param {unknown} value\n * @returns {boolean} `true` if the value is an `OmniPoint`, `false` otherwise\n */\nexport const isOmniPoint = (value: unknown): value is OmniPoint => OmniPointSchema.safeParse(value).success\n\n/**\n * Helper assertion utility that checks whether an `OmniGraph`\n * has at least any contracts or connections defined\n *\n * @param {OmniGraph} graph\n * @returns {boolean}\n */\nexport const isOmniGraphEmpty = ({ contracts, connections }: OmniGraph): boolean =>\n    contracts.length === 0 && connections.length === 0\n\n/**\n * Factory for OmniNode schemas\n *\n * @param configSchema Schema of the config contained in the node\n *\n * @returns `z.ZodSchema<OmniNode<TConfig>>` schema for a node with the particular config type\n */\nexport const createOmniNodeSchema = <TConfig = unknown>(\n    configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniNode<TConfig>, z.ZodTypeDef, unknown> =>\n    EmptyOmniNodeSchema.extend({\n        config: configSchema,\n    }) as z.ZodSchema<OmniNode<TConfig>, z.ZodTypeDef>\n\n/**\n * Factory for OmniEdge schemas\n *\n * @param {z.ZodSchema<TConfig>} configSchema Schema of the config contained in the edge\n *\n * @returns {z.ZodSchema<OmniEdge<TConfig>>} Schema for an edge with the particular config type\n */\nexport const createOmniEdgeSchema = <TConfig = unknown>(\n    configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniEdge<TConfig>, z.ZodTypeDef, unknown> =>\n    EmptyOmniEdgeSchema.extend({\n        config: configSchema,\n    }) as z.ZodSchema<OmniEdge<TConfig>, z.ZodTypeDef>\n\n/**\n * Factory for OmniGraph schemas\n *\n * @param {z.ZodSchema<OmniNode<TNodeConfig>, z.ZodTypeDef, unknown>} nodeSchema\n * @param {z.ZodSchema<OmniEdge<TEdgeConfig>, z.ZodTypeDef, unknown>} edgeSchema\n *\n * @returns {z.ZodSchema<OmniGraph<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown>}\n */\nexport const createOmniGraphSchema = <TNodeConfig = unknown, TEdgeConfig = unknown>(\n    nodeSchema: z.ZodSchema<OmniNode<TNodeConfig>, z.ZodTypeDef, unknown>,\n    edgeSchema: z.ZodSchema<OmniEdge<TEdgeConfig>, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniGraph<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown> =>\n    z.object({\n        contracts: z.array(nodeSchema),\n        connections: z.array(edgeSchema),\n    })\n","import { formatEid } from '@/omnigraph'\nimport type { OmniAddress, PossiblyBigInt, PossiblyBytes } from '@/types'\nimport { hexZeroPad } from '@ethersproject/bytes'\nimport { ChainType, EndpointId, endpointIdToChainType } from '@layerzerolabs/lz-definitions'\nimport assert from 'assert'\nimport bs58 from 'bs58'\n\n/**\n * Converts an address into Bytes32 by padding it with zeros.\n *\n * It will return zero bytes if passed `null`, `undefined` or an empty string.\n *\n * @param {PossiblyBytes | null | undefined} bytes\n * @returns {string}\n */\nexport const makeBytes32 = (bytes?: PossiblyBytes | null | undefined): string => hexZeroPad(bytes || '0x0', 32)\n\n/**\n * Compares two Bytes32-like values by value (i.e. ignores casing on strings\n * and string length)\n *\n * @param {PossiblyBytes | null | undefined} a\n * @param {PossiblyBytes | null | undefined} b\n * @returns {boolean}\n */\nexport const areBytes32Equal = (a: PossiblyBytes | null | undefined, b: PossiblyBytes | null | undefined): boolean =>\n    BigInt(makeBytes32(a)) === BigInt(makeBytes32(b))\n\n/**\n * Checks whether a value is a zero value.\n *\n * It will return true if passed `null`, `undefined`, empty bytes ('0x') or an empty string.\n *\n * It will throw an error if the value is not a valid numerical value.\n *\n * @param {PossiblyBytes | PossiblyBigInt | null | undefined} value\n * @returns {boolean}\n */\nexport const isZero = (value: PossiblyBytes | PossiblyBigInt | null | undefined): boolean => {\n    switch (true) {\n        case value === '0x':\n        case value == null:\n            return true\n\n        case typeof value === 'string':\n        case typeof value === 'number':\n        case typeof value === 'bigint':\n            return BigInt(value) === BigInt(0)\n\n        default:\n            return value.every((byte) => byte === 0)\n    }\n}\n\n/**\n * Turns a potentially zero address into undefined\n *\n * @param {PossiblyBytes | PossiblyBigInt | null | undefined} value\n *\n * @returns {string | undefined}\n */\nexport const ignoreZero = <T extends PossiblyBytes | PossiblyBigInt>(value?: T | null | undefined): T | undefined =>\n    isZero(value) ? undefined : value ?? undefined\n\n/**\n * Helper function to be used when sorting of addresses is necessary.\n *\n * This can be used to sort arrays of addresses in ascending manner:\n *\n * ```\n * // The result will be [\"0x000000000000000000636F6e736F6c652e6c6f67\", \"0xEe6cF2E1Bc7645F8439d241ce37820305F2BB3F8\"]\n * [\"0xEe6cF2E1Bc7645F8439d241ce37820305F2BB3F8\", \"0x000000000000000000636F6e736F6c652e6c6f67\"].sort(compareBytes32Ascending)\n * ```\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare}\n *\n * @param {PossiblyBytes} a\n * @param {PossiblyBytes} b\n * @returns {number} `0` when the two are interchangeable, a negative value when `a` comes before `b` and a positive value when `a` comes after `b`\n */\nexport const compareBytes32Ascending = (a: PossiblyBytes, b: PossiblyBytes): number =>\n    Number(BigInt(makeBytes32(a)) - BigInt(makeBytes32(b)))\n\n/**\n * Normalizes a network-specific peer address into a byte array with length of 32.\n *\n * @param {OmniAddress} address\n * @param {EndpointId} eid\n * @returns {Uint8Array}\n */\nexport const normalizePeer = (address: OmniAddress | null | undefined, eid: EndpointId): Uint8Array => {\n    if (address == null) {\n        return new Uint8Array(32)\n    }\n\n    const chainType = endpointIdToChainType(eid)\n\n    switch (chainType) {\n        case ChainType.SOLANA:\n            return bs58.decode(address)\n\n        case ChainType.APTOS:\n        case ChainType.EVM:\n            return toBytes32(fromHex(address))\n\n        case ChainType.TON:\n            return fromHex(address)\n\n        default:\n            throw new Error(`normalizePeer: Unsupported chain type ${chainType} ${formatEid(eid)}`)\n    }\n}\n\n/**\n * Denormalizes Bytes32 representing a peer address into a network-specific peer address.\n *\n * @param {Uint8Array} bytes\n * @param {EndpointId} eid\n * @returns {OmniAddress}\n */\nexport const denormalizePeer = (bytes: Uint8Array | null | undefined, eid: EndpointId): OmniAddress | undefined => {\n    if (bytes == null || isZero(bytes)) {\n        return undefined\n    }\n\n    const chainType = endpointIdToChainType(eid)\n\n    switch (chainType) {\n        case ChainType.SOLANA:\n            return bs58.encode(toBytes32(bytes))\n\n        case ChainType.APTOS:\n            return toHex(toBytes32(bytes))\n\n        case ChainType.EVM:\n            return toHex(toBytes20(bytes))\n\n        case ChainType.TON:\n            return toHex(bytes)\n\n        default:\n            throw new Error(`denormalizePeer: Unsupported chain type ${chainType} ${formatEid(eid)}`)\n    }\n}\n\n/**\n * Helper utility that left-pads a `Uint8Array` to be 32 bytes in length.\n *\n * This function will check that only the rightmost 32 bytes are non-zero\n * and will throw otherwise.\n *\n * @param {Uint8Array} bytes A `Uint8Array` with the all but the rightmost 32 bytes set to zero.\n * @returns {Uint8Array} A `Uint8Array` of length 32.\n */\nconst toBytes32 = (bytes: Uint8Array): Uint8Array => {\n    assertZeroBytes(\n        getLeftPadding(bytes, 32),\n        `Cannot convert an array with more than 32 non-zero bytes into Bytes32. Got ${bytes} with length ${bytes.length}`\n    )\n\n    const bytes32 = new Uint8Array(32)\n\n    return bytes32.set(bytes, 32 - bytes.length), bytes32\n}\n\n/**\n * Helper utility that left-pads a `Uint8Array` to be 20 bytes in length.\n *\n * This function will check that only the rightmost 20 bytes are non-zero\n * and will throw otherwise.\n *\n * @param {Uint8Array} bytes A `Uint8Array` with the all but the rightmost 20 bytes set to zero.\n * @returns {Uint8Array} A `Uint8Array` of length 32.\n */\nconst toBytes20 = (bytes: Uint8Array): Uint8Array => {\n    assertZeroBytes(\n        getLeftPadding(bytes, 20),\n        `Cannot convert an array with more than 20 non-zero bytes into Bytes20. Got ${bytes} with length ${bytes.length}`\n    )\n\n    return new Uint8Array(bytes.slice(-20))\n}\n\n/**\n * Helper utility to convert `UInt8Array` into a hex string (with leading `0x`)\n *\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nexport const toHex = (bytes: Uint8Array): string => `0x${Buffer.from(bytes).toString('hex')}`\n\n/**\n * Helper utility to convert a hex string (with or without leading `0x`) to `UInt8Array`\n *\n * @param {string} hex\n * @returns {Uint8Array}\n */\nexport const fromHex = (hex: string): Uint8Array => Uint8Array.from(Buffer.from(hex.replace(/^0x/, ''), 'hex'))\n\n/**\n * Helper utility that returns the leftmost bytes after removing the rightmost `length` bytes from a UInt8Array.\n *\n * This is used when asserting that the `UInt8Array` only contains zero values\n * except for the rightmost `length` bytes\n *\n * ```\n * // Remove 1 rigthmost byte and return the result\n * const left4Bytes = getLeftPadding([1,2,3,4,5], 1) // [1,2,3,4]\n *\n * // Remove 8 rightmost bytes and return the result\n * const left8Bytes = getLeftPadding([1,2,3,4,5], 8) // []\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {number} length The number of rightmost bytes to remove from the array\n * @returns {Uint8Array}\n */\nconst getLeftPadding = (bytes: Uint8Array, length: number): Uint8Array =>\n    bytes.subarray(0, Math.max(bytes.length - length, 0))\n\n/**\n * Helper utility to assert that all elements of `bytes` are zero.\n *\n * @param {Uint8Array} bytes\n * @param {string} message A message to fail the assertion with if a non-zero byte is found\n */\nconst assertZeroBytes = (bytes: Uint8Array, message: string) => bytes.forEach((byte) => assert(byte === 0, message))\n","import { createModuleLogger, printJson } from '@layerzerolabs/io-devtools'\nimport assert from 'assert'\nimport { backOff } from 'exponential-backoff'\n\nexport type OnRetry<TInstance, TArgs extends unknown[] = unknown[]> = (\n    attempt: number,\n    numAttempts: number,\n    error: unknown,\n    target: TInstance,\n    method: string,\n    args: TArgs\n) => boolean | void | undefined\n\nexport interface RetriableConfig<TInstance = unknown> {\n    /**\n     * Enable / disable the retry behavior\n     */\n    enabled: boolean\n    /**\n     * The maximum delay, in milliseconds, between two consecutive attempts.\n     *\n     * @default Infinity\n     */\n    maxDelay?: number\n    /**\n     * Number of times the method call will be retried. The default is 3\n     *\n     * @default 3\n     */\n    numAttempts: number\n    /**\n     * Callback called on every failed attempt.\n     *\n     * @param {number} attempt 1-indexed number of attempt of executing the method\n     * @param {number} numAttempts Maximum/total number of attempts that will be executed\n     * @param {unknown} error The error that caused the function to be retried\n     * @param {unknown} target The object whose method is being retried\n     * @param {string} method The method name\n     * @param {unknown[]} args The method parameters\n     * @returns {boolean | undefined} This function can stop the retry train by returning false\n     */\n    onRetry: OnRetry<TInstance>\n}\n\ninterface TAsyncRetriable {\n    <TArgs extends unknown[], TResult>(\n        overrides?: Partial<RetriableConfig>\n    ): (\n        target: unknown,\n        propertyKey: string,\n        descriptor: TypedPropertyDescriptor<(...args: TArgs) => Promise<TResult>>\n    ) => TypedPropertyDescriptor<(...args: TArgs) => Promise<TResult>>\n\n    /**\n     * The default config used by all Asyncretriable decorators.\n     *\n     * This config can be updated at runtime by setting its properties:\n     *\n     * ```\n     * AsyncRetriable.config.numAttempts = 10\n     * ```\n     */\n    config: RetriableConfig\n\n    /**\n     * Resets the config to its default state\n     *\n     * @returns {void}\n     */\n    reset: () => void\n}\n\n/**\n * Helper function that creates a default debug logger for the `onRetry`\n * callback of `AsyncRetriable`\n */\nexport const createDefaultRetryHandler = (loggerName: string = 'AsyncRetriable'): OnRetry<unknown> => {\n    const logger = createModuleLogger(loggerName)\n\n    return (attempt, numAttempts, error, target, method, args) => {\n        logger.debug(`Attempt ${attempt}/${numAttempts}: ${method}() with arguments: ${printJson(args)}: ${error}`)\n    }\n}\n\nexport const AsyncRetriable: TAsyncRetriable = (overrides: Partial<RetriableConfig> = {}) => {\n    return function AsyncRetriableDecorator<TArgs extends unknown[], TResult>(\n        target: unknown,\n        propertyKey: string,\n        descriptor: TypedPropertyDescriptor<(...args: TArgs) => Promise<TResult>>\n    ) {\n        // Grab the original method and ensure that we are decorating a method\n        const originalMethod = descriptor.value\n        assert(\n            typeof originalMethod === 'function',\n            `AsyncRetriable must be applied to an instance method, ${propertyKey} property looks more like ${typeof originalMethod}`\n        )\n\n        // We'll wrap the retry handler from exponential backoff\n        // to make it a bit nicer to use\n        //\n        // - We'll put the attempt as the first argument\n        // - We'll add the decorator target as the last argument\n        //\n        // We'll curry this function so that it can pass the arguments to onRetry\n        const handleRetry =\n            (args: TArgs) =>\n            (error: unknown, attempt: number): boolean => {\n                const numAttempts = overrides.numAttempts ?? AsyncRetriable.config.numAttempts\n                const onRetry = overrides.onRetry ?? AsyncRetriable.config.onRetry\n\n                return onRetry(attempt, numAttempts, error, target, propertyKey, args) ?? true\n            }\n\n        // Create the retried method\n        const retriedMethod = function (this: unknown, ...args: TArgs): Promise<TResult> {\n            const enabled = overrides.enabled ?? AsyncRetriable.config.enabled\n            // If we are disabled, we are disabled\n            if (!enabled) {\n                return originalMethod.apply(this, args)\n            }\n\n            const maxDelay = overrides.numAttempts ?? AsyncRetriable.config.maxDelay\n            const numAttempts = overrides.numAttempts ?? AsyncRetriable.config.numAttempts\n\n            // We need to call the original method with the current this context\n            // rather than the target, target can point to a prototype rather than the instance\n            return backOff(() => originalMethod.apply(this, args), {\n                // A typical problem in our case is 429 Too many requests\n                // which would still happen if we didn't introduce a bit of randomness into the delay\n                jitter: 'full',\n                maxDelay,\n                numOfAttempts: numAttempts,\n                retry: handleRetry(args),\n            })\n        }\n\n        // return our new descriptor\n        return (descriptor.value = retriedMethod), descriptor\n    }\n}\n\nconst DEFAULT_CONFIG: RetriableConfig = {\n    enabled: true,\n    numAttempts: 3,\n    onRetry: createDefaultRetryHandler(),\n}\n\n/**\n * The default config used by all Asyncretriable decorators.\n *\n * This config can be updated at runtime by setting its properties:\n *\n * ```\n * AsyncRetriable.config.numAttempts = 10\n * ```\n */\nAsyncRetriable.config = { ...DEFAULT_CONFIG }\n\n/**\n * Resets the config to its default state\n *\n * @returns {void}\n */\nAsyncRetriable.reset = () => {\n    AsyncRetriable.config = { ...DEFAULT_CONFIG }\n}\n","/**\n * Splits a comma-separated string into individual values\n * and discards any whitespace.\n *\n * @param {string} value\n * @returns {string[]}\n */\nexport const splitCommaSeparated = (value: string): string[] =>\n    value\n        .trim()\n        .split(/\\s*,\\s*/)\n        .filter(Boolean)\n","import { dump } from 'js-yaml'\nimport type { ComposeSpec } from './types'\n\nexport const serializeDockerComposeSpec = (spec: ComposeSpec): string => dump(spec)\n","import { createLogger, type Logger, printJson } from '@layerzerolabs/io-devtools'\nimport { OmniGraphBuilder, type Configurator, type IOmniSDK, type OmniGraph, type OmniSDKFactory } from '@/omnigraph'\nimport type { OmniTransaction } from '@/transactions'\n\nexport interface CreateConfigExecuteFlowArgs<TOmniGraph extends OmniGraph = OmniGraph, TSDK = IOmniSDK> {\n    configurator: Configurator<TOmniGraph, TSDK>\n    sdkFactory: OmniSDKFactory<TSDK>\n    logger?: Logger\n}\n\nexport interface ConfigExecuteFlowArgs<TOmniGraph extends OmniGraph = OmniGraph> {\n    graph: TOmniGraph\n}\n\nexport type ConfigExecuteFlow<TOmniGraph extends OmniGraph = OmniGraph> = (\n    args: ConfigExecuteFlowArgs<TOmniGraph>\n) => Promise<OmniTransaction[]>\n\nexport const createConfigExecuteFlow =\n    <TOmniGraph extends OmniGraph = OmniGraph, TSDK = IOmniSDK>({\n        logger = createLogger(),\n        configurator,\n        sdkFactory,\n    }: CreateConfigExecuteFlowArgs<TOmniGraph, TSDK>): ConfigExecuteFlow<TOmniGraph> =>\n    async ({ graph }: ConfigExecuteFlowArgs<TOmniGraph>): Promise<OmniTransaction[]> => {\n        logger.verbose(`Executing graph:\\n\\n${printJson(graph)}`)\n\n        // As an additional step, even though this task is getting called\n        // from controlled and type-safe environments (for now),\n        // we pass the graph through a builder\n        //\n        // We can discard the output, this step is only here to ensure that the graph is valid\n        // (this) call would throw if the graph was not valid\n        try {\n            logger.verbose(`Validating graph`)\n\n            OmniGraphBuilder.fromGraph(graph)\n        } catch (error) {\n            logger.verbose(`Provided graph does not look valid: ${error}`)\n\n            throw new Error(`An error occurred while validating OmniGraph configuration: ${error}`)\n        }\n\n        // The only thing this task does is it uses the provided arguments\n        // to compile a list of OmniTransactions\n        try {\n            return await configurator(graph, sdkFactory)\n        } catch (error) {\n            logger.verbose(`Encountered an error: ${error}`)\n\n            throw new Error(`An error occurred while getting the OApp configuration: ${error}`)\n        }\n    }\n","import { createLogger, importDefault, isFile, isReadable, Logger, printZodErrors } from '@layerzerolabs/io-devtools'\nimport type { SafeParseReturnType, ZodType, ZodTypeDef } from 'zod'\nimport type { OmniGraph } from '@/omnigraph'\nimport { resolve } from 'path'\n\nexport interface CreateConfigLoadFlowArgs<TOmniGraph = OmniGraph> {\n    configSchema: ZodType<TOmniGraph, ZodTypeDef, unknown>\n    logger?: Logger\n}\n\nexport interface ConfigLoadFlowArgs {\n    configPath: string\n}\n\nexport type ConfigLoadFlow<TOmniGraph = OmniGraph> = (args: ConfigLoadFlowArgs) => Promise<TOmniGraph>\n\n/**\n * A flow that loads a configuration file from `configPath` and validates it against a `configSchema`.\n *\n * The schema is responsible for any transformations that need to be done to turn the raw config into an `OmniGraph`\n * (e.g. transforming from hardhat-specific format).\n *\n * The config file can be in one of the supoorted formats:\n *\n * - JS\n * - TS\n * - JSON\n *\n * For the JS and TS versions, the config file can either export the config object directly\n * or can export a function that returns the config object (or a promise of the config object)\n *\n * @template TOmniGraph\n * @param ConfigLoadFlowArgs\n * @returns {Promise<TOmniGraph>}\n */\nexport const createConfigLoadFlow =\n    <TOmniGraph = OmniGraph>({\n        configSchema,\n        logger = createLogger(),\n    }: CreateConfigLoadFlowArgs<TOmniGraph>): ConfigLoadFlow<TOmniGraph> =>\n    async ({ configPath }): Promise<TOmniGraph> => {\n        logger.verbose(`Loading config from ${configPath}`)\n\n        const absolutePath = resolve(configPath)\n        logger.verbose(`Resolved config file location for '${configPath}': '${absolutePath}'`)\n\n        // First we check that the config file is indeed there and we can read it\n        logger.verbose(`Checking config file '${absolutePath}' for existence & readability`)\n        const isConfigReadable = isFile(absolutePath) && isReadable(absolutePath)\n        if (!isConfigReadable) {\n            throw new Error(\n                `Unable to read config file '${configPath}'. Check that the file exists and is readable to your terminal user`\n            )\n        }\n\n        // Keep talking to the user\n        logger.verbose(`Config file '${absolutePath}' exists & is readable`)\n\n        // Now let's see if we can load the config file\n        let rawConfig: unknown\n        try {\n            logger.verbose(`Loading config file '${absolutePath}'`)\n\n            rawConfig = await importDefault(absolutePath)\n        } catch (error) {\n            throw new Error(`Unable to read config file '${configPath}': ${error}`)\n        }\n\n        logger.verbose(`Loaded config file '${absolutePath}'`)\n\n        // Now let's check whether the config file contains a function\n        //\n        // If so, we'll execute this function and will expect a config as a result\n        let rawConfigMaterialized: unknown\n        if (typeof rawConfig === 'function') {\n            logger.verbose(`Executing configuration function from config file '${absolutePath}'`)\n\n            try {\n                rawConfigMaterialized = await rawConfig()\n            } catch (error) {\n                throw new Error(`Got an exception while executing config funtion from file '${configPath}': ${error}`)\n            }\n        } else {\n            logger.verbose(`Using exported value from config file '${absolutePath}'`)\n            rawConfigMaterialized = rawConfig\n        }\n\n        // It's time to make sure that the config is not malformed\n        //\n        // At this stage we are only interested in the shape of the data,\n        // we are not checking whether the information makes sense (e.g.\n        // whether there are no missing nodes etc)\n        logger.verbose(`Validating the structure of config file '${absolutePath}'`)\n\n        // We'll try/catch the schema validation (even though we are using the \"safe\" version,\n        // zod will just throw if any of the schema transformations throw)\n        //\n        // We do this so that we can prepend the error message with a more meaningful one\n        let configParseResult: SafeParseReturnType<unknown, TOmniGraph>\n        try {\n            configParseResult = await configSchema.safeParseAsync(rawConfigMaterialized)\n        } catch (error) {\n            throw new Error(`Config from file '${configPath}' is invalid: ${error}`)\n        }\n\n        if (configParseResult.success === false) {\n            const userFriendlyErrors = printZodErrors(configParseResult.error)\n\n            throw new Error(\n                `Config from file '${configPath}' is malformed. Please fix the following errors:\\n\\n${userFriendlyErrors}`\n            )\n        }\n\n        return configParseResult.data\n    }\n","import { OmniTransaction } from './types'\nimport { formatEid } from '@/omnigraph/format'\n\nexport const formatOmniTransaction = (\n    transaction: OmniTransaction\n): Record<string, string | number | bigint | undefined> => ({\n    Endpoint: formatEid(transaction.point.eid),\n    OmniAddress: transaction.point.address,\n    OmniContract: transaction.metadata?.contractName,\n    'Function Name': transaction.metadata?.functionName,\n    'Function Arguments': transaction.metadata?.functionArgs,\n    Description: transaction.description,\n    Data: transaction.data,\n    Value: transaction.value,\n    'Gas Limit': transaction.gasLimit,\n})\n","import { Logger, createModuleLogger, pluralizeNoun, pluralizeOrdinal } from '@layerzerolabs/io-devtools'\nimport type {\n    OmniSigner,\n    OmniSignerFactory,\n    OmniTransaction,\n    OmniTransactionReceipt,\n    OmniTransactionResponse,\n    OmniTransactionWithError,\n    OmniTransactionWithReceipt,\n    OmniTransactionWithResponse,\n} from './types'\nimport { formatEid, formatOmniPoint } from '@/omnigraph/format'\nimport { groupTransactionsByEid } from './utils'\nimport { EndpointId } from '@layerzerolabs/lz-definitions'\nimport assert from 'assert'\nimport type { OmniPoint } from '@/omnigraph'\n\n/**\n * Base class for all signers containing common functionality\n */\nexport abstract class OmniSignerBase implements OmniSigner {\n    /**\n     * @deprecated Use `OmniSigner.getPoint()` instead\n     */\n    public readonly eid: EndpointId\n\n    protected constructor(eid: EndpointId) {\n        this.eid = eid\n    }\n\n    abstract getPoint(): OmniPoint | Promise<OmniPoint>\n\n    abstract sign(transaction: OmniTransaction): Promise<string>\n\n    abstract signAndSend(transaction: OmniTransaction): Promise<OmniTransactionResponse>\n\n    /**\n     * helper method to ensure that the transaction we are trying to sign is on a correct network\n     *\n     * @param {OmniTransaction} transaction\n     */\n    protected assertTransaction(transaction: OmniTransaction) {\n        assert(\n            transaction.point.eid === this.eid,\n            `Could not use signer for ${formatEid(this.eid)} to sign a transaction for ${formatOmniPoint(\n                transaction.point\n            )}`\n        )\n    }\n}\n\nexport type SignAndSendResult = [\n    // All the successful transactions\n    successful: OmniTransactionWithReceipt[],\n    // The failed transactions along with the errors\n    errors: OmniTransactionWithError[],\n    // All the transactions that have not been executed (including the failed ones)\n    pending: OmniTransaction[],\n]\n\nexport type OnSignAndSendProgress = (\n    result: OmniTransactionWithReceipt,\n    results: OmniTransactionWithReceipt[]\n) => unknown\n\nexport type SignAndSend = (\n    transactions: OmniTransaction[],\n    onProgress?: OnSignAndSendProgress\n) => Promise<SignAndSendResult>\n\n/**\n * Creates a sign & send utility for a list of transaction\n * with a help of `OmniSignerFactory`\n *\n * @param {OmniSignerFactory} createSigner\n */\nexport const createSignAndSend =\n    (createSigner: OmniSignerFactory): SignAndSend =>\n    async (transactions, onProgress): Promise<SignAndSendResult> => {\n        const logger = createModuleLogger('sign & send')\n\n        // Put it here so that we don't need to type like seven toilet rolls of variable names\n        const n = transactions.length\n\n        // Just exit when there is nothing to sign\n        if (n === 0) {\n            return logger.debug(`No transactions to sign, exiting`), [[], [], []]\n        }\n\n        // Tell the user how many we are signing\n        logger.debug(`Signing ${n} ${pluralizeNoun(n, 'transaction')}`)\n\n        const transactionGroups = Array.from(groupTransactionsByEid(transactions).entries())\n\n        // We'll gather the state of the signing here\n        const successful: OmniTransactionWithReceipt[] = []\n        const errors: OmniTransactionWithError[] = []\n\n        const handleSuccess = (result: OmniTransactionWithReceipt) => {\n            // Here we want to update the global state of the signing\n            successful.push(result)\n\n            // We'll create a clone of the successful array so that the consumers can't mutate it\n            onProgress?.(result, [...successful])\n        }\n\n        const handleError = (error: OmniTransactionWithError) => {\n            // Update the error state\n            errors.push(error)\n        }\n\n        // Based on this feature flag we'll either wait for every transaction before sending the next one\n        // or we submit them all and wait at the very end\n        const useBatchedWait = !!process.env.LZ_ENABLE_EXPERIMENTAL_BATCHED_WAIT\n        if (useBatchedWait) {\n            logger.warn(`You are using experimental batched transaction waiting`)\n        }\n\n        const useBatchedSend = !!process.env.LZ_ENABLE_EXPERIMENTAL_BATCHED_SEND\n        if (useBatchedSend) {\n            logger.warn(`You are using experimental batched transaction sending`)\n        }\n\n        // First we create a signer logic based on the batched wait feature flag\n        const fallbackSignerLogic: TransactionSignerLogic = useBatchedWait\n            ? waitAfterSendingAll\n            : waitBeforeSubmittingNext\n        // Then we create the final signer logic based on the batched send feature flag\n        // The batched send logic will fall back on the default logic if batched send is not available\n        const signerLogic = useBatchedSend ? sendBatchedIfAvailable(fallbackSignerLogic) : fallbackSignerLogic\n\n        await Promise.allSettled(\n            transactionGroups.map(async ([eid, eidTransactions]): Promise<void> => {\n                const eidName = formatEid(eid)\n\n                logger.debug(\n                    `Signing ${eidTransactions.length} ${pluralizeNoun(eidTransactions.length, 'transaction')} for ${eidName}`\n                )\n\n                logger.debug(`Creating signer for ${eidName}`)\n                let signer: OmniSigner<OmniTransactionResponse<OmniTransactionReceipt>>\n\n                try {\n                    signer = await createSigner(eid)\n                } catch (error) {\n                    logger.error(`Failed to create a signer for ${eidName}: ${error}`)\n\n                    return handleError({\n                        error: new Error(`Failed to create a signer for ${eidName}: ${error}`),\n                        transaction: eidTransactions[0]!,\n                    })\n                }\n\n                await signerLogic(eid, logger, signer, eidTransactions, handleSuccess, handleError)\n\n                // Tell the inquisitive user what a good job we did\n                logger.debug(`Successfully signed ${n} ${pluralizeNoun(n, 'transaction')} for ${eidName}`)\n            })\n        )\n\n        // Now we create a list of the transactions that have not been touched\n        //\n        // We do this by taking all the transactions, then filtering out those\n        // that don't have a result associated with them\n        //\n        // This functionality relies on reference equality of the transactions objects\n        // so it's important that we don't mess with those and push the transaction\n        // objects directly to the `successful` and `errors` arrays, without any rest spreading or whatnot\n        const processed = new Set<OmniTransaction>(successful.map(({ transaction }) => transaction))\n        const pending = transactions.filter((transaction) => !processed.has(transaction))\n\n        return [successful, errors, pending]\n    }\n\ntype TransactionSignerLogic = (\n    eid: EndpointId,\n    logger: Logger,\n    signer: OmniSigner,\n    transactions: OmniTransaction[],\n    onSuccess: (resut: OmniTransactionWithReceipt) => void,\n    onError: (error: OmniTransactionWithError) => void\n) => Promise<void>\n\nconst sendBatchedIfAvailable =\n    (fallbackLogic: TransactionSignerLogic): TransactionSignerLogic =>\n    async (eid, logger, signer, transactions, onSuccess, onError) => {\n        const eidName = formatEid(eid)\n\n        // First we check that we can send batched transactions\n        //\n        // If we can't we fall back on the fallback logic\n        if (signer.signAndSendBatch == null) {\n            logger.warn(`Batched transaction sending is not available for ${eidName}, falling back on regular sending`)\n\n            return await fallbackLogic(eid, logger, signer, transactions, onSuccess, onError)\n        }\n\n        // For brevity we'll create a variable that holds a string with pluralized label for the transactions\n        // e.g. \"0 transactions\" or \"1 transaction\"\n        const transactionsName = pluralizeNoun(\n            transactions.length,\n            `1 transaction`,\n            `${transactions.length} transactions`\n        )\n\n        try {\n            logger.debug(`Signing a batch of ${transactionsName} for ${eidName}`)\n            const response = await signer.signAndSendBatch(transactions)\n\n            logger.debug(`Signed a batch of ${transactionsName} for ${eidName}, got hash ${response.transactionHash}`)\n            const receipt = await response.wait()\n\n            logger.debug(`Finished a batch of ${transactionsName} for ${eidName}`)\n\n            for (const transaction of transactions) {\n                onSuccess({ transaction, receipt })\n            }\n        } catch (error) {\n            logger.debug(`Failed to process a batch of ${transactionsName} for ${eidName}: ${error}`)\n\n            for (const transaction of transactions) {\n                onError({ transaction, error })\n            }\n        }\n    }\n\n/**\n * This transaction submitting logic will wait for every single transaction\n * before submitting the next one. This is the default logic, it results in transactions\n * being submitted in separate blocks.\n *\n * This is a safer yet slower strategy since:\n *\n * - A revert will only incur costs on the reverted transaction.\n * - A revert will stop the submitting, especially important if the transactions later on in the list\n *   rely heavily on the earlier ones without this reliance being coded into the contract\n */\nconst waitBeforeSubmittingNext: TransactionSignerLogic = async (\n    eid,\n    logger,\n    signer,\n    transactions,\n    onSuccess,\n    onError\n) => {\n    const eidName = formatEid(eid)\n\n    for (const [index, transaction] of transactions.entries()) {\n        // We want to refer to this transaction by index so we create an ordinal for it (1st, 2nd etc)\n        const ordinal = pluralizeOrdinal(index + 1)\n\n        try {\n            logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`)\n            const response = await signer.signAndSend(transaction)\n\n            logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`)\n\n            const receipt = await response.wait()\n            logger.debug(`Finished ${ordinal} transaction for ${eidName}`)\n\n            onSuccess({ transaction, receipt })\n        } catch (error) {\n            logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`)\n\n            // Update the error state\n            onError({ transaction, error })\n\n            // We want to stop the moment we hit an error\n            return\n        }\n    }\n}\n\n/**\n * This transaction submitting logic will submit all transactions first,\n * then wait for them once they all have been submitted. This is an experimental logic, it results in transactions\n * being submitted in potentially the same block.\n *\n * This is a more adventuurous yet faster strategy since:\n *\n * - A revert might incur costs on not only the reverted transaction but on the subsequent transactions as well\n * - A revert will not stop the submitting, especially important if the transactions later on in the list\n *   rely heavily on the earlier ones without this reliance being coded into the contract\n */\nconst waitAfterSendingAll: TransactionSignerLogic = async (eid, logger, signer, transactions, onSuccess, onError) => {\n    const eidName = formatEid(eid)\n\n    const responses: OmniTransactionWithResponse[] = []\n\n    for (const [index, transaction] of transactions.entries()) {\n        // We want to refer to this transaction by index so we create an ordinal for it (1st, 2nd etc)\n        const ordinal = pluralizeOrdinal(index + 1)\n\n        try {\n            logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`)\n            const response = await signer.signAndSend(transaction)\n\n            logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`)\n\n            responses.push({ transaction, response })\n        } catch (error) {\n            logger.debug(`Failed to sign ${ordinal} transaction for ${eidName}: ${error}`)\n\n            // Update the error state\n            onError({ transaction, error })\n\n            // Stop submitting any other transactions\n            break\n        }\n    }\n\n    for (const [index, { response, transaction }] of responses.entries()) {\n        // We want to refer to this transaction by index so we create an ordinal for it (1st, 2nd etc)\n        const ordinal = pluralizeOrdinal(index + 1)\n\n        try {\n            logger.debug(`Waiting for ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`)\n\n            const receipt = await response.wait()\n            logger.debug(`Finished ${ordinal} transaction for ${eidName}`)\n\n            onSuccess({ transaction, receipt })\n        } catch (error) {\n            logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`)\n\n            // Update the error state\n            onError({ transaction, error })\n        }\n    }\n}\n","import { formatOmniTransaction } from '@/transactions/format'\nimport { createSignAndSend, type SignAndSendResult } from '@/transactions/signer'\nimport type {\n    OmniSignerFactory,\n    OmniTransaction,\n    OmniTransactionWithError,\n    OmniTransactionWithReceipt,\n} from '@/transactions/types'\nimport {\n    createLogger,\n    createModuleLogger,\n    type Logger,\n    pluralizeNoun,\n    printBoolean,\n    printJson,\n    promptToContinue,\n} from '@layerzerolabs/io-devtools'\nimport { createProgressBar, printRecords, render } from '@layerzerolabs/io-devtools/swag'\n\nexport interface SignAndSendFlowArgs {\n    transactions: OmniTransaction[]\n}\n\nexport type SignAndSendFlow = (args: SignAndSendFlowArgs) => Promise<SignAndSendResult>\n\nexport interface CreateSignAndSendFlowArgs {\n    ci?: boolean\n    logger?: Logger\n    createSigner: OmniSignerFactory\n}\n\n/**\n * Sign and send flow is responsible for submitting (i.e. signing and sending)\n * a list of transactions using the signer factory.\n *\n * It is a high level function that can be used from any CLI implementation,\n * be it hardhat or a standalone script.\n *\n * @param {SignAndSendFlowArgs}\n * @returns {SignAndSendFlow}\n */\nexport const createSignAndSendFlow =\n    ({ ci = false, createSigner, logger = createLogger() }: CreateSignAndSendFlowArgs): SignAndSendFlow =>\n    async ({ transactions }: SignAndSendFlowArgs): Promise<SignAndSendResult> => {\n        // We only want to be asking users for input if we are not in interactive mode\n        const isInteractive = !ci\n\n        // We create a separate logger for flow-specific debug logs\n        const subtaskLogger = createModuleLogger(`signAndSendFlow`)\n\n        // Ask them whether they want to see them\n        const previewTransactions = isInteractive\n            ? await promptToContinue(`Would you like to preview the transactions before continuing?`)\n            : true\n        if (previewTransactions) {\n            printRecords(transactions.map(formatOmniTransaction))\n        }\n\n        // Now ask the user whether they want to go ahead with signing them\n        //\n        // If they don't, we'll just return the list of pending transactions\n        const shouldSubmit = isInteractive\n            ? await promptToContinue(`Would you like to submit the required transactions?`)\n            : true\n        if (!shouldSubmit) {\n            return subtaskLogger.verbose(`User cancelled the operation, exiting`), [[], [], transactions]\n        }\n\n        subtaskLogger.verbose(`Signing and sending transactions:\\n\\n${printJson(transactions)}`)\n\n        // The last step is to execute those transactions\n        //\n        // For now we are only allowing sign & send using the accounts confgiured in hardhat config\n        const signAndSend = createSignAndSend(createSigner)\n\n        // We'll use these variables to store the state of signing\n        let transactionsToSign: OmniTransaction[] = transactions\n        let successfulTransactions: OmniTransactionWithReceipt[] = []\n        let errors: OmniTransactionWithError[] = []\n\n        // We will run an infinite retry loop when signing the transactions\n        //\n        // This loop will be broken in these scenarios:\n        // - if all the transactions succeed\n        // - if some of the transactions fail\n        //      - in the interactive mode, if the user decides not to retry the failed transactions\n        //      - in the non-interactive mode\n        //\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // Now we render a progressbar to monitor the task progress\n            const progressBar = render(\n                createProgressBar({ before: 'Signing... ', after: ` 0/${transactionsToSign.length}` })\n            )\n\n            subtaskLogger.verbose(`Sending the transactions`)\n            const [successfulBatch, errorsBatch, pendingBatch] = await signAndSend(\n                transactionsToSign,\n                (result, results) => {\n                    // We'll keep updating the progressbar as we sign the transactions\n                    progressBar.rerender(\n                        createProgressBar({\n                            progress: results.length / transactionsToSign.length,\n                            before: 'Signing... ',\n                            after: ` ${results.length}/${transactionsToSign.length}`,\n                        })\n                    )\n                }\n            )\n\n            // And finally we drop the progressbar and continue\n            progressBar.clear()\n\n            // Now let's update the accumulators\n            //\n            // We'll append the successful transactions\n            successfulTransactions = [...successfulTransactions, ...successfulBatch]\n            // Overwrite the errrors\n            //\n            // We might in future return the error history but for now the last errors are okay\n            errors = errorsBatch\n            // And we update the array of transactions with the ones that did not make it through\n            transactionsToSign = pendingBatch\n\n            subtaskLogger.verbose(`Sent the transactions`)\n            subtaskLogger.debug(`Successfully sent the following transactions:\\n\\n${printJson(successfulBatch)}`)\n            subtaskLogger.debug(`Failed to send the following transactions:\\n\\n${printJson(errorsBatch)}`)\n            subtaskLogger.debug(`Did not send the following transactions:\\n\\n${printJson(pendingBatch)}`)\n\n            // Let the user know about the results of the batch\n            logger.info(\n                pluralizeNoun(\n                    successfulBatch.length,\n                    `Successfully sent 1 transaction`,\n                    `Successfully sent ${successfulBatch.length} transactions`\n                )\n            )\n\n            // If there are no errors, we break out of the loop immediatelly\n            if (errors.length === 0) {\n                logger.info(`${printBoolean(true)} Your OApp is now configured`)\n\n                break\n            }\n\n            // Now we bring the bad news to the user\n            logger.error(\n                pluralizeNoun(\n                    errors.length,\n                    `Failed to send 1 transaction`,\n                    `Failed to send ${errors.length} transactions`\n                )\n            )\n\n            const previewErrors = isInteractive\n                ? await promptToContinue(`Would you like to preview the failed transactions?`)\n                : true\n            if (previewErrors) {\n                printRecords(\n                    errors.map(({ error, transaction }) => ({\n                        error: String(error),\n                        ...formatOmniTransaction(transaction),\n                    }))\n                )\n            }\n\n            // We'll ask the user if they want to retry if we're in interactive mode\n            //\n            // If they decide not to, we exit, if they want to retry we start the loop again\n            const retry = isInteractive ? await promptToContinue(`Would you like to retry?`, true) : false\n            if (!retry) {\n                logger.error(`${printBoolean(false)} Failed to configure the OApp`)\n\n                break\n            }\n        }\n\n        return [successfulTransactions, errors, transactionsToSign]\n    }\n","import { createLogger, printJson, pluralizeNoun, type Logger } from '@layerzerolabs/io-devtools'\n\nimport type { ConfigExecuteFlow } from './config.execute'\nimport type { SignAndSendFlow } from './sign.and.send'\nimport type { OmniGraph } from '@/omnigraph'\nimport { formatOmniTransaction, type OmniTransaction, type SignAndSendResult } from '@/transactions'\nimport { printRecords } from '@layerzerolabs/io-devtools/swag'\n\nexport interface CreateWireFlowArgs<TOmniGraph extends OmniGraph> {\n    logger?: Logger\n    executeConfig: ConfigExecuteFlow<TOmniGraph>\n    signAndSend: SignAndSendFlow\n}\n\nexport interface WireFlowArgs<TOmniGraph extends OmniGraph> {\n    graph: TOmniGraph\n    assert?: boolean\n    dryRun?: boolean\n}\n\nexport const createWireFlow =\n    <TOmniGraph extends OmniGraph>({\n        logger = createLogger(),\n        executeConfig,\n        signAndSend,\n    }: CreateWireFlowArgs<TOmniGraph>) =>\n    async ({ graph, assert = false, dryRun = false }: WireFlowArgs<TOmniGraph>): Promise<SignAndSendResult> => {\n        if (assert) {\n            logger.info(`Running in assertion mode`)\n        } else if (dryRun) {\n            logger.info(`Running in dry run mode`)\n        }\n\n        // At this point we are ready to create the list of transactions\n        logger.verbose(`Creating a list of wiring transactions`)\n\n        // We'll get the list of OmniTransactions using the config execution flow\n        const transactions: OmniTransaction[] = await executeConfig({ graph })\n\n        // Flood users with debug output\n        logger.verbose(`Created a list of wiring transactions`)\n        logger.debug(`Following transactions are necessary:\\n\\n${printJson(transactions)}`)\n\n        // If there are no transactions that need to be executed, we'll just exit\n        if (transactions.length === 0) {\n            logger.info(`The OApp is wired, no action is necessary`)\n\n            return [[], [], []]\n        }\n\n        // If we are in a dry run mode, we print our the results and exit\n        if (dryRun) {\n            printRecords(transactions.map(formatOmniTransaction))\n\n            return [[], [], transactions]\n        }\n\n        // If we are in an assertion mode, we make sure there are no pending transactions\n        if (assert) {\n            // Let the user know something's about to go down\n            logger.error(`The OApp is not fully wired, following transactions are necessary:`)\n\n            // Print the outstanding transactions\n            printRecords(transactions.map(formatOmniTransaction))\n\n            // Mark the process as failed (if not already marked)\n            //\n            // TODO This is a bit ugly since we might not be running this in a standalone process\n            // so we might want to move the assert functionality outside of this flow\n            process.exitCode = process.exitCode || 1\n\n            // Return the list of pending transactions\n            return [[], [], transactions]\n        }\n\n        // Tell the user about the transactions\n        logger.info(\n            pluralizeNoun(\n                transactions.length,\n                `There is 1 transaction required to configure the OApp`,\n                `There are ${transactions.length} transactions required to configure the OApp`\n            )\n        )\n\n        // Now sign & send the transactions\n        const signAndSendResult: SignAndSendResult = await signAndSend({\n            transactions,\n        })\n\n        return signAndSendResult\n    }\n"]}