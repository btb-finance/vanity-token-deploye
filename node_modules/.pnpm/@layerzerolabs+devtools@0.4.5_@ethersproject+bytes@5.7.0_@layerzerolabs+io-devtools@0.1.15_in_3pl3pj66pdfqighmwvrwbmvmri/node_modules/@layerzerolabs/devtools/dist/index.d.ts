import { EndpointId } from '@layerzerolabs/lz-definitions';
import { Logger } from '@layerzerolabs/io-devtools';
import { z, ZodType, ZodTypeDef } from 'zod';

/**
 * Compares two object by value, returning `true` if they match
 *
 * ```
 * const theyMatch = isDeepEqual({ a: 1 }, { a: 1 }) // true
 * const theyDontMatch = isDeepEqual({ a: 1 }, { a: '1' }) // false
 * ```
 *
 * @param {unknown} a
 * @param {unknown} b
 * @returns {boolean}
 */
declare const isDeepEqual: (a: unknown, b: unknown) => boolean;

type Bytes32 = string;
type Bytes20 = string;
type Bytes = string;
type PossiblyBigInt = string | number | bigint;
type OmniAddress = Bytes32 | Bytes20;
type PossiblyBytes = Bytes | Bytes32 | Bytes20 | Uint8Array;
/**
 * Generic type for a hybrid (sync / async) factory
 * that generates an instance of `TOutput` based on arguments of type `TInput`
 *
 * `TInput` represents the list of all function arguments that need to be passed to the factory:
 *
 * ```typescript
 * const mySyncFactory: Factory<[number, boolean], string> = (num: number, bool: boolean): string => "hello"
 *
 * const mySyncFactory: Factory<[], string> = async () => "hello"
 * ```
 *
 * The hybrid aspect just makes it easier for implementers - if the logic is synchronous,
 * this type will not force any extra `async`.
 */
type Factory<TInput extends unknown[], TOutput> = (...input: TInput) => TOutput | Promise<TOutput>;
type EndpointBasedFactory<TValue> = Factory<[eid: EndpointId], TValue>;
type RpcUrlFactory = EndpointBasedFactory<string>;
/**
 * Helper type that grabs all the keys of a type / an interface
 * that are not defined as undefined or unknown
 *
 * ```typescript
 * interface A {
 *   nown: string;
 *   unown: unknown
 *   udefned: undefined
 *   noll: null
 * }
 *
 * // Will be 'nown' | 'noll'
 * type MandatoryKeysOFA = GetMandatoryKeys<A>
 * ```
 */
type GetMandatoryKeys<T> = {
    [P in keyof T]: T[P] extends Exclude<T[P], NonNullable<unknown> | null> ? never : undefined extends T[P] ? never : P;
}[keyof T];
/**
 * Helper type that turns all properties defined as unknown or undefined
 * into optional properties
 */
type WithOptionals<T> = Partial<T> & Pick<T, GetMandatoryKeys<T>>;
/**
 * Helper type for loosening the user configuration types
 * when it comes to `bigint`s.
 *
 * It will recursively replace all the `bigint` types,
 * preserving the types structure, with `PossiblyBigInt` type.
 *
 * ```
 * interface Config {
 *   values: bigint[]
 * }
 *
 * type UserConfig = WithLooseBigInts<Config>
 *
 * const userConfig: UserConfig = {
 *   values: ["124", 124, BigInt(124)]
 * }
 * ```
 */
type WithLooseBigInts<T> = T extends bigint ? PossiblyBigInt : T extends Set<bigint> ? Set<PossiblyBigInt> : T extends Map<infer K, infer V> ? Map<WithLooseBigInts<K>, WithLooseBigInts<V>> : T extends {
    [K in keyof T]: T[K];
} ? {
    [K in keyof T]: WithLooseBigInts<T[K]>;
} : T extends Promise<infer V> ? Promise<WithLooseBigInts<V>> : T;

/**
 * Converts an address into Bytes32 by padding it with zeros.
 *
 * It will return zero bytes if passed `null`, `undefined` or an empty string.
 *
 * @param {PossiblyBytes | null | undefined} bytes
 * @returns {string}
 */
declare const makeBytes32: (bytes?: PossiblyBytes | null | undefined) => string;
/**
 * Compares two Bytes32-like values by value (i.e. ignores casing on strings
 * and string length)
 *
 * @param {PossiblyBytes | null | undefined} a
 * @param {PossiblyBytes | null | undefined} b
 * @returns {boolean}
 */
declare const areBytes32Equal: (a: PossiblyBytes | null | undefined, b: PossiblyBytes | null | undefined) => boolean;
/**
 * Checks whether a value is a zero value.
 *
 * It will return true if passed `null`, `undefined`, empty bytes ('0x') or an empty string.
 *
 * It will throw an error if the value is not a valid numerical value.
 *
 * @param {PossiblyBytes | PossiblyBigInt | null | undefined} value
 * @returns {boolean}
 */
declare const isZero: (value: PossiblyBytes | PossiblyBigInt | null | undefined) => boolean;
/**
 * Turns a potentially zero address into undefined
 *
 * @param {PossiblyBytes | PossiblyBigInt | null | undefined} value
 *
 * @returns {string | undefined}
 */
declare const ignoreZero: <T extends PossiblyBytes | PossiblyBigInt>(value?: T | null | undefined) => T | undefined;
/**
 * Helper function to be used when sorting of addresses is necessary.
 *
 * This can be used to sort arrays of addresses in ascending manner:
 *
 * ```
 * // The result will be ["0x000000000000000000636F6e736F6c652e6c6f67", "0xEe6cF2E1Bc7645F8439d241ce37820305F2BB3F8"]
 * ["0xEe6cF2E1Bc7645F8439d241ce37820305F2BB3F8", "0x000000000000000000636F6e736F6c652e6c6f67"].sort(compareBytes32Ascending)
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare}
 *
 * @param {PossiblyBytes} a
 * @param {PossiblyBytes} b
 * @returns {number} `0` when the two are interchangeable, a negative value when `a` comes before `b` and a positive value when `a` comes after `b`
 */
declare const compareBytes32Ascending: (a: PossiblyBytes, b: PossiblyBytes) => number;
/**
 * Normalizes a network-specific peer address into a byte array with length of 32.
 *
 * @param {OmniAddress} address
 * @param {EndpointId} eid
 * @returns {Uint8Array}
 */
declare const normalizePeer: (address: OmniAddress | null | undefined, eid: EndpointId) => Uint8Array;
/**
 * Denormalizes Bytes32 representing a peer address into a network-specific peer address.
 *
 * @param {Uint8Array} bytes
 * @param {EndpointId} eid
 * @returns {OmniAddress}
 */
declare const denormalizePeer: (bytes: Uint8Array | null | undefined, eid: EndpointId) => OmniAddress | undefined;
/**
 * Helper utility to convert `UInt8Array` into a hex string (with leading `0x`)
 *
 * @param {Uint8Array} bytes
 * @returns {string}
 */
declare const toHex: (bytes: Uint8Array) => string;
/**
 * Helper utility to convert a hex string (with or without leading `0x`) to `UInt8Array`
 *
 * @param {string} hex
 * @returns {Uint8Array}
 */
declare const fromHex: (hex: string) => Uint8Array;

/**
 * Helper type for argumentless factories a.k.a. tasks
 */
type Task<T> = Factory<[], T>;
/**
 * Executes tasks in sequence, waiting for each one to finish before starting the next one
 *
 * Will resolve with the output of all tasks or reject with the first rejection.
 *
 * @param {Task<T>[]} tasks
 * @returns {Promise<T[]>}
 */
declare const sequence: <T>(tasks: Task<T>[]) => Promise<T[]>;
/**
 * Executes tasks in parallel
 *
 * Will resolve with the output of all tasks or reject with the any rejection.
 *
 * @param {Task<T>[]} tasks
 * @returns {Promise<T[]>}
 */
declare const parallel: <T>(tasks: Task<T>[]) => Promise<T[]>;
/**
 * Creates a default applicative based on an environment feature flag.
 *
 * For now we keep the parallel execution as an opt-in feature flag
 * before we have a retry logic fully in place for the SDKs
 *
 * This is to avoid 429 too many requests errors from the RPCs
 *
 * @param logger
 * @returns
 */
declare const createDefaultApplicative: (logger?: Logger) => <T>(tasks: Task<T>[]) => Promise<T[]>;
/**
 * Maps the errors coming from a task. Errors thrown from the `toError`
 * callback will not be caught.
 *
 * ```
 * const functionThatMightThrow = () => sdk.getSomeAttribute()
 *
 * const result = await mapError(functionThatMightThrow, (error) => new Error(`Error produced: ${error}`))
 * ```
 *
 * @template T
 * @template E
 * @param {(error: unknown) => E} toError Error mapping function
 */
declare const mapError: <T, E = unknown>(task: Task<T>, toError: (error: unknown) => E) => Promise<Awaited<T>>;
/**
 * Intercepts any errors coming from a task. The return value
 * of this call will be the return value of the task
 * and the rejected value will be the original erorr.
 *
 * Any errors or rejections from the `onError` callback will be caught
 * and the original error will be rethrown.
 *
 * ```
 * const functionThatMightThrow = () => sdk.getSomeAttribute()
 *
 * // With custom logging
 * const result = await tapError(functionThatMightThrow, (error) => console.error('Something went wrong:', error))
 *
 * // For lazy people
 * const result = await tapError(functionThatMightThrow, console.error)
 * ```
 *
 * @param {Factory<[error: unknown], void>} onError Synchronous or asynchronous error callback
 */
declare const tapError: <T>(task: Task<T>, onError: Factory<[error: unknown], void>) => Promise<Awaited<T>>;
/**
 * Executes tasks in a sequence until one resolves.
 *
 * Will resolve with the output of the first task that resolves
 * or reject with the last rejection.
 *
 * Will reject immediatelly if no tasks have been passed
 *
 * @param {Task<T>[]} tasks
 * @returns {Promise<T>}
 */
declare const first: <T>(tasks: Task<T>[]) => Promise<T>;
/**
 * Helper utility for currying first() - creating a function
 * that behaves like first() but accepts arguments that will be passed to the factory functions
 *
 * @param {Factory<TInput, TOutput>[]} factories
 * @returns {Factory<TInput, TOutput>}
 */
declare const firstFactory: <TInput extends unknown[], TOutput>(...factories: Factory<TInput, TOutput>[]) => Factory<TInput, TOutput>;
/**
 * RetryStrategy represents a function that, when passed to `createRetryFactory`,
 * controls the execution of a retried function.
 *
 * It will be executed on every failed attempt and has the ability to modify the
 * input originally passed to the retried function.
 *
 * In its simplest form, it will either return `true` (to retry again) or `false` (stop retrying).
 *
 * In its advanced form, it can use the parameters passed to it to create
 * a new set of arguments passed to the function being retried:
 *
 * ```
 * // As a simple example let's consider a function
 * // whose argument is the amount of money we want to pay for a service
 * const functionThatCanFail = (money: number): Promise<void> => { ... }
 *
 * // We can create a strategy that will keep adding 1 to the amount of money
 * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => [previousMoney + 1]
 *
 * // Or we can create a strategy that will adjust the money based on the initial value
 * //
 * // In this made up case it will take the original amount and will add 2 for every failed attempt
 * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => [originalMoney + attempt * 2]
 *
 * // Or we can go insane with our logic and can, because without objective morality
 * // everything is permissible, update the amount on every other attempt
 * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => attempt % 2 ? [previousMoney + 1] : true
 * ```
 *
 * @param {number} attempt The 0-indexed attempt that the retry function is performing
 * @param {unknown} error The error thrown from the previous execution of the retried function
 * @param {TInput} previousInput The input passed to the previous execution of the retried function
 * @param {TInput} originalInput The input passed to the first execution of the retried function
 */
type RetryStrategy<TInput extends unknown[]> = Factory<[
    attempt: number,
    error: unknown,
    previousInput: TInput,
    originalInput: TInput
], TInput | boolean>;
/**
 * Uses the retry strategy to create a function that can wrap any function with retry logic.
 *
 * ```
 * // As a simple example let's consider a function
 * // whose argument is the amount of money we want to pay for a service
 * const functionThatCanFail = (money: number): Promise<void> => { ... }
 *
 * // By default, it will use a three-times-and-fail retry strategy
 * const retry = createRetryFactory()
 *
 * // It can wrap any function (sync or async) that can throw or reject
 * const retriedFunctionThatCanFail = retry(functionThatCanFail)
 *
 * // The function can then be called just like the original, wrapped function
 * retriedFunctionThatCanFail(1_000_000)
 *
 * // For advanced cases, you can use your own strategy
 * const strategy: RetryStrategy<[money: number]> = () => { ... }
 * const retry = createRetryFactory(strategy)
 * ```
 *
 * @see {@link createSimpleRetryStrategy}
 * @see {@link RetryStrategy}
 *
 * @param {RetryStrategy<TInput>} [strategy] `RetryStrategy` to use. Defaults to a simple strategy that retries three times
 * @returns {<TOutput>(task: Factory<TInput, TOutput>) => Factory<TInput, TOutput>}
 */
declare const createRetryFactory: <TInput extends unknown[]>(strategy?: RetryStrategy<TInput>) => (<TOutput>(task: Factory<TInput, TOutput>) => Factory<TInput, TOutput>);
/**
 * Creates a simple `RetryStrategy` that will retry N times.
 *
 * If you want to compose this strategy, you can pass `wrappedStrategy`:
 *
 * ```
 * const myVeryAdvancedStrategy: RetryStrategy<[string, number]> = () => { ... }
 * const myVeryAdvancedStrategyThatWillRetryThreeTimesOnly = createSimpleRetryStrategy(3, myVeryAdvancedStrategy)
 * ```
 *
 * @param {number} numAttempts Must be larger than 0
 * @param {RetryStrategy<TInput>} [wrappedStrategy] Strategy to use if the number of attempts has not been reached yet
 * @returns {RetryStrategy<TInput>}
 */
declare const createSimpleRetryStrategy: <TInput extends unknown[]>(numAttempts: number, wrappedStrategy?: RetryStrategy<TInput>) => RetryStrategy<TInput>;

type OnRetry<TInstance, TArgs extends unknown[] = unknown[]> = (attempt: number, numAttempts: number, error: unknown, target: TInstance, method: string, args: TArgs) => boolean | void | undefined;
interface RetriableConfig<TInstance = unknown> {
    /**
     * Enable / disable the retry behavior
     */
    enabled: boolean;
    /**
     * The maximum delay, in milliseconds, between two consecutive attempts.
     *
     * @default Infinity
     */
    maxDelay?: number;
    /**
     * Number of times the method call will be retried. The default is 3
     *
     * @default 3
     */
    numAttempts: number;
    /**
     * Callback called on every failed attempt.
     *
     * @param {number} attempt 1-indexed number of attempt of executing the method
     * @param {number} numAttempts Maximum/total number of attempts that will be executed
     * @param {unknown} error The error that caused the function to be retried
     * @param {unknown} target The object whose method is being retried
     * @param {string} method The method name
     * @param {unknown[]} args The method parameters
     * @returns {boolean | undefined} This function can stop the retry train by returning false
     */
    onRetry: OnRetry<TInstance>;
}
interface TAsyncRetriable {
    <TArgs extends unknown[], TResult>(overrides?: Partial<RetriableConfig>): (target: unknown, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: TArgs) => Promise<TResult>>) => TypedPropertyDescriptor<(...args: TArgs) => Promise<TResult>>;
    /**
     * The default config used by all Asyncretriable decorators.
     *
     * This config can be updated at runtime by setting its properties:
     *
     * ```
     * AsyncRetriable.config.numAttempts = 10
     * ```
     */
    config: RetriableConfig;
    /**
     * Resets the config to its default state
     *
     * @returns {void}
     */
    reset: () => void;
}
/**
 * Helper function that creates a default debug logger for the `onRetry`
 * callback of `AsyncRetriable`
 */
declare const createDefaultRetryHandler: (loggerName?: string) => OnRetry<unknown>;
declare const AsyncRetriable: TAsyncRetriable;

/**
 * Splits a comma-separated string into individual values
 * and discards any whitespace.
 *
 * @param {string} value
 * @returns {string[]}
 */
declare const splitCommaSeparated: (value: string) => string[];

type ComposeSpecVersion = '3.9';
interface ComposeSpecServiceHealthcheck {
    disable?: boolean;
    interval?: string;
    retries?: number;
    test?: string | string[];
    timeout?: string;
    start_period?: string;
    start_interval?: string;
}
interface ComposeSpecServiceBuild {
    context?: string;
    dockerfile?: string;
    dockerfile_inline?: string;
    args?: ListOrDict;
    ssh?: ListOrDict;
    labels?: ListOrDict;
    cache_from?: string[];
    cache_to?: string[];
    no_cache?: boolean;
    network?: string;
    pull?: boolean;
    target?: string;
    privileged?: boolean;
    tags?: string[];
    platforms?: string[];
}
interface ComposeSpecPortDefinition {
    name?: string;
    mode?: string;
    host_ip?: string;
    target?: number;
    published?: string | number;
    protocol?: string;
}
type ComposeSpecPortNumber = string | number;
type ComposeSpecPort = `${ComposeSpecPortNumber}:${ComposeSpecPortNumber}` | ComposeSpecPortNumber | ComposeSpecPortDefinition;
interface ComposeSpecServiceVolumeDefinition {
    type: string;
    source?: string;
    target?: string;
    read_only?: boolean;
    consistency?: string;
    bind?: {
        propagation?: string;
        create_host_path?: boolean;
        selinux?: 'z' | 'Z';
    };
    volume?: {
        nocopy?: boolean;
    };
    tmpfs?: {
        size?: number | string;
        mode?: number;
    };
}
type ComposeSpecServiceVolume = string | ComposeSpecServiceVolumeDefinition;
type ComposeSpecDependencyCondition = 'service_started' | 'service_healthy' | 'service_completed_successfully';
interface ComposeSpecDependsOnDefinition {
    restart?: boolean;
    required?: boolean;
    condition: ComposeSpecDependencyCondition;
}
type ComposeSpecServiceDependsOn = string[] | Record<string, ComposeSpecDependsOnDefinition>;
type ComposeSpecServiceCommand = string | string[];
interface ComposeSpecService {
    depends_on?: ComposeSpecServiceDependsOn;
    build?: string | ComposeSpecServiceBuild;
    image?: string;
    expose?: ComposeSpecPortNumber[];
    command?: ComposeSpecServiceCommand;
    ports?: ComposeSpecPort[];
    volumes?: ComposeSpecServiceVolume[];
    healthcheck?: ComposeSpecServiceHealthcheck;
}
type ComposeSpecServices = Record<string, ComposeSpecService>;
interface ComposeSpecVolumeDefinition {
    name?: string;
    driver?: string;
    driver_opts?: Record<string, string | number>;
    labels?: ListOrDict;
}
type ComposeSpecVolume = null | ComposeSpecVolumeDefinition;
type ComposeSpecVolumes = Record<string, ComposeSpecVolume>;
interface ComposeSpec {
    version?: ComposeSpecVersion;
    services?: ComposeSpecServices;
    volumes?: ComposeSpecVolumes;
}
type ListOrDict = Record<string, string | number | boolean | null> | string[];

declare const serializeDockerComposeSpec: (spec: ComposeSpec) => string;

/**
 * OmniPoint identifies a point in omniverse, an omnichain universe.
 *
 * In layman terms this is a contract deployed on a particular network (represented by an endpoint).
 */
type OmniPoint = WithEid<{
    address: OmniAddress;
    contractName?: string | null;
}>;
/**
 * OmniVector identifies a vector in omniverse, an omnichain universe.
 *
 * In layman terms this is a directional connection between two contracts - two points of the omniverse
 */
interface OmniVector {
    from: OmniPoint;
    to: OmniPoint;
}
/**
 * OmniError represents an arbitrary error that occurred on a particular point in omniverse.
 */
interface OmniError<TError = unknown> {
    point: OmniPoint;
    error: TError;
}
/**
 * OmniNode represents a point in omniverse
 * with an additional piece of information attached
 */
type OmniNode<TConfig = unknown> = WithOptionals<{
    point: OmniPoint;
    config: TConfig;
}>;
/**
 * OmniEdge represents a connection between two points in omniverse
 * with an additional piece of information attached
 */
type OmniEdge<TConfig = unknown> = WithOptionals<{
    vector: OmniVector;
    config: TConfig;
}>;
/**
 * OmniGraph is a collection of nodes and edges of omniverse
 * that together represent an omnichain app a.k.a. OApp.
 *
 * For purposes of readability and to avoid overabstraction on the user end,
 * the names are set to be `contracts` rather than `nodes` and `connections` rather than `edges`
 */
interface OmniGraph<TNodeConfig = unknown, TEdgeConfig = unknown> {
    contracts: OmniNode<TNodeConfig>[];
    connections: OmniEdge<TEdgeConfig>[];
}
/**
 * Helper type for inferring the type of element in the `contracts` array of an `OmniGraph`
 */
type InferOmniNode<TOmniGraph extends OmniGraph> = TOmniGraph['contracts'][number];
/**
 * Helper type for inferring the type of element in the `connections` array of an `OmniGraph`
 */
type InferOmniEdge<TOmniGraph extends OmniGraph> = TOmniGraph['connections'][number];
/**
 * Helper type that adds eid property to an underlying type
 */
type WithEid<TValue> = TValue & {
    eid: EndpointId;
};
/**
 * Base interface for all SDKs
 */
interface IOmniSDK {
    point: OmniPoint;
}
/**
 * Base factory for all SDK factories
 */
type OmniSDKFactory<TOmniSDK = IOmniSDK, TOmniPoint = OmniPoint> = Factory<[TOmniPoint], TOmniSDK>;
/**
 * Helper type for configuration functions
 */
type Configurator<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = (graph: TOmniGraph, createSdk: OmniSDKFactory<TOmniSDK>) => Promise<OmniTransaction[]>;

declare class OmniGraphBuilder<TNodeConfig = unknown, TEdgeConfig = unknown> {
    #private;
    /**
     * Syntactic sugar utility for cloning graphs
     *
     * @param {OmniGraph<TNodeConfig, TEdgeConfig>} graph
     * @returns {OmniGraph<TNodeConfig, TEdgeConfig>}
     */
    static fromGraph<TNodeConfig = unknown, TEdgeConfig = unknown>(graph: OmniGraph<TNodeConfig, TEdgeConfig>): OmniGraphBuilder<TNodeConfig, TEdgeConfig>;
    addNodes(...nodes: OmniNode<TNodeConfig>[]): this;
    addEdges(...edges: OmniEdge<TEdgeConfig>[]): this;
    removeNodeAt(point: OmniPoint): this;
    removeEdgeAt(vector: OmniVector): this;
    getNodeAt(point: OmniPoint): OmniNode<TNodeConfig> | undefined;
    getEdgeAt(vector: OmniVector): OmniEdge<TEdgeConfig> | undefined;
    getEdgesFrom(point: OmniPoint): OmniEdge<TEdgeConfig>[];
    getEdgesTo(point: OmniPoint): OmniEdge<TEdgeConfig>[];
    get nodes(): OmniNode<TNodeConfig>[];
    get edges(): OmniEdge<TEdgeConfig>[];
    get graph(): OmniGraph<TNodeConfig, TEdgeConfig>;
}

interface OmniTransaction {
    point: OmniPoint;
    data: string;
    description?: string;
    gasLimit?: string | bigint | number;
    value?: string | bigint | number;
    metadata?: OmniTransactionMetadata;
}
interface OmniTransactionMetadata {
    contractName?: string;
    functionName?: string;
    functionArgs?: string;
}
interface OmniTransactionWithResponse<TReceipt extends OmniTransactionReceipt = OmniTransactionReceipt> {
    transaction: OmniTransaction;
    response: OmniTransactionResponse<TReceipt>;
}
interface OmniTransactionWithReceipt<TReceipt extends OmniTransactionReceipt = OmniTransactionReceipt> {
    transaction: OmniTransaction;
    receipt: TReceipt;
}
interface OmniTransactionWithError<TError = unknown> {
    transaction: OmniTransaction;
    error: TError;
}
interface OmniTransactionResponse<TReceipt extends OmniTransactionReceipt = OmniTransactionReceipt> {
    transactionHash: string;
    wait: (confirmations?: number) => Promise<TReceipt>;
}
interface OmniTransactionReceipt {
    transactionHash: string;
}
interface OmniSigner<TResponse extends OmniTransactionResponse = OmniTransactionResponse> {
    /**
     * @deprecated Use `OmniSigner.getPoint().eid` instead
     */
    eid: EndpointId;
    getPoint(): OmniPoint | Promise<OmniPoint>;
    sign: (transaction: OmniTransaction) => Promise<string>;
    signAndSend: (transaction: OmniTransaction) => Promise<TResponse>;
    /**
     * Signers can support multi send / batch mode
     * where multiple transactions get submitted together.
     *
     * Examples of this are Gnosis Safe signer or a signer using an EVM multicall contract.
     *
     * @param {OmniTransaction[]} transactions
     */
    signAndSendBatch?: (transactions: OmniTransaction[]) => Promise<TResponse>;
}
type OmniSignerFactory<TSigner extends OmniSigner = OmniSigner> = EndpointBasedFactory<TSigner>;

type CreateTransactionsFromOmniNodes<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = Factory<[
    InferOmniNode<TOmniGraph>,
    TOmniSDK,
    TOmniGraph,
    OmniSDKFactory<TOmniSDK>
], OmniTransaction[] | OmniTransaction | null | undefined>;
type CreateTransactionsFromOmniEdges<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = Factory<[
    InferOmniEdge<TOmniGraph>,
    TOmniSDK,
    TOmniGraph,
    OmniSDKFactory<TOmniSDK>
], OmniTransaction[] | OmniTransaction | null | undefined>;
/**
 * Function that takes care of the boilerplate for node configuration functions.
 *
 * It will create an SDK for every node in the graph, then call `createTransactions`
 * with the node itself, the created SDK, the whole graph and the SDK factory.
 *
 * ```
 * const configureSomething = createConfigureNodes(async ({ config }: OmniNode<{ something: string }>, sdk) => {
 *   const something = await sdk.getSomething()
 *   if (something !== config.something) return []
 *
 *   return sdk.setSomething(config.something)
 * })
 * ```
 *
 * @template TOmniGraph
 * @template TOmniSDK
 * @param {CreateTransactionsFromOmniNodes<TOmniGraph, TOmniSDK>} createTransactions
 * @returns {Configurator<TOmniGraph, TOmniSDK>}
 */
declare const createConfigureNodes: <TOmniGraph extends OmniGraph = OmniGraph<unknown, unknown>, TOmniSDK = IOmniSDK>(createTransactions: CreateTransactionsFromOmniNodes<TOmniGraph, TOmniSDK>) => Configurator<TOmniGraph, TOmniSDK>;
/**
 * Function that takes care of the boilerplate for edge configuration functions.
 *
 * It will create an SDK for every edge (using the `from` field) in the graph, then call `createTransactions`
 * with the edge itself, the created SDK, the whole graph and the SDK factory.
 *
 * ```
 * const configureSomething = createConfigureEdges(async ({ config, vector: { to } }: OmniEdge<{ something: string }>, sdk) => {
 *   const something = await sdk.getSomethingFor(to.eid)
 *   if (something !== config.something) return []
 *
 *   return sdk.setSomething(to.eid, config.something)
 * })
 * ```
 *
 * @template TOmniGraph
 * @template TOmniSDK
 * @param {CreateTransactionsFromOmniEdges<TOmniGraph, TOmniSDK>} createTransactions
 * @returns {Configurator<TOmniGraph, TOmniSDK>}
 */
declare const createConfigureEdges: <TOmniGraph extends OmniGraph = OmniGraph<unknown, unknown>, TOmniSDK = IOmniSDK>(createTransactions: CreateTransactionsFromOmniEdges<TOmniGraph, TOmniSDK>) => Configurator<TOmniGraph, TOmniSDK>;
/**
 * Helper function that takes multiple configurators and executes them
 * (the execution is parallel or serial based on the LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION
 * feature flag at the moment)
 *
 * ```
 * const configureOApp = createConfigureMultiple(
 *   configureOAppPeers
 *   configureSendLibraries
 *   configureReceiveLibraries
 *   configureReceiveLibraryTimeouts
 *   configureSendConfig
 *   configureReceiveConfig
 *   configureEnforcedOptions,
 *   configureCallerBpsCap,
 *   configureOAppDelegates
 * )
 * ```
 *
 * @param {...Configurator<TOmniGraph, TOmniSDK>} configurators An array of configuration functions
 * @returns {Configurator<TOmniGraph, TOmniSDK>}
 */
declare const createConfigureMultiple: <TOmniGraph extends OmniGraph = OmniGraph<unknown, unknown>, TOmniSDK = IOmniSDK>(...configurators: Configurator<TOmniGraph, TOmniSDK>[]) => Configurator<TOmniGraph, TOmniSDK>;

/**
 * Compares two points by value
 *
 * @param a `OmniPoint`
 * @param b `OmniPoint`
 *
 * @returns `true` if the vector point to the same point in omniverse
 */
declare const arePointsEqual: (a: OmniPoint, b: OmniPoint) => boolean;
/**
 * Checks if two points are on the same endpoint
 *
 * @param a `OmniPoint`
 * @param b `OmniPoint`
 *
 * @returns `true` if the vector point to the same point in omniverse
 */
declare const areSameEndpoint: (a: OmniPoint, b: OmniPoint) => boolean;
/**
 * Compares two vectors by value
 *
 * @param a `OmniVector`
 * @param b `OmniVector`
 *
 * @returns `true` if the vector point from and to the same point in omniverse
 */
declare const areVectorsEqual: (a: OmniVector, b: OmniVector) => boolean;
/**
 * Checks that a vector is _possible_ - i.e. connects two endpoints
 * that can be connected in reality.
 *
 * @param vector `OmniVector`
 *
 * @returns `true` if two points of the vector can be connected in reality
 */
declare const isVectorPossible: ({ from, to }: OmniVector) => boolean;
/**
 * Serializes a point. Useful for when points need to be used in Map
 * where we cannot adjust the default behavior of using a reference equality
 *
 * @param point `OmniPoint`
 *
 * @returns `string`
 */
declare const serializePoint: ({ address, eid }: OmniPoint) => string;
/**
 * Serializes a vector. Useful for when vectors need to be used in Map
 * where we cannot adjust the default behavior of using a reference equality
 *
 * @param point `OmniVector`
 *
 * @returns `string`
 */
declare const serializeVector: ({ from, to }: OmniVector) => string;
/**
 * Helper function to quickly convert a pair of nodes to a vector
 *
 * @param a `OmniNode`
 * @param b `OmniNode`
 * @returns `OmniVector`
 */
declare const vectorFromNodes: (a: OmniNode, b: OmniNode) => OmniVector;
/**
 * Helper function to add an `eid` to arbitrary values, converting them to `WithEid`
 *
 * This is useful to reduce repetition when e.g. creating multiple `OmniPoint` instances on the same network:
 *
 * ```
 * const onMainnet = withEid(EndpointId.ETHEREUM_V2_MAINNET)
 *
 * const onePoint = onMainnet({ address: '0x0' })
 * const anotherPoint = onMainnet({ address: '0x1' })
 * ```
 */
declare const withEid: (eid: EndpointId) => <T>(value: T) => WithEid<T>;

type Hash = string | number | boolean | bigint;
/**
 * Data structure similar to the default ES6 Map
 * with one crucial difference - it requires a hash function
 * which allows it to store values not by reference, but by value
 *
 * The implementation is quite naive as it uses three additional maps
 * to be able to easily implement the ES6 Map interface. This comes at a small
 * storage price which, in our environment, is perfectly negligible.
 *
 * The interface matches the interface of Map with one syntactic sugar added:
 * the getOrElse method that prevents us from having to do null checks on get.
 */
declare abstract class AbstractMap<K, V> implements Map<K, V> {
    #private;
    protected abstract hash(key: K): Hash;
    constructor(entries?: Iterable<[K, V]>);
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: unknown): void;
    get(key: K): V | undefined;
    getOrElse(key: K, orElse: () => V): V;
    has(key: K): boolean;
    set(key: K, value: V): this;
    get size(): number;
    entries(): IterableIterator<[K, V]>;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    [Symbol.iterator](): IterableIterator<[K, V]>;
    [Symbol.toStringTag]: string;
}

declare class OmniPointMap<V, K extends OmniPoint = OmniPoint> extends AbstractMap<K, V> {
    [Symbol.toStringTag]: string;
    protected hash(point: K): string;
}
declare class OmniVectorMap<V, K extends OmniVector = OmniVector> extends AbstractMap<K, V> {
    [Symbol.toStringTag]: string;
    protected hash(vector: K): string;
}

declare const formatEid: (eid: EndpointId) => string;
declare const formatOmniPoint: ({ eid, address, contractName }: OmniPoint) => string;
declare const formatOmniVector: ({ from, to }: OmniVector) => string;

/**
 * Schema for parsing strings, bigints and numbers to uint backed by bigint
 *
 * It does not use z.coerce in order to avoid errors coming from BigInt() constructor
 */
declare const UIntBigIntSchema: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, bigint, unknown>, z.ZodBigInt>;
declare const UIntNumberSchema: z.ZodPipeline<z.ZodEffects<z.ZodUnknown, number, unknown>, z.ZodNumber>;
declare const AddressSchema: z.ZodString;
declare const EndpointIdSchema: z.ZodSchema<EndpointId, z.ZodTypeDef, string | number>;
declare const OmniPointSchema: z.ZodSchema<OmniPoint, z.ZodTypeDef, unknown>;
declare const OmniVectorSchema: z.ZodSchema<OmniVector, z.ZodTypeDef, unknown>;
declare const EmptyOmniNodeSchema: z.ZodObject<{
    point: z.ZodType<OmniPoint, z.ZodTypeDef, unknown>;
    config: z.ZodOptional<z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    point: {
        address: OmniAddress;
        contractName?: string | null;
    } & {
        eid: EndpointId;
    };
    config?: unknown;
}, {
    point?: unknown;
    config?: unknown;
}>;
declare const EmptyOmniEdgeSchema: z.ZodObject<{
    vector: z.ZodType<OmniVector, z.ZodTypeDef, unknown>;
    config: z.ZodOptional<z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    vector: OmniVector;
    config?: unknown;
}, {
    vector?: unknown;
    config?: unknown;
}>;
/**
 * Helper assertion utility for `OmniPoint` instances
 *
 * @param {unknown} value
 * @returns {boolean} `true` if the value is an `OmniPoint`, `false` otherwise
 */
declare const isOmniPoint: (value: unknown) => value is OmniPoint;
/**
 * Helper assertion utility that checks whether an `OmniGraph`
 * has at least any contracts or connections defined
 *
 * @param {OmniGraph} graph
 * @returns {boolean}
 */
declare const isOmniGraphEmpty: ({ contracts, connections }: OmniGraph) => boolean;
/**
 * Factory for OmniNode schemas
 *
 * @param configSchema Schema of the config contained in the node
 *
 * @returns `z.ZodSchema<OmniNode<TConfig>>` schema for a node with the particular config type
 */
declare const createOmniNodeSchema: <TConfig = unknown>(configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>) => z.ZodSchema<OmniNode<TConfig>, z.ZodTypeDef, unknown>;
/**
 * Factory for OmniEdge schemas
 *
 * @param {z.ZodSchema<TConfig>} configSchema Schema of the config contained in the edge
 *
 * @returns {z.ZodSchema<OmniEdge<TConfig>>} Schema for an edge with the particular config type
 */
declare const createOmniEdgeSchema: <TConfig = unknown>(configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>) => z.ZodSchema<OmniEdge<TConfig>, z.ZodTypeDef, unknown>;
/**
 * Factory for OmniGraph schemas
 *
 * @param {z.ZodSchema<OmniNode<TNodeConfig>, z.ZodTypeDef, unknown>} nodeSchema
 * @param {z.ZodSchema<OmniEdge<TEdgeConfig>, z.ZodTypeDef, unknown>} edgeSchema
 *
 * @returns {z.ZodSchema<OmniGraph<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown>}
 */
declare const createOmniGraphSchema: <TNodeConfig = unknown, TEdgeConfig = unknown>(nodeSchema: z.ZodSchema<OmniNode<TNodeConfig>, z.ZodTypeDef, unknown>, edgeSchema: z.ZodSchema<OmniEdge<TEdgeConfig>, z.ZodTypeDef, unknown>) => z.ZodSchema<OmniGraph<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown>;

declare const formatOmniTransaction: (transaction: OmniTransaction) => Record<string, string | number | bigint | undefined>;

/**
 * Base class for all signers containing common functionality
 */
declare abstract class OmniSignerBase implements OmniSigner {
    /**
     * @deprecated Use `OmniSigner.getPoint()` instead
     */
    readonly eid: EndpointId;
    protected constructor(eid: EndpointId);
    abstract getPoint(): OmniPoint | Promise<OmniPoint>;
    abstract sign(transaction: OmniTransaction): Promise<string>;
    abstract signAndSend(transaction: OmniTransaction): Promise<OmniTransactionResponse>;
    /**
     * helper method to ensure that the transaction we are trying to sign is on a correct network
     *
     * @param {OmniTransaction} transaction
     */
    protected assertTransaction(transaction: OmniTransaction): void;
}
type SignAndSendResult = [
    successful: OmniTransactionWithReceipt[],
    errors: OmniTransactionWithError[],
    pending: OmniTransaction[]
];
type OnSignAndSendProgress = (result: OmniTransactionWithReceipt, results: OmniTransactionWithReceipt[]) => unknown;
type SignAndSend = (transactions: OmniTransaction[], onProgress?: OnSignAndSendProgress) => Promise<SignAndSendResult>;
/**
 * Creates a sign & send utility for a list of transaction
 * with a help of `OmniSignerFactory`
 *
 * @param {OmniSignerFactory} createSigner
 */
declare const createSignAndSend: (createSigner: OmniSignerFactory) => SignAndSend;

declare const flattenTransactions: (transations: (OmniTransaction | OmniTransaction[] | null | undefined)[]) => OmniTransaction[];
/**
 * Groups transactions by their `eid`, preserving the order per group
 *
 * @param {OmniTransaction[]} transactions
 * @returns {Map<EndpointId, OmniTransaction[]>}
 */
declare const groupTransactionsByEid: (transactions: OmniTransaction[]) => Map<EndpointId, OmniTransaction[]>;
declare const isFailedSignAndSendResult: ([, failed]: SignAndSendResult) => boolean;

interface CreateConfigExecuteFlowArgs<TOmniGraph extends OmniGraph = OmniGraph, TSDK = IOmniSDK> {
    configurator: Configurator<TOmniGraph, TSDK>;
    sdkFactory: OmniSDKFactory<TSDK>;
    logger?: Logger;
}
interface ConfigExecuteFlowArgs<TOmniGraph extends OmniGraph = OmniGraph> {
    graph: TOmniGraph;
}
type ConfigExecuteFlow<TOmniGraph extends OmniGraph = OmniGraph> = (args: ConfigExecuteFlowArgs<TOmniGraph>) => Promise<OmniTransaction[]>;
declare const createConfigExecuteFlow: <TOmniGraph extends OmniGraph = OmniGraph<unknown, unknown>, TSDK = IOmniSDK>({ logger, configurator, sdkFactory, }: CreateConfigExecuteFlowArgs<TOmniGraph, TSDK>) => ConfigExecuteFlow<TOmniGraph>;

interface CreateConfigLoadFlowArgs<TOmniGraph = OmniGraph> {
    configSchema: ZodType<TOmniGraph, ZodTypeDef, unknown>;
    logger?: Logger;
}
interface ConfigLoadFlowArgs {
    configPath: string;
}
type ConfigLoadFlow<TOmniGraph = OmniGraph> = (args: ConfigLoadFlowArgs) => Promise<TOmniGraph>;
/**
 * A flow that loads a configuration file from `configPath` and validates it against a `configSchema`.
 *
 * The schema is responsible for any transformations that need to be done to turn the raw config into an `OmniGraph`
 * (e.g. transforming from hardhat-specific format).
 *
 * The config file can be in one of the supoorted formats:
 *
 * - JS
 * - TS
 * - JSON
 *
 * For the JS and TS versions, the config file can either export the config object directly
 * or can export a function that returns the config object (or a promise of the config object)
 *
 * @template TOmniGraph
 * @param ConfigLoadFlowArgs
 * @returns {Promise<TOmniGraph>}
 */
declare const createConfigLoadFlow: <TOmniGraph = OmniGraph<unknown, unknown>>({ configSchema, logger, }: CreateConfigLoadFlowArgs<TOmniGraph>) => ConfigLoadFlow<TOmniGraph>;

interface SignAndSendFlowArgs {
    transactions: OmniTransaction[];
}
type SignAndSendFlow = (args: SignAndSendFlowArgs) => Promise<SignAndSendResult>;
interface CreateSignAndSendFlowArgs {
    ci?: boolean;
    logger?: Logger;
    createSigner: OmniSignerFactory;
}
/**
 * Sign and send flow is responsible for submitting (i.e. signing and sending)
 * a list of transactions using the signer factory.
 *
 * It is a high level function that can be used from any CLI implementation,
 * be it hardhat or a standalone script.
 *
 * @param {SignAndSendFlowArgs}
 * @returns {SignAndSendFlow}
 */
declare const createSignAndSendFlow: ({ ci, createSigner, logger }: CreateSignAndSendFlowArgs) => SignAndSendFlow;

interface CreateWireFlowArgs<TOmniGraph extends OmniGraph> {
    logger?: Logger;
    executeConfig: ConfigExecuteFlow<TOmniGraph>;
    signAndSend: SignAndSendFlow;
}
interface WireFlowArgs<TOmniGraph extends OmniGraph> {
    graph: TOmniGraph;
    assert?: boolean;
    dryRun?: boolean;
}
declare const createWireFlow: <TOmniGraph extends OmniGraph>({ logger, executeConfig, signAndSend, }: CreateWireFlowArgs<TOmniGraph>) => ({ graph, assert, dryRun }: WireFlowArgs<TOmniGraph>) => Promise<SignAndSendResult>;

export { AddressSchema, AsyncRetriable, type Bytes, type Bytes20, type Bytes32, type ComposeSpec, type ComposeSpecDependencyCondition, type ComposeSpecDependsOnDefinition, type ComposeSpecPort, type ComposeSpecPortDefinition, type ComposeSpecPortNumber, type ComposeSpecService, type ComposeSpecServiceBuild, type ComposeSpecServiceCommand, type ComposeSpecServiceDependsOn, type ComposeSpecServiceHealthcheck, type ComposeSpecServiceVolume, type ComposeSpecServiceVolumeDefinition, type ComposeSpecServices, type ComposeSpecVersion, type ComposeSpecVolume, type ComposeSpecVolumeDefinition, type ComposeSpecVolumes, type ConfigExecuteFlow, type ConfigExecuteFlowArgs, type ConfigLoadFlow, type ConfigLoadFlowArgs, type Configurator, type CreateConfigExecuteFlowArgs, type CreateConfigLoadFlowArgs, type CreateSignAndSendFlowArgs, type CreateTransactionsFromOmniEdges, type CreateTransactionsFromOmniNodes, type CreateWireFlowArgs, EmptyOmniEdgeSchema, EmptyOmniNodeSchema, type EndpointBasedFactory, EndpointIdSchema, type Factory, type IOmniSDK, type InferOmniEdge, type InferOmniNode, type ListOrDict, type OmniAddress, type OmniEdge, type OmniError, type OmniGraph, OmniGraphBuilder, type OmniNode, type OmniPoint, OmniPointMap, OmniPointSchema, type OmniSDKFactory, type OmniSigner, OmniSignerBase, type OmniSignerFactory, type OmniTransaction, type OmniTransactionMetadata, type OmniTransactionReceipt, type OmniTransactionResponse, type OmniTransactionWithError, type OmniTransactionWithReceipt, type OmniTransactionWithResponse, type OmniVector, OmniVectorMap, OmniVectorSchema, type OnRetry, type OnSignAndSendProgress, type PossiblyBigInt, type PossiblyBytes, type RetriableConfig, type RpcUrlFactory, type SignAndSend, type SignAndSendFlow, type SignAndSendFlowArgs, type SignAndSendResult, UIntBigIntSchema, UIntNumberSchema, type WireFlowArgs, type WithEid, type WithLooseBigInts, type WithOptionals, areBytes32Equal, arePointsEqual, areSameEndpoint, areVectorsEqual, compareBytes32Ascending, createConfigExecuteFlow, createConfigLoadFlow, createConfigureEdges, createConfigureMultiple, createConfigureNodes, createDefaultApplicative, createDefaultRetryHandler, createOmniEdgeSchema, createOmniGraphSchema, createOmniNodeSchema, createRetryFactory, createSignAndSend, createSignAndSendFlow, createSimpleRetryStrategy, createWireFlow, denormalizePeer, first, firstFactory, flattenTransactions, formatEid, formatOmniPoint, formatOmniTransaction, formatOmniVector, fromHex, groupTransactionsByEid, ignoreZero, isDeepEqual, isFailedSignAndSendResult, isOmniGraphEmpty, isOmniPoint, isVectorPossible, isZero, makeBytes32, mapError, normalizePeer, parallel, sequence, serializeDockerComposeSpec, serializePoint, serializeVector, splitCommaSeparated, tapError, toHex, vectorFromNodes, withEid };
