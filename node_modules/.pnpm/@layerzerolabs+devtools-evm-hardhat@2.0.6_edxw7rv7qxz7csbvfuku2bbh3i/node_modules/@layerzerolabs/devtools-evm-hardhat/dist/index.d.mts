import { A as ArtifactPackage, S as SimulationConfig, a as SimulationUserConfig } from './type-extensions-tCX7T1q0.mjs';
export { b as SimulationAnvilConfig, c as SimulationAnvilUserConfig } from './type-extensions-tCX7T1q0.mjs';
import * as hardhat_types from 'hardhat/types';
import { Artifact, CLIArgumentType, HardhatUserConfig, HardhatRuntimeEnvironment, HardhatArguments, EthereumProvider, ConfigurableTaskDefinition, HardhatConfig, NetworkConfig } from 'hardhat/types';
import * as _layerzerolabs_devtools_evm from '@layerzerolabs/devtools-evm';
import { SignerDefinition, OmniContractFactory, ProviderFactory, OmniContract, AnvilOptions, OmniSignerEVM, GnosisOmniSignerEVM } from '@layerzerolabs/devtools-evm';
import { LogLevel } from '@layerzerolabs/io-devtools';
import { EndpointId, Environment, Stage } from '@layerzerolabs/lz-definitions';
import { DeploymentsExtension, Deployment } from 'hardhat-deploy/dist/types';
import * as _layerzerolabs_devtools from '@layerzerolabs/devtools';
import { WithEid, WithOptionals, OmniPoint, OmniGraph, Factory, OmniGraphBuilder, OmniNode, OmniEdge, EndpointBasedFactory, ComposeSpecService, ComposeSpecServices, ComposeSpec, OmniTransaction, OmniSignerFactory } from '@layerzerolabs/devtools';
import { z } from 'zod';
import * as _ethersproject_providers from '@ethersproject/providers';
import { JsonRpcProvider } from '@ethersproject/providers';
import * as micro_memoize from 'micro-memoize';
import { HardhatContext } from 'hardhat/internal/context';
import { ConnectSafeConfigWithSafeAddress } from '@safe-global/protocol-kit';

/**
 * Will return all artifacts available in the project, including the external ones
 *
 * @return {Promise<Artifact[]>}
 */
declare const getAllArtifacts: (hre?: any) => Promise<Artifact[]>;
declare const isErrorFragment: <TFragment extends {
    type?: string;
}>(fragment: TFragment) => fragment is TFragment & {
    type: "error";
};

/**
 * Hardhat CLI type for a function argument.
 *
 * This is only to be used with subtasks since you cannot pass functions
 * to tasks (unless you're insane and want to inline a function)
 */
declare const fn: CLIArgumentType<string>;
/**
 * Signer-specific CLI argument (either a non-negative index
 * or a signer EVM address)
 */
declare const signer: CLIArgumentType<SignerDefinition>;
declare const types: {
    string: CLIArgumentType<string>;
    boolean: CLIArgumentType<boolean>;
    int: CLIArgumentType<number>;
    bigint: CLIArgumentType<bigint>;
    float: CLIArgumentType<number>;
    inputFile: CLIArgumentType<string>;
    json: CLIArgumentType<any>;
    any: hardhat_types.ArgumentType<any>;
    csv: CLIArgumentType<string[]>;
    eid: CLIArgumentType<EndpointId>;
    logLevel: CLIArgumentType<LogLevel>;
    fn: CLIArgumentType<string>;
    signer: CLIArgumentType<SignerDefinition>;
    environment: CLIArgumentType<Environment>;
    stage: CLIArgumentType<Stage>;
};

/**
 * Helper utility that adds external deployment paths for all LayzerZero enabled networks.
 * This will make LayerZero contracts available in your deploy scripts and tasks.
 *
 * ```
 * // hardhat.config.ts
 * import { EndpointId } from "@layerzerolabs/lz-definitions"
 *
 * const config: HardhatUserConfig = {
 *   networks: {
 *     arbitrum: {
 *       eid: EndpointId.ARBITRUM_MAINNET
 *     },
 *     fuji: {
 *       eid: EndpointId.AVALANCHE_TESTNET
 *     }
 *   }
 * }
 *
 * export default withLayerZeroDeployments("@layerzerolabs/lz-evm-sdk-v1")
 * ```
 *
 * @param packageNames `string[]` List of @layerzerolabs package names that contain deployments directory
 *
 * @returns `<THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig): THardhatUserConfig` Hardhat config decorator
 */
declare const withLayerZeroDeployments: (...packageNames: string[]) => <THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig) => THardhatUserConfig;
/**
 * Helper utility that appends external artifacts directories
 * to existing hadrhat config
 *
 * ```
 * // hardhat.config.ts
 * import { EndpointId } from "@layerzerolabs/lz-definitions"
 *
 * const config: HardhatUserConfig = {
 *   networks: {
 *     arbitrum: {
 *       eid: EndpointId.ARBITRUM_MAINNET
 *     },
 *     fuji: {
 *       eid: EndpointId.AVALANCHE_TESTNET
 *     }
 *   }
 * }
 *
 * export default withLayerZeroArtifacts("@layerzerolabs/lz-evm-sdk-v1")
 * ```
 *
 * @param packageNames `string[]`
 *
 * @returns `<THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig): THardhatUserConfig` Hardhat config decorator
 */
declare const withLayerZeroArtifacts: (...artifactPackages: ArtifactPackage[]) => <THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig) => THardhatUserConfig;

declare const TASK_LZ_DEPLOY = "lz:deploy";
declare const TASK_LZ_EXPORT_DEPLOYMENTS_TYPESCRIPT = "lz:export:deployments:typescript";
declare const SUBTASK_LZ_SIGN_AND_SEND = "::lz:sign-and-send";
declare const TASK_LZ_TEST_SIMULATION_START = "lz:test:simulation:start";
declare const TASK_LZ_TEST_SIMULATION_LOGS = "lz:test:simulation:logs";
declare const TASK_LZ_TEST_SIMULATION_STOP = "lz:test:simulation:stop";
declare const TASK_LZ_VALIDATE_SAFE_CONFIGS = "lz:healthcheck:validate:safe-configs";
declare const TASK_LZ_VALIDATE_RPCS = "lz:healthcheck:validate:rpcs";

declare class ConfigurationError extends Error {
}

/**
 * Creates a generic error parser based on all the artifacts found in your hardhat project
 */
declare const createErrorParser: () => Promise<(error: unknown) => _layerzerolabs_devtools_evm.ContractError<unknown> | Promise<_layerzerolabs_devtools_evm.ContractError<unknown>>>;

interface HardhatRuntimeEnvironmentWithDeployments extends HardhatRuntimeEnvironment {
    deployments: DeploymentsExtension;
}
/**
 * Helper utility to make sure hardhat-deploy is being used by the project
 *
 * @param {HardhatRuntimeEnvironment} hre
 */
declare function assertHardhatDeploy(hre: HardhatRuntimeEnvironment): asserts hre is HardhatRuntimeEnvironmentWithDeployments;
/**
 * Helper utility to make sure that all the networks passed
 * to this function have been defined in the config
 *
 * @param {Iterable<string>} networkNames
 * @param {HardhatRuntimeEnvironment} hre
 */
declare function assertDefinedNetworks<TNetworkNames extends Iterable<string>>(networkNames: TNetworkNames, hre?: HardhatRuntimeEnvironment): TNetworkNames;

/**
 * Omniverse wrapper around a hardhat-deploy deployment
 */
type OmniDeployment = WithEid<{
    deployment: Deployment;
}>;
/**
 * Hardhat-specific variation of an `OmniPoint`
 *
 * Since in hardhat we have access to artifacts/deployments,
 * we can use contract name to find an address or ABIs of a particular contract
 * and transform `OmniPointHardhat` to `OmniPoint`
 */
type OmniPointHardhat = WithEid<{
    contractName?: string | null;
    address?: string | null;
}>;
type WithContractName<T> = T & {
    contractName: string;
};
/**
 * Hardhat-specific variation of `OmniNode` that uses `OmniPointHardhat`
 * instead of `OmniPoint` to specify the contract coordinates
 */
type OmniNodeHardhat<TNodeConfig> = WithOptionals<{
    contract: OmniPointHardhat | OmniPoint;
    config: TNodeConfig;
}>;
/**
 * Hardhat-specific variation of `OmniEdge` that uses `OmniPointHardhat`
 * instead of `OmniPoint` to specify the contracts' coordinates
 */
type OmniEdgeHardhat<TEdgeConfig> = WithOptionals<{
    from: OmniPointHardhat | OmniPoint;
    to: OmniPointHardhat | OmniPoint;
    config: TEdgeConfig;
}>;
/**
 * Hardhat-specific variation of `OmniGraph` that uses `OmniNodeHardhat`
 * and `OmniEdgeHardhat` to specify the contracts and connections
 */
interface OmniGraphHardhat<TNodeConfig = unknown, TEdgeConfig = unknown> {
    contracts: OmniNodeHardhat<TNodeConfig>[];
    connections: OmniEdgeHardhat<TEdgeConfig>[];
}
/**
 * Helper type to convert OmniGraphHardhat to OmniGraph
 *
 * ```
 * type MyOmniGraphHardhat = OmniGraphHardhat<MyNodeConfig, MyEdgeConfig>
 * type MyOmniGraph = InferOmniGraph<MyOmniGraphHardhat>
 * ```
 */
type InferOmniGraph<TOmniGraphHardhat extends OmniGraphHardhat> = TOmniGraphHardhat extends OmniGraphHardhat<infer TNodeConfig, infer TEdgeConfig> ? OmniGraph<TNodeConfig, TEdgeConfig> : never;
type OmniContractFactoryHardhat = OmniContractFactory<OmniPointHardhat>;
type OmniPointHardhatTransformer = Factory<[OmniPointHardhat | OmniPoint], OmniPoint>;
type OmniGraphHardhatTransformer<TNodeConfig = unknown, TEdgeConfig = unknown> = Factory<[
    OmniGraphHardhat<TNodeConfig, TEdgeConfig>
], OmniGraph<TNodeConfig, TEdgeConfig>>;

/**
 * OmniGraphBuilderHardhat houses all hardhat-specific utilities for building OmniGraphs
 *
 * It is not an instantiable class - it only provides static utilities for working with OmniGraph
 *
 * @deprecated Transform the graph using the transformation function from `createOmniGraphHardhatTransformer()` directly:
 *
 * ```
 * const hardhatGraph: OmniGraphHardhat<TNodeConfig, TEdgeConfig>
 * const transformer = createOmniGraphHardhatTransformer()
 * const graph = await transformer(hardhatGraph)
 * ```
 */
declare class OmniGraphBuilderHardhat {
    static fromConfig<TNodeConfig, TEdgeConfig>(graph: OmniGraphHardhat<TNodeConfig, TEdgeConfig>, transform?: OmniGraphHardhatTransformer<TNodeConfig, TEdgeConfig>): Promise<OmniGraphBuilder<TNodeConfig, TEdgeConfig>>;
    constructor();
}

declare const createConnectedContractFactory: (contractFactory?: OmniContractFactoryHardhat, providerFactory?: ProviderFactory) => OmniContractFactoryHardhat;

declare const omniDeploymentToPoint: ({ eid, deployment }: OmniDeployment) => OmniPoint;
declare const omniDeploymentToContract: ({ eid, deployment }: OmniDeployment) => OmniContract;
declare const createContractFactory: (environmentFactory?: _layerzerolabs_devtools.EndpointBasedFactory<hardhat_types.HardhatRuntimeEnvironment>) => OmniContractFactoryHardhat;

declare const OmniPointHardhatSchema: z.ZodSchema<OmniPointHardhat, z.ZodTypeDef, unknown>;
/**
 * Factory for OmniNodeHardhat schemas
 *
 * @param configSchema Schema of the config contained in the node
 *
 * @returns {z.ZodSchema<OmniNodeHardhat<TConfig>>} schema for a node with the particular config type
 */
declare const createOmniNodeHardhatSchema: <TConfig = unknown>(configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>) => z.ZodSchema<OmniNodeHardhat<TConfig>, z.ZodTypeDef, unknown>;
/**
 * Factory for OmniEdgeHardhat schemas
 *
 * @param {z.ZodSchema<TConfig>} configSchema Schema of the config contained in the edge
 *
 * @returns {z.ZodSchema<OmniEdgeHardhat<TConfig>>} Schema for an edge with the particular config type
 */
declare const createOmniEdgeHardhatSchema: <TConfig = unknown>(configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>) => z.ZodSchema<OmniEdgeHardhat<TConfig>, z.ZodTypeDef, unknown>;
/**
 * Factory for OmniGraphHardhat schemas
 *
 * @param {z.ZodSchema<OmniNodeHardhat<TNodeConfig>>} nodeSchema
 * @param {z.ZodSchema<OmniEdgeHardhat<TEdgeConfig>>} edgeSchema
 *
 * @returns {z.ZodSchema<OmniGraphHardhat<TNodeConfig, TEdgeConfig>>}
 */
declare const createOmniGraphHardhatSchema: <TNodeConfig = unknown, TEdgeConfig = unknown>(nodeSchema: z.ZodSchema<OmniNodeHardhat<TNodeConfig>, z.ZodTypeDef, unknown>, edgeSchema: z.ZodSchema<OmniEdgeHardhat<TEdgeConfig>, z.ZodTypeDef, unknown>) => z.ZodSchema<OmniGraphHardhat<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown>;
declare const hasContractName: <T extends object>(value: T) => value is WithContractName<T>;

/**
 * Create a function capable of transforming `OmniPointHardhat` to a regular `OmniPoint`
 * with some help from an `OmniContractFactoryHardhat`
 *
 * @param {OmniContractFactoryHardhat} contractFactory
 * @returns {OmniPointHardhatTransformer}
 */
declare const createOmniPointHardhatTransformer: (contractFactory?: OmniContractFactoryHardhat) => OmniPointHardhatTransformer;
/**
 * Create a function capable of transforming `OmniNodeHardhat` to a regular `OmniNode`
 * with some help from an `OmniPointHardhatTransformer`
 *
 * @param {OmniPointHardhatTransformer} [pointTransformer]
 * @returns
 */
declare const createOmniNodeHardhatTransformer: (pointTransformer?: OmniPointHardhatTransformer) => <TNodeConfig>({ contract, config }: OmniNodeHardhat<TNodeConfig>) => Promise<OmniNode<TNodeConfig>>;
/**
 * Create a function capable of transforming `OmniEdgeHardhat` to a regular `OmniEdge`
 * with some help from an `OmniPointHardhatTransformer`
 *
 * @param {OmniPointHardhatTransformer} [pointTransformer]
 * @returns
 */
declare const createOmniEdgeHardhatTransformer: (pointTransformer?: OmniPointHardhatTransformer) => <TEdgeConfig>({ from, to, config }: OmniEdgeHardhat<TEdgeConfig>) => Promise<OmniEdge<TEdgeConfig>>;
declare const createOmniGraphHardhatTransformer: <TNodeConfig, TEdgeConfig>(nodeTransformer?: <TNodeConfig_1>({ contract, config }: OmniNodeHardhat<TNodeConfig_1>) => Promise<OmniNode<TNodeConfig_1>>, edgeTransformer?: <TEdgeConfig_1>({ from, to, config }: OmniEdgeHardhat<TEdgeConfig_1>) => Promise<OmniEdge<TEdgeConfig_1>>, applicative?: <T>(tasks: (() => T | Promise<T>)[]) => Promise<T[]>) => OmniGraphHardhatTransformer<TNodeConfig, TEdgeConfig>;

declare const createProviderFactory: (networkEnvironmentFactory?: _layerzerolabs_devtools.EndpointBasedFactory<hardhat_types.HardhatRuntimeEnvironment>) => ProviderFactory<JsonRpcProvider>;

/**
 * Helper type for when we need to grab something asynchronously by the network name
 */
type GetByNetwork<TValue> = Factory<[networkName: string], TValue>;
/**
 * Helper type for when we need to grab something asynchronously by the network name
 */
type GetByEid<TValue> = Factory<[eid: EndpointId], TValue>;
/**
 * Creates and sets the default hardhat context.
 *
 * This function will fail if a context has already been created
 */
declare const createDefaultContext: (hardhatArguments?: Partial<HardhatArguments>) => void;
/**
 * Returns the default hardhat context for the project, i.e.
 * the context that the project has been setup with.
 *
 * Throws if there is no context.
 *
 * @returns {HardhatContext}
 */
declare const getDefaultContext: () => HardhatContext;
/**
 * Returns the default `HardhatRuntimeEnvironment` (`hre`) for the project.
 *
 * Throws if there is no `HardhatRuntimeEnvironment`.
 *
 * @returns {HardhatRuntimeEnvironment}
 */
declare const getDefaultRuntimeEnvironment: () => HardhatRuntimeEnvironment;
/**
 * Creates a clone of the HardhatRuntimeEnvironment for a particular network
 *
 * ```typescript
 * const env = getHreByNetworkName("bsc-testnet");
 *
 * // All the ususal properties are present
 * env.deployments.get("MyContract")
 * ```
 *
 * @returns {Promise<HardhatRuntimeEnvironment>}
 */
declare const getHreByNetworkName: GetByNetwork<HardhatRuntimeEnvironment>;
/**
 * Creates a clone of the HardhatRuntimeEnvironment for a particular network
 * identified by endpoint ID
 *
 * ```typescript
 * const getHreByEid = createGetHreByEid()
 * const env = await getHreByEid(EndpointId.AVALANCHE_V2_TESTNET);
 *
 * // All the ususal properties are present
 * env.deployments.get("MyContract")
 * ```
 *
 * @returns {Promise<HardhatRuntimeEnvironment>}
 */
declare const createGetHreByEid: (hre?: HardhatRuntimeEnvironment) => EndpointBasedFactory<HardhatRuntimeEnvironment>;
/**
 * Helper function that wraps an EthereumProvider with EthersProviderWrapper
 * so that we can use it further with ethers as a regular JsonRpcProvider
 *
 * @param {EIP1193Provider} provider
 * @returns {JsonRpcProvider}
 */
declare const wrapEIP1193Provider: (provider: EthereumProvider) => JsonRpcProvider;
/**
 * Gets an EndpointId defined in the hardhat config
 * for a particular network name (as an `eid` property).
 *
 * Throws if the network or the eid are not defined
 *
 * @param {string} networkName
 * @param {HardhatRuntimeEnvironment | undefined} [hre]
 * @returns {EndpointId}
 */
declare const getEidForNetworkName: (networkName: string, hre?: HardhatRuntimeEnvironment) => EndpointId;
/**
 * Gets a network name with its `eid` property matching
 * a particular `eid`
 *
 * Throws if there are multiple networks defined with the same `eid`.
 *
 * Returns `undefined` if there is no network with given `eid`
 *
 * @param {EndpointId} eid
 * @param {HardhatRuntimeEnvironment | undefined} [hre]
 * @returns {string | undefined}
 */
declare const getNetworkNameForEidMaybe: (eid: EndpointId, hre?: HardhatRuntimeEnvironment) => string | undefined;
/**
 * Gets a network name with its `eid` property matching
 * a particular `eid`
 *
 * Throws if there is no such network or if there are multiple
 * networks defined with the same `eid`
 *
 * @param {EndpointId} eid
 * @param {HardhatRuntimeEnvironment | undefined} [hre]
 * @returns {string}
 */
declare const getNetworkNameForEid: (eid: EndpointId, hre?: HardhatRuntimeEnvironment) => string;
/**
 * Gets a record containing the mapping between network names and endpoint IDs.
 * Will also return the network names for which the `eid` has not been defined
 *
 * Throws if there are multiple networks defined with the same `eid`
 *
 * @param {HardhatRuntimeEnvironment | undefined} [hre]
 * @returns {Record<string, EndpointId | undefined>}
 */
declare const getEidsByNetworkName: micro_memoize.Memoized<(hre?: HardhatRuntimeEnvironment) => Record<string, EndpointId | undefined>>;
/**
 * Helper utility that copies the whole task definition under a new name
 *
 * This is useful if a new task needs to have the same interface as an existing task,
 * for example if we want to create a slightly modified version of a wire task
 * without needing to retype all the `.addFlag` and `.addOption`
 *
 * @param {string} parentTaskName Task to inherit the options and the action from
 * @param {HardhatRuntimeEnvironment} [hre]
 * @returns {(taskName: string) => ConfigurableTaskDefinition}
 */
declare const inheritTask: (parentTaskName: string, context?: HardhatContext) => (taskName: string) => ConfigurableTaskDefinition;

/**
 * Creates a docker compose service specification for an anvil-based EVM node
 *
 * @param {AnvilOptions} anvilOptions
 * @returns {ComposeSpecService}
 */
declare const createEvmNodeServiceSpec: (anvilOptions: AnvilOptions) => ComposeSpecService;
/**
 * Creates a docker compose service specification for an nginx-based proxy service
 * that proxies requests to underlying EVM nodes (or their RPC URLs to be mor precise)
 *
 * @param {number} port
 * @param {ComposeSpecServices} networkServices
 * @returns {ComposeSpecService}
 */
declare const createEvmNodeProxyServiceSpec: (port: number, networkServices: ComposeSpecServices) => ComposeSpecService;
/**
 * Creates a docker compose spec with a set of anvil-based EVM nodes
 * and a single proxy server that proxies requests to these nodes.
 *
 * @param {SimulationConfig} config
 * @param {Record<string, AnvilOptions>} networks
 * @returns {ComposeSpec}
 */
declare const createSimulationComposeSpec: (config: SimulationConfig, networks: Record<string, AnvilOptions>) => ComposeSpec;

/**
 * Turns `SimulationUserConfig` into `SimulationConfig` by supplying defaults
 *
 * @param {SimulationUserConfig} userConfig
 * @param {HardhatConfig} hardhatConfig
 * @returns {SimulationConfig}
 */
declare const resolveSimulationConfig: (userConfig: SimulationUserConfig, hardhatConfig: HardhatConfig) => SimulationConfig;
/**
 * Takes a portion of the hardhat networks config and turns the values into `AnvilOptions`
 * to be used by a simulation network container.
 *
 * This is used in the simulation generation phase where the compose files
 * for networks defined in hardhat config are being generated.
 *
 * The `Record<string, NetworkConfig>` is used instead of `NetworksConfig` type from hardhat
 * to avoid any type issues with special keys like `localhost` or `hardhat`.
 *
 * @param {SimulationConfig} config
 * @param {Record<string, NetworkConfig>} networksConfig
 * @returns {Record<string, AnvilOptions>} Object with the same keys as the networks config, with values mapped to `AnvilOptions`
 */
declare const getAnvilOptionsFromHardhatNetworks: (config: SimulationConfig, networksConfig: Record<string, NetworkConfig>) => Record<string, AnvilOptions>;
/**
 * Returns with overrides for hardhat network configuration.
 *
 * This, when merged with a hardhat config, will redirect the network calls to the local EVM nodes.
 *
 * @param {SimulationConfig} config
 * @param {Record<string, NetworkConfig>} networksConfig
 * @returns {Record<string, NetworkConfig>}
 */
declare const getHardhatNetworkOverrides: (config: SimulationConfig, networksConfig: Record<string, NetworkConfig>) => Record<string, NetworkConfig>;
/**
 * Helper utility to pick network configs by their names / object keys.
 *
 * Similar to TypeScript `Pick` helper type, but in runtime.
 *
 * @param {string[]} networks List of networks to pick
 */
declare const pickNetworkConfigs: (networks: string[]) => <B extends NetworkConfig>(fb: Record<string, B>) => Record<string, B>;

declare const formatOmniTransaction: (transaction: OmniTransaction) => Record<string, string | number | bigint | undefined>;

declare const createSignerFactory: (definition?: SignerDefinition, networkEnvironmentFactory?: EndpointBasedFactory<hardhat_types.HardhatRuntimeEnvironment>, providerFactory?: _layerzerolabs_devtools_evm.ProviderFactory<_ethersproject_providers.JsonRpcProvider>, signerAddressorIndexFactory?: EndpointBasedFactory<string | number | undefined>) => OmniSignerFactory<OmniSignerEVM>;
declare const createGnosisSignerFactory: (definition?: SignerDefinition, networkEnvironmentFactory?: EndpointBasedFactory<hardhat_types.HardhatRuntimeEnvironment>, providerFactory?: _layerzerolabs_devtools_evm.ProviderFactory<_ethersproject_providers.JsonRpcProvider>, signerAddressorIndexFactory?: EndpointBasedFactory<string | number | undefined>) => OmniSignerFactory<GnosisOmniSignerEVM<ConnectSafeConfigWithSafeAddress>>;
/**
 * Factory for signer address/index for a specific eid.
 *
 * Will take an optional signer definition and either:
 *
 * - Return static signer address or index for static signer configuration
 * - Look up named signer account in hardhat config and return its address
 *
 * @param {SignerDefinition} [definition]
 * @param {EndpointBasedFactory<HardhatRuntimeEnvironment>} [networkEnvironmentFactory]
 * @returns
 */
declare const createSignerAddressOrIndexFactory: (definition?: SignerDefinition, networkEnvironmentFactory?: EndpointBasedFactory<hardhat_types.HardhatRuntimeEnvironment>) => EndpointBasedFactory<string | number | undefined>;

export { ConfigurationError, type GetByEid, type GetByNetwork, type HardhatRuntimeEnvironmentWithDeployments, type InferOmniGraph, type OmniContractFactoryHardhat, type OmniDeployment, type OmniEdgeHardhat, OmniGraphBuilderHardhat, type OmniGraphHardhat, type OmniGraphHardhatTransformer, type OmniNodeHardhat, type OmniPointHardhat, OmniPointHardhatSchema, type OmniPointHardhatTransformer, SUBTASK_LZ_SIGN_AND_SEND, SimulationConfig, SimulationUserConfig, TASK_LZ_DEPLOY, TASK_LZ_EXPORT_DEPLOYMENTS_TYPESCRIPT, TASK_LZ_TEST_SIMULATION_LOGS, TASK_LZ_TEST_SIMULATION_START, TASK_LZ_TEST_SIMULATION_STOP, TASK_LZ_VALIDATE_RPCS, TASK_LZ_VALIDATE_SAFE_CONFIGS, type WithContractName, assertDefinedNetworks, assertHardhatDeploy, createConnectedContractFactory, createContractFactory, createDefaultContext, createErrorParser, createEvmNodeProxyServiceSpec, createEvmNodeServiceSpec, createGetHreByEid, createGnosisSignerFactory, createOmniEdgeHardhatSchema, createOmniEdgeHardhatTransformer, createOmniGraphHardhatSchema, createOmniGraphHardhatTransformer, createOmniNodeHardhatSchema, createOmniNodeHardhatTransformer, createOmniPointHardhatTransformer, createProviderFactory, createSignerAddressOrIndexFactory, createSignerFactory, createSimulationComposeSpec, fn, formatOmniTransaction, getAllArtifacts, getAnvilOptionsFromHardhatNetworks, getDefaultContext, getDefaultRuntimeEnvironment, getEidForNetworkName, getEidsByNetworkName, getHardhatNetworkOverrides, getHreByNetworkName, getNetworkNameForEid, getNetworkNameForEidMaybe, hasContractName, inheritTask, isErrorFragment, omniDeploymentToContract, omniDeploymentToPoint, pickNetworkConfigs, resolveSimulationConfig, signer, types, withLayerZeroArtifacts, withLayerZeroDeployments, wrapEIP1193Provider };
