{"version":3,"sources":["../src/type-extensions.ts","../src/runtime.ts","../src/errors/errors.ts","../src/errors/parser.ts","../src/artifacts.ts","../src/cli.ts","../src/config.ts","../src/constants/tasks.ts","../src/internal/assertions.ts","../src/omnigraph/builder.ts","../src/omnigraph/transformations.ts","../src/omnigraph/coordinates.ts","../src/omnigraph/contracts.ts","../src/provider.ts","../src/omnigraph/schema.ts","../src/simulation/compose.ts","../src/simulation/config.ts","../src/transactions/format.ts","../src/transactions/signer.ts"],"names":["pMemoize","abi","environment","eid","_a","assert","formatEid","Contract","createModuleLogger","deployments","pipe","signer"],"mappings":"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","sourcesContent":["import 'hardhat/types/config'\nimport { EndpointId } from '@layerzerolabs/lz-definitions'\nimport { ConnectSafeConfigWithSafeAddress } from '@safe-global/protocol-kit'\nimport { SimulationUserConfig } from '@/simulation/types'\n\n/**\n * Packages containing external artifacts can be specified either\n *\n * - By just their package name, in which case the artifacts will be loaded from the `./artifacts` path\n * - By their package name and a specific path to the artifacts directory\n * - By a filesystem path\n */\nexport type ArtifactPackage = ArtifactPackageName | ArtifactPackageWithPath | ArtifactPackagePath\n\nexport type ArtifactPackageName = string\n\nexport interface ArtifactPackageWithPath {\n    name: ArtifactPackageName\n    path?: string\n}\n\nexport interface ArtifactPackagePath {\n    name?: never\n    path: string\n}\n\ndeclare module 'hardhat/types/config' {\n    interface HardhatNetworkUserConfig {\n        eid?: never\n        safeConfig?: never\n    }\n\n    interface HardhatNetworkConfig {\n        eid?: never\n        safeConfig?: never\n    }\n\n    interface HttpNetworkUserConfig {\n        /**\n         * Specifies the mapping between the network\n         * defined in your hardhat config and the LayerZero endpoint ID\n         * on this network.\n         *\n         * This allows you to use arbitrary network names while maintaining\n         * allowing you to easily find deployment and artifact information\n         * for LayerZero protocol contracts using the standard hardhat deploy methods\n         */\n        eid?: EndpointId\n\n        /**\n         * Use a \"local\" LayerZero environment for the network.\n         *\n         * Local environments are postfixed with `-local` in the deployment directories\n         * and represent contracts deployed to ephemerous development networks.\n         *\n         * Local environments cannot coexists with their non-local counterparts\n         * in hardhat configs since they share the same `eid`\n         */\n        isLocalEid?: boolean\n\n        /**\n         * Optional gnosis safe config.\n         */\n        safeConfig?: SafeConfig\n    }\n\n    interface HttpNetworkConfig {\n        /**\n         * Specifies the mapping between the network\n         * defined in your hardhat config and the LayerZero endpoint ID\n         * on this network.\n         *\n         * This allows you to use arbitrary network names while maintaining\n         * allowing you to easily find deployment and artifact information\n         * for LayerZero protocol contracts using the standard hardhat deploy methods\n         */\n        eid?: EndpointId\n\n        /**\n         * Use a \"local\" LayerZero environment for the network.\n         *\n         * Local environments are postfixed with `-local` in the deployment directories\n         * and represent contracts deployed to ephemerous development networks\n         *\n         * Local environments cannot coexists with their non-local counterparts\n         * in hardhat configs since they share the same `eid`\n         */\n        isLocalEid?: boolean\n\n        /**\n         * Optional gnosis safe config.\n         */\n        safeConfig?: SafeConfig\n    }\n    interface SafeConfig extends ConnectSafeConfigWithSafeAddress {\n        safeUrl: string // Note:  This is the URL of the Safe API, not the safe itself\n        safeAddress: string // override to make ConnectSafeConfig.safeAddress mandatory\n    }\n\n    interface HardhatUserConfig {\n        /**\n         * LayerZero advanced configuration\n         */\n        layerZero?: LayerZeroHardhatUserConfig\n    }\n\n    interface LayerZeroHardhatUserConfig {\n        /**\n         * Defines the names of @layerzerolabs packages\n         * that will be added to your hardhat config under external deployments.\n         *\n         * By default, the protocol deployments from `@layerzerolabs/lz-evm-sdk-v2`\n         * will be added which allows your scripts to reference deployments\n         * of protocol contracts such as `EndpointV2`:\n         *\n         * ```\n         * // In your deploy script or task\n         * const { address, abi } = hre.deployments.get('EndpointV2')\n         * ```\n         *\n         * @default ['@layerzerolabs/lz-evm-sdk-v2']\n         */\n        deploymentSourcePackages?: string[]\n\n        /**\n         * Defines the names of @layerzerolabs packages\n         * that will be added to your hardhat config under external artifacts.\n         *\n         * By default, the protocol artifacts from `@layerzerolabs/lz-evm-sdk-v2`\n         * will be added which allows your scripts to reference artifacts\n         * of protocol contracts such as `EndpointV2`:\n         *\n         * ```\n         * // In your deploy script or task\n         * const { address, abi } = hre.deployments.get('EndpointV2')\n         * ```\n         *\n         * For testing purposes, artifacts from `@layerzerolabs/test-devtools-evm-hardhat`\n         * will also be added. This allows your tests to reference contracts such as `EndpointV2Mock`:\n         *\n         * ```\n         * // In your hardhat test\n         * const EndpointV2MockArtifact = await hre.deployments.getArtifact('EndpointV2Mock')\n         * ```\n         *\n         * @default ['@layerzerolabs/lz-evm-sdk-v2','@layerzerolabs/test-devtools-evm-hardhat']\n         */\n        artifactSourcePackages?: ArtifactPackage[]\n\n        /**\n         * Configuration of features that are not considered stable yet\n         */\n        experimental?: {\n            /**\n             * Configuration for omnichain simulation\n             *\n             * Omnichain simulation allows developers to easily setup\n             * local environment forked from live networks without\n             * having to adjust the `hardhat.config.ts` file\n             */\n            simulation?: SimulationUserConfig\n        }\n    }\n}\n","import type {\n    HardhatRuntimeEnvironment,\n    EthereumProvider,\n    ConfigurableTaskDefinition,\n    HardhatArguments,\n} from 'hardhat/types'\n\nimport pMemoize from 'p-memoize'\nimport type { JsonRpcProvider } from '@ethersproject/providers'\nimport { ConfigurationError } from './errors'\nimport { HardhatContext } from 'hardhat/internal/context'\nimport { loadConfigAndTasks } from 'hardhat/internal/core/config/config-loading'\nimport { Environment as HardhatRuntimeEnvironmentImplementation } from 'hardhat/internal/core/runtime-environment'\nimport { EndpointId } from '@layerzerolabs/lz-definitions'\nimport { EndpointBasedFactory, Factory, formatEid } from '@layerzerolabs/devtools'\nimport { EthersProviderWrapper } from '@nomiclabs/hardhat-ethers/internal/ethers-provider-wrapper'\nimport assert from 'assert'\nimport memoize from 'micro-memoize'\nimport { subtask, task } from 'hardhat/config'\n\n/**\n * Helper type for when we need to grab something asynchronously by the network name\n */\nexport type GetByNetwork<TValue> = Factory<[networkName: string], TValue>\n\n/**\n * Helper type for when we need to grab something asynchronously by the network name\n */\nexport type GetByEid<TValue> = Factory<[eid: EndpointId], TValue>\n\n/**\n * Creates and sets the default hardhat context.\n *\n * This function will fail if a context has already been created\n */\nexport const createDefaultContext = (hardhatArguments: Partial<HardhatArguments> = {}) => {\n    const ctx = HardhatContext.createHardhatContext()\n    const resolvedArguments: HardhatArguments = {\n        showStackTraces: false,\n        version: false,\n        help: false,\n        emoji: false,\n        verbose: false,\n        ...hardhatArguments,\n    }\n    const { resolvedConfig, userConfig } = loadConfigAndTasks(resolvedArguments)\n    const envExtenders = ctx.environmentExtenders\n    const providerExtenders = ctx.providerExtenders\n    const taskDefinitions = ctx.tasksDSL.getTaskDefinitions()\n    const scopesDefinitions = ctx.tasksDSL.getScopesDefinitions()\n    const env = new HardhatRuntimeEnvironmentImplementation(\n        resolvedConfig,\n        resolvedArguments,\n        taskDefinitions,\n        scopesDefinitions,\n        envExtenders,\n        userConfig,\n        providerExtenders\n    )\n\n    ctx.setHardhatRuntimeEnvironment(env as unknown as HardhatRuntimeEnvironment)\n}\n\n/**\n * Returns the default hardhat context for the project, i.e.\n * the context that the project has been setup with.\n *\n * Throws if there is no context.\n *\n * @returns {HardhatContext}\n */\nexport const getDefaultContext = (): HardhatContext => {\n    // Context is registered globally as a singleton and can be accessed\n    // using the static methods of the HardhatContext class\n    //\n    // In our case we require the context to exist, the other option would be\n    // to create it and set it up - see packages/hardhat-core/src/register.ts for an example setup\n    try {\n        return HardhatContext.getHardhatContext()\n    } catch (error: unknown) {\n        throw new ConfigurationError(`Could not get Hardhat context: ${error}`)\n    }\n}\n\n/**\n * Returns the default `HardhatRuntimeEnvironment` (`hre`) for the project.\n *\n * Throws if there is no `HardhatRuntimeEnvironment`.\n *\n * @returns {HardhatRuntimeEnvironment}\n */\nexport const getDefaultRuntimeEnvironment = (): HardhatRuntimeEnvironment => {\n    // The first step is to get the hardhat context\n    const context = getDefaultContext()\n\n    // We require the hardhat environment to already exist\n    //\n    // Again, we could create it but that means we'd need to duplicate the bootstrap code\n    // that hardhat does when setting up the environment\n    try {\n        return context.getHardhatRuntimeEnvironment()\n    } catch (error: unknown) {\n        throw new ConfigurationError(`Could not get Hardhat Runtime Environment: ${error}`)\n    }\n}\n\n/**\n * Creates a clone of the HardhatRuntimeEnvironment for a particular network\n *\n * ```typescript\n * const env = getHreByNetworkName(\"bsc-testnet\");\n *\n * // All the ususal properties are present\n * env.deployments.get(\"MyContract\")\n * ```\n *\n * @returns {Promise<HardhatRuntimeEnvironment>}\n */\nexport const getHreByNetworkName: GetByNetwork<HardhatRuntimeEnvironment> = pMemoize(async (networkName) => {\n    const context = getDefaultContext()\n    const environment = getDefaultRuntimeEnvironment()\n\n    try {\n        // The last step is to create a duplicate environment that mimics the original one\n        // with one crucial difference - the network setup\n        return new HardhatRuntimeEnvironmentImplementation(\n            environment.config,\n            {\n                ...environment.hardhatArguments,\n                network: networkName,\n            },\n            environment.tasks,\n            environment.scopes,\n            context.environmentExtenders,\n            environment.userConfig,\n            context.providerExtenders\n            // This is a bit annoying - the environmentExtenders are not stronly typed\n            // so TypeScript complains that the properties required by HardhatRuntimeEnvironment\n            // are not present on HardhatRuntimeEnvironmentImplementation\n        ) as unknown as HardhatRuntimeEnvironment\n    } catch (error: unknown) {\n        throw new ConfigurationError(`Could not setup Hardhat Runtime Environment: ${error}`)\n    }\n})\n\n/**\n * Creates a clone of the HardhatRuntimeEnvironment for a particular network\n * identified by endpoint ID\n *\n * ```typescript\n * const getHreByEid = createGetHreByEid()\n * const env = await getHreByEid(EndpointId.AVALANCHE_V2_TESTNET);\n *\n * // All the ususal properties are present\n * env.deployments.get(\"MyContract\")\n * ```\n *\n * @returns {Promise<HardhatRuntimeEnvironment>}\n */\nexport const createGetHreByEid = (\n    hre = getDefaultRuntimeEnvironment()\n): EndpointBasedFactory<HardhatRuntimeEnvironment> =>\n    pMemoize(async (eid: EndpointId) => getHreByNetworkName(getNetworkNameForEid(eid, hre)))\n\n/**\n * Helper function that wraps an EthereumProvider with EthersProviderWrapper\n * so that we can use it further with ethers as a regular JsonRpcProvider\n *\n * @param {EIP1193Provider} provider\n * @returns {JsonRpcProvider}\n */\nexport const wrapEIP1193Provider = (provider: EthereumProvider): JsonRpcProvider => new EthersProviderWrapper(provider)\n\n/**\n * Gets an EndpointId defined in the hardhat config\n * for a particular network name (as an `eid` property).\n *\n * Throws if the network or the eid are not defined\n *\n * @param {string} networkName\n * @param {HardhatRuntimeEnvironment | undefined} [hre]\n * @returns {EndpointId}\n */\nexport const getEidForNetworkName = (\n    networkName: string,\n    hre: HardhatRuntimeEnvironment = getDefaultRuntimeEnvironment()\n): EndpointId => {\n    const networkConfig = hre.config.networks[networkName]\n    assert(networkConfig, `Network '${networkName}' is not defined in hardhat config`)\n    assert(networkConfig.eid != null, `Network '${networkName}' does not have 'eid' property defined in its config`)\n\n    return networkConfig.eid\n}\n\n/**\n * Gets a network name with its `eid` property matching\n * a particular `eid`\n *\n * Throws if there are multiple networks defined with the same `eid`.\n *\n * Returns `undefined` if there is no network with given `eid`\n *\n * @param {EndpointId} eid\n * @param {HardhatRuntimeEnvironment | undefined} [hre]\n * @returns {string | undefined}\n */\nexport const getNetworkNameForEidMaybe = (\n    eid: EndpointId,\n    hre: HardhatRuntimeEnvironment = getDefaultRuntimeEnvironment()\n): string | undefined => {\n    // We are using getEidsByNetworkName to get the nice validation of network config\n    const eidsByNetworkName = getEidsByNetworkName(hre)\n\n    for (const [networkName, networkEid] of Object.entries(eidsByNetworkName)) {\n        if (networkEid === eid) {\n            return networkName\n        }\n    }\n\n    return undefined\n}\n\n/**\n * Gets a network name with its `eid` property matching\n * a particular `eid`\n *\n * Throws if there is no such network or if there are multiple\n * networks defined with the same `eid`\n *\n * @param {EndpointId} eid\n * @param {HardhatRuntimeEnvironment | undefined} [hre]\n * @returns {string}\n */\nexport const getNetworkNameForEid = (\n    eid: EndpointId,\n    hre: HardhatRuntimeEnvironment = getDefaultRuntimeEnvironment()\n): string => {\n    const networkName = getNetworkNameForEidMaybe(eid, hre)\n\n    // Here we error out if there are no networks with this eid\n    return assert(networkName != null, `Could not find a network for eid ${eid} (${formatEid(eid)})`), networkName\n}\n\n/**\n * Gets a record containing the mapping between network names and endpoint IDs.\n * Will also return the network names for which the `eid` has not been defined\n *\n * Throws if there are multiple networks defined with the same `eid`\n *\n * @param {HardhatRuntimeEnvironment | undefined} [hre]\n * @returns {Record<string, EndpointId | undefined>}\n */\nexport const getEidsByNetworkName = memoize(\n    (hre: HardhatRuntimeEnvironment = getDefaultRuntimeEnvironment()): Record<string, EndpointId | undefined> => {\n        // First we get the network name -> network config pairs\n        const networkEntries = Object.entries(hre.config.networks)\n        // And map the network config to an endpoint ID\n        const eidEntries = networkEntries.map(\n            ([networkName, networkConfig]) => [networkName, networkConfig.eid] as const\n        )\n        // Now we turn the entries back into a record\n        const eidsByNetworkName = Object.fromEntries(eidEntries)\n\n        // Now we check that the user has not configured the endpoint ID mapping incorrectly\n        // (i.e. there are more networks configured with the same endpoint ID)\n        //\n        // For this we'll drop all the networks whose endpoint IDs are not defined\n        const eidEntriesWithDefinedEid = eidEntries.filter(([_, eid]) => eid != null)\n        const definedEidsByNetworkName = Object.fromEntries(eidEntriesWithDefinedEid)\n\n        // Now we grab the sets of unique network names and endpoint IDs\n        const allDefinedEids = new Set(Object.values(definedEidsByNetworkName))\n        const allNetworkNames = new Set(Object.keys(definedEidsByNetworkName))\n\n        // If the number of unique networks matches the number of unique endpoint IDs, there are no duplicates\n        if (allDefinedEids.size === allNetworkNames.size) {\n            return eidsByNetworkName\n        }\n\n        // At this point the number of defined endpoint IDs can only be lower than\n        // the number of defined network names (since network names are taken from the keys\n        // of an object and endpoint IDs from its values)\n        //\n        // To let the user know whihc networks to fix, we need to grab all the ones that\n        // have been duplicated\n        //\n        // We are not claiming any efficiency of this algorithm as we don't expect any large numbers of networks\n        const duplicatedNetworkNames = Array.from(allDefinedEids)\n            // First we grab all the network names with this endpoint ID\n            .map((eid) =>\n                eidEntriesWithDefinedEid.flatMap(([networkName, definedEid]) =>\n                    eid === definedEid ? [networkName] : []\n                )\n            )\n            // Then we find all the network names listed more than once\n            .filter((networkNames) => networkNames.length > 1)\n\n        // Now we let the user know which network names have identical endpoint IDs\n        const messages = duplicatedNetworkNames\n            .map(\n                (networkNames) =>\n                    `- ${networkNames.join(', ')} have eid set to ${formatEid(eidsByNetworkName[networkNames[0]!]!)}`\n            )\n            .join('\\n')\n\n        throw new Error(\n            `Found multiple networks configured with the same 'eid':\\n\\n${messages}\\n\\nPlease fix this in your hardhat config.`\n        )\n    }\n)\n\n/**\n * Helper utility that copies the whole task definition under a new name\n *\n * This is useful if a new task needs to have the same interface as an existing task,\n * for example if we want to create a slightly modified version of a wire task\n * without needing to retype all the `.addFlag` and `.addOption`\n *\n * @param {string} parentTaskName Task to inherit the options and the action from\n * @param {HardhatRuntimeEnvironment} [hre]\n * @returns {(taskName: string) => ConfigurableTaskDefinition}\n */\nexport const inheritTask =\n    (parentTaskName: string, context = getDefaultContext()) =>\n    (taskName: string): ConfigurableTaskDefinition => {\n        // For now we only support non-scoped tasks\n        const parentTaskDefinition = context.tasksDSL.getTaskDefinition(undefined, parentTaskName)\n        assert(parentTaskDefinition != null, `Missing task definition for ${parentTaskName}`)\n\n        // First we create the task definition itself\n        const creator = parentTaskDefinition.isSubtask ? subtask : task\n        const childTask = creator(taskName).setAction(parentTaskDefinition.action)\n\n        // Then we start setting properties\n        if (parentTaskDefinition.description != null) {\n            childTask.setDescription(parentTaskDefinition.description)\n        }\n\n        // Params go first (just because I said so, not for any particular reason)\n        for (const definition of Object.values(parentTaskDefinition.paramDefinitions)) {\n            // Params need to be treated based on their type (flag/param)\n            if (definition.isFlag) {\n                childTask.addFlag(definition.name, definition.description)\n            } else {\n                childTask.addParam(\n                    definition.name,\n                    definition.description,\n                    definition.defaultValue,\n                    definition.type,\n                    definition.isOptional\n                )\n            }\n        }\n\n        // Positional params go second\n        for (const definition of parentTaskDefinition.positionalParamDefinitions) {\n            if (definition.isVariadic) {\n                childTask.addVariadicPositionalParam(\n                    definition.name,\n                    definition.description,\n                    definition.defaultValue,\n                    definition.type,\n                    definition.isOptional\n                )\n            } else {\n                childTask.addPositionalParam(\n                    definition.name,\n                    definition.description,\n                    definition.defaultValue,\n                    definition.type,\n                    definition.isOptional\n                )\n            }\n        }\n\n        return childTask\n    }\n","'use strict'\n\nexport class ConfigurationError extends Error {}\n","import { getAllArtifacts, isErrorFragment } from '@/artifacts'\nimport { Contract } from '@ethersproject/contracts'\nimport { OmniContract, createContractErrorParser } from '@layerzerolabs/devtools-evm'\nimport { makeZeroAddress } from '@layerzerolabs/devtools-evm'\nimport { EndpointId } from '@layerzerolabs/lz-definitions'\nimport pMemoize from 'p-memoize'\n\n/**\n * Helper function that combines all the available ABIs into a one giant\n * interface (only containing the error fragments) used for error decoding.\n *\n * @returns {OmniContract}\n */\nconst createCombinedContract = pMemoize(async (): Promise<OmniContract> => {\n    // We get all the available artifacts first\n    const artifacts = await getAllArtifacts()\n\n    // Now we combine the ABIs and keep only the errors\n    const abi = artifacts.flatMap((artifact) => artifact.abi).filter(isErrorFragment)\n\n    // Even though duplicated fragments don't throw errors, they still pollute the interface with warning console.logs\n    // To prevent this, we'll run a simple deduplication algorithm - use JSON encoded values as hashes\n    const deduplicatedAbi = Object.values(Object.fromEntries(abi.map((abi) => [JSON.stringify(abi), abi])))\n\n    // FIXME Since we are creating an endpoint-agnostic, completely fictional contract,\n    // we just make up and eid for it. Once the underlying logic is refactored, this should be gone\n    return { eid: -1 as EndpointId, contract: new Contract(makeZeroAddress(), deduplicatedAbi) }\n})\n\n/**\n * Creates a generic error parser based on all the artifacts found in your hardhat project\n */\nexport const createErrorParser = async () => createContractErrorParser(await createCombinedContract())\n","import { getDefaultRuntimeEnvironment } from '@/runtime'\nimport { Artifacts } from 'hardhat/internal/artifacts'\nimport { Artifact } from 'hardhat/types'\nimport pMemoize from 'p-memoize'\n\n/**\n * Will return all artifacts available in the project, including the external ones\n *\n * @return {Promise<Artifact[]>}\n */\nexport const getAllArtifacts = pMemoize(async (hre = getDefaultRuntimeEnvironment()): Promise<Artifact[]> => {\n    // First we collect all the paths where artifacts could be\n    //\n    // This is a port of the code found in hardhat-deploy/src/DeploymentsManager.ts\n    const externalContracts = hre.config.external?.contracts ?? []\n    const artifactsPaths: string[] = [\n        hre.config.paths.artifacts,\n        hre.config.paths.imports,\n        ...externalContracts.flatMap(({ artifacts }) => artifacts),\n    ]\n\n    // Now we create Artifacts objects\n    const artifactsObjects = artifactsPaths.map((path) => new Artifacts(path))\n\n    // Oxford dictionary defines \"artifactses\" as the plural form of \"artifacts\"\n    const artifactses = await Promise.all(artifactsObjects.map(getAllArtifactsFrom))\n\n    return artifactses.flat()\n})\n\nconst getAllArtifactsFrom = async (artifactsObject: Artifacts) => {\n    // First we get all the fully qualified names fro mthis artifacts object\n    const fullyQualifiedNames = await artifactsObject.getAllFullyQualifiedNames()\n\n    return fullyQualifiedNames.map((name) => artifactsObject.readArtifactSync(name))\n}\n\nexport const isErrorFragment = <TFragment extends { type?: string }>(\n    fragment: TFragment\n): fragment is TFragment & { type: 'error' } => fragment.type === 'error'\n","import { types as builtInTypes } from 'hardhat/config'\nimport { HardhatError } from 'hardhat/internal/core/errors'\nimport { ERRORS } from 'hardhat/internal/core/errors-list'\nimport type { CLIArgumentType } from 'hardhat/types'\nimport { splitCommaSeparated } from '@layerzerolabs/devtools'\nimport { isEVMAddress, SignerDefinition } from '@layerzerolabs/devtools-evm'\nimport { isLogLevel, LogLevel } from '@layerzerolabs/io-devtools'\nimport { EndpointId, Environment, Stage } from '@layerzerolabs/lz-definitions'\n\n/**\n * Hardhat CLI type for a comma separated list of arbitrary strings\n */\nconst csv: CLIArgumentType<string[]> = {\n    name: 'csv',\n    parse(name: string, value: string) {\n        return splitCommaSeparated(value)\n    },\n    validate() {},\n}\n\nconst isEnvironment = (value: string): value is Environment => Object.values<string>(Environment).includes(value)\n\n/**\n * Hardhat CLI type for a LayzerZero chain environment\n *\n * @see {@link Environment}\n */\nconst environment: CLIArgumentType<Environment> = {\n    name: 'environment',\n    parse(name: string, value: string) {\n        if (!isEnvironment(value)) {\n            throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: name,\n                type: 'environment',\n            })\n        }\n\n        return value\n    },\n    validate() {},\n}\n\nconst isStage = (value: string): value is Stage => Object.values<string>(Stage).includes(value)\n\n/**\n * Hardhat CLI type for a LayzerZero chain stage\n *\n * @see {@link Stage}\n */\nconst stage: CLIArgumentType<Stage> = {\n    name: 'stage',\n    parse(name: string, value: string) {\n        if (!isStage(value)) {\n            throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: name,\n                type: 'stage',\n            })\n        }\n\n        return value\n    },\n    validate() {},\n}\n\n/**\n * Hardhat CLI type for a LayzerZero chain stage\n *\n * @see {@link Stage}\n */\nconst eid: CLIArgumentType<EndpointId> = {\n    name: 'eid',\n    parse(name: string, value: string) {\n        const valueAsInt = parseInt(value)\n        if (isNaN(valueAsInt)) {\n            const eid = EndpointId[value]\n\n            if (typeof eid !== 'number') {\n                throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                    value,\n                    name: name,\n                    type: 'stage',\n                })\n            }\n\n            return eid\n        }\n\n        const eidLabel = EndpointId[valueAsInt]\n        if (typeof eidLabel !== 'string') {\n            throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: name,\n                type: 'stage',\n            })\n        }\n\n        return valueAsInt as EndpointId\n    },\n    validate() {},\n}\n\n/**\n * Hardhat CLI type for a log level argument\n *\n * @see {@link LogLevel}\n */\nconst logLevel: CLIArgumentType<LogLevel> = {\n    name: 'logLevel',\n    parse(name: string, value: string) {\n        if (!isLogLevel(value)) {\n            throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: name,\n                type: 'logLevel',\n            })\n        }\n\n        return value\n    },\n    validate() {},\n}\n\n/**\n * Hardhat CLI type for a function argument.\n *\n * This is only to be used with subtasks since you cannot pass functions\n * to tasks (unless you're insane and want to inline a function)\n */\nexport const fn: CLIArgumentType<string> = {\n    name: 'function',\n    parse: (argName, value) => {\n        if (typeof value !== 'function') {\n            throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: argName,\n                type: fn.name,\n            })\n        }\n\n        return value\n    },\n    validate() {},\n}\n\n/**\n * Signer-specific CLI argument (either a non-negative index\n * or a signer EVM address)\n */\nexport const signer: CLIArgumentType<SignerDefinition> = {\n    name: 'signer',\n    parse: (argName, value) => {\n        // If the value looks like an EVM address, we'll return an address definition\n        if (isEVMAddress(value)) {\n            return { type: 'address', address: value }\n        }\n\n        // If the value parses to an integer, we'll return an index definition\n        const parsed = parseInt(value, 10)\n        if (!isNaN(parsed)) {\n            if (parsed < 0) {\n                throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                    value,\n                    name: argName,\n                    type: signer.name,\n                })\n            }\n\n            return { type: 'index', index: parsed }\n        }\n\n        // In any other case we'll return a named definition\n        return { type: 'named', name: value }\n    },\n    validate() {},\n}\n\nexport const types = { csv, eid, logLevel, fn, signer, environment, stage, ...builtInTypes }\n","import 'hardhat-deploy/dist/src/type-extensions'\n\nimport { endpointIdToNetwork } from '@layerzerolabs/lz-definitions'\nimport { HardhatUserConfig } from 'hardhat/types'\nimport { join, dirname } from 'path'\nimport { createModuleLogger } from '@layerzerolabs/io-devtools'\nimport type { ArtifactPackage } from './type-extensions'\n\nconst resolvePackageDirectory = (packageName: string): string => {\n    // The tricky bit here is the fact that if we resolve packages by their package name,\n    // we might be pointed to a file in some dist directory - node will just pick up the `main`\n    // entry in package.json and point us there\n    //\n    // So in order to get a stable path we choose package.json, pretty solid choice\n    const packageJsonName = join(packageName, 'package.json')\n    // We now resolve the path to package.json\n    const packageJsonPath = require.resolve(packageJsonName)\n    // And return its directory\n    return dirname(packageJsonPath)\n}\n\nconst resolveArtifactsPath = (artifactsPackage: ArtifactPackage): string => {\n    // In case the package was specified as a package name only, we'll resolve its filesystem location\n    // and use the default `artifacts` directory\n    if (typeof artifactsPackage === 'string') {\n        return join(resolvePackageDirectory(artifactsPackage), 'artifacts')\n    }\n\n    // In case the package was specified as an object, we'll use the `path` property to point to the artifacts directory\n    if (artifactsPackage.name != null) {\n        return join(resolvePackageDirectory(artifactsPackage.name), artifactsPackage.path ?? 'artifacts')\n    }\n\n    // In case the package was specified as a `path` only, we'll use that as the final artifacts path\n    return artifactsPackage.path\n}\n\n/**\n * Helper utility that adds external deployment paths for all LayzerZero enabled networks.\n * This will make LayerZero contracts available in your deploy scripts and tasks.\n *\n * ```\n * // hardhat.config.ts\n * import { EndpointId } from \"@layerzerolabs/lz-definitions\"\n *\n * const config: HardhatUserConfig = {\n *   networks: {\n *     arbitrum: {\n *       eid: EndpointId.ARBITRUM_MAINNET\n *     },\n *     fuji: {\n *       eid: EndpointId.AVALANCHE_TESTNET\n *     }\n *   }\n * }\n *\n * export default withLayerZeroDeployments(\"@layerzerolabs/lz-evm-sdk-v1\")\n * ```\n *\n * @param packageNames `string[]` List of @layerzerolabs package names that contain deployments directory\n *\n * @returns `<THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig): THardhatUserConfig` Hardhat config decorator\n */\nexport const withLayerZeroDeployments = (...packageNames: string[]) => {\n    const resolvedDeploymentsDirectories = packageNames\n        // The first thing we do is we resolve the paths to LayerZero packages\n        .map(resolvePackageDirectory)\n        // Then navigate to the deployments folder\n        .map((resolvedPackagePath) => join(resolvedPackagePath, 'deployments'))\n\n    // We return a function that will enrich hardhat config with the external deployments configuration\n    //\n    // This is a pretty standard way of enriching configuration files that leads to quite nice consumer code\n    return <THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig): THardhatUserConfig => ({\n        ...config,\n        external: {\n            ...config.external,\n            // Now for the meat of the operation, we'll enrich the external.deployments object\n            deployments: Object.fromEntries(\n                Object.entries(config.networks ?? {}).flatMap(([networkName, networkConfig]) => {\n                    const eid = networkConfig?.eid\n                    const networkLogger = createModuleLogger(networkName)\n\n                    // Let's first check whether eid is defined on the network config\n                    if (eid == null) {\n                        networkLogger.debug(\n                            'Endpoint ID not specified in hardhat config, skipping external deployment configuration'\n                        )\n\n                        return []\n                    }\n\n                    try {\n                        // This operation is unsafe and can throw - let's make sure we don't explode with some unreadable error\n                        const layerZeroNetworkName = endpointIdToNetwork(eid, networkConfig?.isLocalEid)\n                        const layerZeroNetworkDeploymentsDirectories = resolvedDeploymentsDirectories.map(\n                            (deploymentsDirectory) => join(deploymentsDirectory, layerZeroNetworkName)\n                        )\n\n                        return [\n                            [\n                                // The external deployments object is keyed by local network names\n                                // which do not necessarily match the LayerZero ones\n                                networkName,\n                                // And its values are arrays of filesystem paths referring to individual network deployment directories\n                                Array.from(\n                                    // Since we want the paths to be unique, we'll put everything we have into a Set, then convert back to array\n                                    new Set([\n                                        // These are the external deployments already configured\n                                        ...(config.external?.deployments?.[networkName] ?? []),\n                                        // And these are the new ones\n                                        ...layerZeroNetworkDeploymentsDirectories,\n                                    ])\n                                ),\n                            ],\n                        ]\n                    } catch (error) {\n                        networkLogger.error(\n                            `Invalid endpoint ID specified in hardhat config (${eid}), skipping external deployment configuration`\n                        )\n\n                        return []\n                    }\n                })\n            ),\n        },\n    })\n}\n\n/**\n * Helper utility that appends external artifacts directories\n * to existing hadrhat config\n *\n * ```\n * // hardhat.config.ts\n * import { EndpointId } from \"@layerzerolabs/lz-definitions\"\n *\n * const config: HardhatUserConfig = {\n *   networks: {\n *     arbitrum: {\n *       eid: EndpointId.ARBITRUM_MAINNET\n *     },\n *     fuji: {\n *       eid: EndpointId.AVALANCHE_TESTNET\n *     }\n *   }\n * }\n *\n * export default withLayerZeroArtifacts(\"@layerzerolabs/lz-evm-sdk-v1\")\n * ```\n *\n * @param packageNames `string[]`\n *\n * @returns `<THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig): THardhatUserConfig` Hardhat config decorator\n */\nexport const withLayerZeroArtifacts = (...artifactPackages: ArtifactPackage[]) => {\n    const resolvedArtifactsDirectories = artifactPackages\n        // The first thing we do is we resolve the artifact package definitions into filesystem paths\n        .map(resolveArtifactsPath)\n\n    // We return a function that will enrich hardhat config with the external artifacts configuration\n    //\n    // This is a pretty standard way of enriching configuration files that leads to quite nice consumer code\n    return <THardhatUserConfig extends HardhatUserConfig>(config: THardhatUserConfig): THardhatUserConfig => {\n        // We'll first grab all the external artifacts already defined\n        const existingArtifacts = new Set(config.external?.contracts?.flatMap(({ artifacts }) => artifacts) ?? [])\n\n        // And only append stuff if we have something new to say\n        const newArtifacts = new Set(\n            resolvedArtifactsDirectories.filter((artifact) => !existingArtifacts.has(artifact))\n        )\n        if (newArtifacts.size === 0) {\n            return config\n        }\n\n        return {\n            ...config,\n            external: {\n                ...config.external,\n                contracts: [\n                    ...(config.external?.contracts ?? []),\n                    {\n                        artifacts: Array.from(newArtifacts),\n                    },\n                ],\n            },\n        }\n    }\n}\n","export const TASK_LZ_DEPLOY = 'lz:deploy'\n\nexport const TASK_LZ_EXPORT_DEPLOYMENTS_TYPESCRIPT = 'lz:export:deployments:typescript'\n\nexport const SUBTASK_LZ_SIGN_AND_SEND = '::lz:sign-and-send'\n\nexport const TASK_LZ_TEST_SIMULATION_START = 'lz:test:simulation:start'\n\nexport const TASK_LZ_TEST_SIMULATION_LOGS = 'lz:test:simulation:logs'\n\nexport const TASK_LZ_TEST_SIMULATION_STOP = 'lz:test:simulation:stop'\n\nexport const TASK_LZ_VALIDATE_SAFE_CONFIGS = 'lz:healthcheck:validate:safe-configs'\n\nexport const TASK_LZ_VALIDATE_RPCS = 'lz:healthcheck:validate:rpcs'\n","import { getDefaultRuntimeEnvironment, getEidsByNetworkName } from '@/runtime'\nimport assert, { AssertionError } from 'assert'\nimport 'hardhat-deploy/dist/src/type-extensions'\nimport { DeploymentsExtension } from 'hardhat-deploy/dist/types'\nimport { HardhatRuntimeEnvironment } from 'hardhat/types'\n\nexport interface HardhatRuntimeEnvironmentWithDeployments extends HardhatRuntimeEnvironment {\n    deployments: DeploymentsExtension\n}\n\n/**\n * Helper utility to make sure hardhat-deploy is being used by the project\n *\n * @param {HardhatRuntimeEnvironment} hre\n */\nexport function assertHardhatDeploy(\n    hre: HardhatRuntimeEnvironment\n): asserts hre is HardhatRuntimeEnvironmentWithDeployments {\n    assert(hre.deployments, `You don't seem to be using hardhat-deploy in your project`)\n}\n\n/**\n * Helper utility to make sure that all the networks passed\n * to this function have been defined in the config\n *\n * @param {Iterable<string>} networkNames\n * @param {HardhatRuntimeEnvironment} hre\n */\nexport function assertDefinedNetworks<TNetworkNames extends Iterable<string>>(\n    networkNames: TNetworkNames,\n    hre: HardhatRuntimeEnvironment = getDefaultRuntimeEnvironment()\n): TNetworkNames {\n    const definedNetworkNames = new Set(Object.keys(getEidsByNetworkName(hre)))\n\n    for (const networkName of networkNames) {\n        if (definedNetworkNames.has(networkName)) {\n            continue\n        }\n\n        throw new AssertionError({\n            message: `Network '${networkName}' has not been defined. Defined networks are ${Array.from(definedNetworkNames).join(', ')}`,\n        })\n    }\n\n    return networkNames\n}\n","import type { OmniGraphHardhat, OmniGraphHardhatTransformer } from './types'\nimport { OmniGraphBuilder } from '@layerzerolabs/devtools'\nimport assert from 'assert'\nimport { createOmniGraphHardhatTransformer } from './transformations'\n\n/**\n * OmniGraphBuilderHardhat houses all hardhat-specific utilities for building OmniGraphs\n *\n * It is not an instantiable class - it only provides static utilities for working with OmniGraph\n *\n * @deprecated Transform the graph using the transformation function from `createOmniGraphHardhatTransformer()` directly:\n *\n * ```\n * const hardhatGraph: OmniGraphHardhat<TNodeConfig, TEdgeConfig>\n * const transformer = createOmniGraphHardhatTransformer()\n * const graph = await transformer(hardhatGraph)\n * ```\n */\nexport class OmniGraphBuilderHardhat {\n    static async fromConfig<TNodeConfig, TEdgeConfig>(\n        graph: OmniGraphHardhat<TNodeConfig, TEdgeConfig>,\n        transform: OmniGraphHardhatTransformer<TNodeConfig, TEdgeConfig> = createOmniGraphHardhatTransformer()\n    ): Promise<OmniGraphBuilder<TNodeConfig, TEdgeConfig>> {\n        return OmniGraphBuilder.fromGraph(await transform(graph))\n    }\n\n    constructor() {\n        assert(\n            false,\n            'OmniGraphBuilderHardhat cannot be instantiated - it only provides static utilities for working with OmniGraph'\n        )\n    }\n}\n","import type { OmniEdge, OmniNode } from '@layerzerolabs/devtools'\nimport { isOmniPoint } from '@layerzerolabs/devtools'\nimport { omniContractToPoint } from '@layerzerolabs/devtools-evm'\nimport { createContractFactory } from './coordinates'\nimport type {\n    OmniContractFactoryHardhat,\n    OmniEdgeHardhat,\n    OmniGraphHardhatTransformer,\n    OmniNodeHardhat,\n    OmniPointHardhatTransformer,\n} from './types'\nimport { parallel } from '@layerzerolabs/devtools'\n\n/**\n * Create a function capable of transforming `OmniPointHardhat` to a regular `OmniPoint`\n * with some help from an `OmniContractFactoryHardhat`\n *\n * @param {OmniContractFactoryHardhat} contractFactory\n * @returns {OmniPointHardhatTransformer}\n */\nexport const createOmniPointHardhatTransformer =\n    (contractFactory: OmniContractFactoryHardhat = createContractFactory()): OmniPointHardhatTransformer =>\n    async (point) =>\n        isOmniPoint(point) ? point : { ...point, ...omniContractToPoint(await contractFactory(point)) }\n\n/**\n * Create a function capable of transforming `OmniNodeHardhat` to a regular `OmniNode`\n * with some help from an `OmniPointHardhatTransformer`\n *\n * @param {OmniPointHardhatTransformer} [pointTransformer]\n * @returns\n */\nexport const createOmniNodeHardhatTransformer =\n    (pointTransformer = createOmniPointHardhatTransformer()) =>\n    async <TNodeConfig>({ contract, config }: OmniNodeHardhat<TNodeConfig>): Promise<OmniNode<TNodeConfig>> => ({\n        point: await pointTransformer(contract),\n        config: config as TNodeConfig,\n    })\n\n/**\n * Create a function capable of transforming `OmniEdgeHardhat` to a regular `OmniEdge`\n * with some help from an `OmniPointHardhatTransformer`\n *\n * @param {OmniPointHardhatTransformer} [pointTransformer]\n * @returns\n */\nexport const createOmniEdgeHardhatTransformer =\n    (pointTransformer = createOmniPointHardhatTransformer()) =>\n    async <TEdgeConfig>({ from, to, config }: OmniEdgeHardhat<TEdgeConfig>): Promise<OmniEdge<TEdgeConfig>> => ({\n        vector: {\n            from: await pointTransformer(from),\n            to: await pointTransformer(to),\n        },\n        config: config as TEdgeConfig,\n    })\n\nexport const createOmniGraphHardhatTransformer =\n    <TNodeConfig, TEdgeConfig>(\n        nodeTransformer = createOmniNodeHardhatTransformer(),\n        edgeTransformer = createOmniEdgeHardhatTransformer(),\n        applicative = parallel\n    ): OmniGraphHardhatTransformer<TNodeConfig, TEdgeConfig> =>\n    async ({ contracts, connections }) => ({\n        contracts: await applicative(contracts.map((contract) => () => nodeTransformer(contract))),\n        connections: await applicative(connections.map((connection) => () => edgeTransformer(connection))),\n    })\n","import { formatEid, type OmniPoint } from '@layerzerolabs/devtools'\nimport pMemoize from 'p-memoize'\nimport { OmniContract } from '@layerzerolabs/devtools-evm'\nimport { Contract } from '@ethersproject/contracts'\nimport assert from 'assert'\nimport { OmniContractFactoryHardhat, OmniDeployment } from './types'\nimport { createGetHreByEid } from '@/runtime'\nimport { assertHardhatDeploy } from '@/internal/assertions'\nimport { createModuleLogger } from '@layerzerolabs/io-devtools'\n\nexport const omniDeploymentToPoint = ({ eid, deployment }: OmniDeployment): OmniPoint => ({\n    eid,\n    address: deployment.address,\n})\n\nexport const omniDeploymentToContract = ({ eid, deployment }: OmniDeployment): OmniContract => ({\n    eid,\n    contract: new Contract(deployment.address, deployment.abi),\n})\n\nexport const createContractFactory = (environmentFactory = createGetHreByEid()): OmniContractFactoryHardhat => {\n    return pMemoize(async ({ eid, address, contractName }) => {\n        const env = await environmentFactory(eid)\n        assertHardhatDeploy(env)\n\n        const networkLabel = `${formatEid(eid)} (${env.network.name})`\n        const logger = createModuleLogger(`Contract factory @ ${networkLabel}`)\n\n        // If we have both the contract name & address, we go off artifacts\n        if (contractName != null && address != null) {\n            logger.verbose(`Looking for contract ${contractName} on address ${address} in artifacts`)\n\n            const artifact = await env.deployments.getArtifact(contractName).catch((error) => {\n                logger.verbose(`Failed to load artifact for contract ${contractName} on address ${address}: ${error}`)\n                logger.verbose(`Will search for the contract by its address only`)\n            })\n\n            if (artifact != null) {\n                const contract = new Contract(address, artifact.abi)\n\n                return { eid, contract }\n            }\n        }\n\n        // If we have the contract name but no address, we need to get it from the deployments by name\n        if (contractName != null && address == null) {\n            logger.verbose(`Looking for contract ${contractName} in deployments`)\n\n            const deployment = await env.deployments.getOrNull(contractName)\n            assert(deployment != null, `Could not find a deployment for contract '${contractName}' on ${networkLabel}`)\n\n            return omniDeploymentToContract({ eid, deployment })\n        }\n\n        // And if we only have the address, we need to go get it from deployments by address\n        if (address != null) {\n            logger.verbose(`Looking for contract with address ${address} in deployments`)\n\n            // The deployments can contain multiple deployment files for the same address\n            //\n            // This happens (besides of course a case of switching RPC URLs without changing network names)\n            // when using proxies - hardhat-deploy will create multiple deployment files\n            // with complete and partial ABIs\n            //\n            // To handle this case we'll merge the ABIs to make sure we have all the methods available\n            const deployments = await env.deployments\n                .getDeploymentsFromAddress(address)\n                .then(\n                    (deployments) =>\n                        (\n                            // We want to handle a case in which no deployments are returned\n                            // because the store has been cleared\n                            assert(\n                                deployments.length > 0,\n                                `Could not find a deployment for address '${address}' on ${networkLabel}`\n                            ),\n                            deployments\n                        )\n                )\n                .catch(async () => {\n                    // Hardhat deploy does not call its setup function when we call getDeploymentsFromAddress\n                    // so we need to force it to do so\n                    //\n                    // Since the setup function is not available on the deployments extension, we need to trigger it indirectly\n                    await env.deployments.all()\n\n                    return await env.deployments.getDeploymentsFromAddress(address)\n                })\n            assert(deployments.length > 0, `Could not find a deployment for address '${address}' on ${networkLabel}`)\n\n            const mergedAbis = deployments.flatMap((deployment) => deployment.abi)\n\n            // Even though duplicated fragments don't throw errors, they still pollute the interface with warning console.logs\n            // To prevent this, we'll run a simple deduplication algorithm - use JSON encoded values as hashes\n            const deduplicatedAbi = Object.values(\n                Object.fromEntries(mergedAbis.map((abi) => [JSON.stringify(abi), abi]))\n            )\n\n            return { eid, contract: new Contract(address, deduplicatedAbi) }\n        }\n\n        assert(false, `At least one of contractName, address must be specified for OmniPointHardhat on ${networkLabel}`)\n    })\n}\n","import pMemoize from 'p-memoize'\nimport { ProviderFactory, connectOmniContract } from '@layerzerolabs/devtools-evm'\nimport { createContractFactory } from '@/omnigraph/coordinates'\nimport type { OmniContractFactoryHardhat } from '@/omnigraph/types'\nimport { createProviderFactory } from '@/provider'\n\nexport const createConnectedContractFactory = (\n    contractFactory: OmniContractFactoryHardhat = createContractFactory(),\n    providerFactory: ProviderFactory = createProviderFactory()\n): OmniContractFactoryHardhat =>\n    pMemoize(async (point) => {\n        const contract = await contractFactory(point)\n        const provider = await providerFactory(point.eid)\n\n        return connectOmniContract(contract, provider)\n    })\n","import type { JsonRpcProvider } from '@ethersproject/providers'\nimport type { ProviderFactory } from '@layerzerolabs/devtools-evm'\nimport pMemoize from 'p-memoize'\nimport { createGetHreByEid, wrapEIP1193Provider } from './runtime'\n\nexport const createProviderFactory = (\n    networkEnvironmentFactory = createGetHreByEid()\n): ProviderFactory<JsonRpcProvider> => {\n    return pMemoize(async (eid) => {\n        const env = await networkEnvironmentFactory(eid)\n\n        return wrapEIP1193Provider(env.network.provider)\n    })\n}\n","import { z } from 'zod'\nimport { EndpointIdSchema, OmniPointSchema } from '@layerzerolabs/devtools'\nimport type { OmniEdgeHardhat, OmniGraphHardhat, OmniNodeHardhat, OmniPointHardhat, WithContractName } from './types'\n\nexport const OmniPointHardhatSchema: z.ZodSchema<OmniPointHardhat, z.ZodTypeDef, unknown> = z.object({\n    eid: EndpointIdSchema,\n    contractName: z.string().nullish(),\n    address: z.string().nullish(),\n})\n\nconst OmniPointOrOmniPointHardhatSchema = z.union([OmniPointHardhatSchema, OmniPointSchema])\n\n/**\n * Factory for OmniNodeHardhat schemas\n *\n * @param configSchema Schema of the config contained in the node\n *\n * @returns {z.ZodSchema<OmniNodeHardhat<TConfig>>} schema for a node with the particular config type\n */\nexport const createOmniNodeHardhatSchema = <TConfig = unknown>(\n    configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniNodeHardhat<TConfig>, z.ZodTypeDef, unknown> =>\n    z.object({\n        contract: OmniPointOrOmniPointHardhatSchema,\n        config: configSchema,\n    }) as z.ZodSchema<OmniNodeHardhat<TConfig>, z.ZodTypeDef>\n\n/**\n * Factory for OmniEdgeHardhat schemas\n *\n * @param {z.ZodSchema<TConfig>} configSchema Schema of the config contained in the edge\n *\n * @returns {z.ZodSchema<OmniEdgeHardhat<TConfig>>} Schema for an edge with the particular config type\n */\nexport const createOmniEdgeHardhatSchema = <TConfig = unknown>(\n    configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniEdgeHardhat<TConfig>, z.ZodTypeDef, unknown> =>\n    z.object({\n        from: OmniPointOrOmniPointHardhatSchema,\n        to: OmniPointOrOmniPointHardhatSchema,\n        config: configSchema,\n    }) as z.ZodSchema<OmniEdgeHardhat<TConfig>, z.ZodTypeDef>\n\n/**\n * Factory for OmniGraphHardhat schemas\n *\n * @param {z.ZodSchema<OmniNodeHardhat<TNodeConfig>>} nodeSchema\n * @param {z.ZodSchema<OmniEdgeHardhat<TEdgeConfig>>} edgeSchema\n *\n * @returns {z.ZodSchema<OmniGraphHardhat<TNodeConfig, TEdgeConfig>>}\n */\nexport const createOmniGraphHardhatSchema = <TNodeConfig = unknown, TEdgeConfig = unknown>(\n    nodeSchema: z.ZodSchema<OmniNodeHardhat<TNodeConfig>, z.ZodTypeDef, unknown>,\n    edgeSchema: z.ZodSchema<OmniEdgeHardhat<TEdgeConfig>, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniGraphHardhat<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown> =>\n    z.object({\n        contracts: z.array(nodeSchema),\n        connections: z.array(edgeSchema),\n    })\n\nexport const hasContractName = <T extends object>(value: T): value is WithContractName<T> =>\n    'contractName' in value && typeof value.contractName === 'string'\n","import { pipe } from 'fp-ts/lib/function'\nimport * as RR from 'fp-ts/ReadonlyRecord'\nimport type { ComposeSpec, ComposeSpecService } from '@layerzerolabs/devtools'\nimport { type AnvilOptions, createAnvilCliOptions } from '@layerzerolabs/devtools-evm'\nimport type { ComposeSpecServices } from '@layerzerolabs/devtools'\nimport type { SimulationConfig } from './types'\n\n/**\n * Creates a docker compose service specification for an anvil-based EVM node\n *\n * @param {AnvilOptions} anvilOptions\n * @returns {ComposeSpecService}\n */\nexport const createEvmNodeServiceSpec = (anvilOptions: AnvilOptions): ComposeSpecService => ({\n    // This service references a Dockerfile that is copied\n    // next to the resulting docker-compose.yaml\n    //\n    // The source for this Dockerfile is located in src/simulation/assets/Dockerfile.conf\n    build: {\n        dockerfile: 'Dockerfile',\n        target: 'node-evm',\n    },\n    command: ['anvil', ...createAnvilCliOptions(anvilOptions)],\n})\n\n/**\n * Creates a docker compose service specification for an nginx-based proxy service\n * that proxies requests to underlying EVM nodes (or their RPC URLs to be mor precise)\n *\n * @param {number} port\n * @param {ComposeSpecServices} networkServices\n * @returns {ComposeSpecService}\n */\nexport const createEvmNodeProxyServiceSpec = (\n    port: number,\n    networkServices: ComposeSpecServices\n): ComposeSpecService => ({\n    // This service references a Dockerfile that is copied\n    // next to the resulting docker-compose.yaml\n    //\n    // The source for this Dockerfile is located in src/simulation/assets/Dockerfile.conf\n    build: {\n        dockerfile: 'Dockerfile',\n        target: 'proxy-evm',\n    },\n    // This service will expose its internal 8545 port to a host port\n    //\n    // The internal 8545 port is hardcoded both here and in the nginx.conf file,\n    // the source for which is located in src/simulation/assets/nginx.conf\n    ports: [`${port}:8545`],\n    depends_on: pipe(\n        networkServices,\n        // This service will depend on the RPCs to be healthy\n        // so we'll take the networkServices object and replace\n        // the values with service_healthy condition\n        RR.map(() => ({\n            condition: 'service_healthy',\n        }))\n    ),\n})\n\n/**\n * Creates a docker compose spec with a set of anvil-based EVM nodes\n * and a single proxy server that proxies requests to these nodes.\n *\n * @param {SimulationConfig} config\n * @param {Record<string, AnvilOptions>} networks\n * @returns {ComposeSpec}\n */\nexport const createSimulationComposeSpec = (\n    config: SimulationConfig,\n    networks: Record<string, AnvilOptions>\n): ComposeSpec => ({\n    services: pipe(\n        networks,\n        // First we turn the networks into docker compose specs for EVM nodes\n        RR.map(createEvmNodeServiceSpec),\n        (networkServiceSpecs) =>\n            // Then we add the RPC proxy server\n            //\n            // There is a small edge case here that we can address\n            // if it ever comes up: if a network is called 'rpc', this compose file\n            // will not work.\n            //\n            // The fix for this is to prefix all networks with something like network-xxx\n            // but we can do that if ever this usecase comes up\n            pipe(\n                networkServiceSpecs,\n                RR.upsertAt('rpc', createEvmNodeProxyServiceSpec(config.port, networkServiceSpecs))\n            )\n    ),\n})\n","import type { HardhatConfig, HttpNetworkConfig, NetworkConfig } from 'hardhat/types'\nimport type { SimulationConfig, SimulationUserConfig } from './types'\nimport { resolve } from 'path'\nimport { AnvilOptions } from '@layerzerolabs/devtools-evm'\nimport { pipe } from 'fp-ts/lib/function'\nimport * as R from 'fp-ts/Record'\n\n/**\n * Turns `SimulationUserConfig` into `SimulationConfig` by supplying defaults\n *\n * @param {SimulationUserConfig} userConfig\n * @param {HardhatConfig} hardhatConfig\n * @returns {SimulationConfig}\n */\nexport const resolveSimulationConfig = (\n    userConfig: SimulationUserConfig,\n    hardhatConfig: HardhatConfig\n): SimulationConfig => ({\n    port: userConfig.port ?? 8545,\n    directory: resolve(hardhatConfig.paths.root, userConfig.directory ?? '.layerzero'),\n    overwriteAccounts: userConfig.overwriteAccounts ?? true,\n    anvil: {\n        // For now we'll hardcode the mnemonic we'll use to seed the accounts on the simulation networks\n        mnemonic: 'test test test test test test test test test test test junk',\n        ...userConfig.anvil,\n        // The host and port need to always point to 0.0.0.0:8545\n        // since anvil runs in the container that exposes this port on 0.0.0.0\n        host: '0.0.0.0',\n        port: 8545,\n    },\n})\n\n/**\n * Takes a portion of the hardhat networks config and turns the values into `AnvilOptions`\n * to be used by a simulation network container.\n *\n * This is used in the simulation generation phase where the compose files\n * for networks defined in hardhat config are being generated.\n *\n * The `Record<string, NetworkConfig>` is used instead of `NetworksConfig` type from hardhat\n * to avoid any type issues with special keys like `localhost` or `hardhat`.\n *\n * @param {SimulationConfig} config\n * @param {Record<string, NetworkConfig>} networksConfig\n * @returns {Record<string, AnvilOptions>} Object with the same keys as the networks config, with values mapped to `AnvilOptions`\n */\nexport const getAnvilOptionsFromHardhatNetworks = (\n    config: SimulationConfig,\n    networksConfig: Record<string, NetworkConfig>\n): Record<string, AnvilOptions> =>\n    pipe(\n        networksConfig,\n        // We want to drop all the networks that don't have URLs\n        R.filter(isHttpNetworkConfig),\n        // And map the network configs into AnvilOptions\n        R.map(\n            (networkConfig: HttpNetworkConfig): AnvilOptions => ({\n                ...config.anvil,\n                forkUrl: networkConfig.url,\n            })\n        )\n    )\n\n/**\n * Returns with overrides for hardhat network configuration.\n *\n * This, when merged with a hardhat config, will redirect the network calls to the local EVM nodes.\n *\n * @param {SimulationConfig} config\n * @param {Record<string, NetworkConfig>} networksConfig\n * @returns {Record<string, NetworkConfig>}\n */\nexport const getHardhatNetworkOverrides = (\n    config: SimulationConfig,\n    networksConfig: Record<string, NetworkConfig>\n): Record<string, NetworkConfig> =>\n    pipe(\n        networksConfig,\n        // We want to drop all the networks that don't have URLs\n        R.filter(isHttpNetworkConfig),\n        // We'll take the existing network configs and point them to our RPC proxy\n        //\n        // It's important that these configs are not saved to filesystem as they might contain\n        // sensitive data (and forgetting to ignore these files in git could lead to security breaches)\n        R.mapWithIndex(\n            (networkName, networkConfig): NetworkConfig => ({\n                ...networkConfig,\n                // We want to redirect this network to the local proxy\n                //\n                // This is the nginx server listening on the port we configured in the simulation configuration\n                url: new URL(networkName, `http://localhost:${config.port}`).toString(),\n                accounts: config.overwriteAccounts\n                    ? // When overwriting accounts, all the accounts will be switched to the anvil config\n                      // (or reasonable defaults if not provided)\n                      {\n                          mnemonic: config.anvil.mnemonic,\n                          // These need to be defaulted to the anvil options\n                          // (or the anvil defaults)\n                          //\n                          // See https://book.getfoundry.sh/reference/cli/anvil for anvil defaults\n                          count: config.anvil.count ?? 10,\n                          path: config.anvil.derivationPath ?? \"m/44'/60'/0'/0/\",\n                          // These will be hardcoded for now as anvil does not support setting these\n                          initialIndex: 0,\n                          passphrase: '',\n                      }\n                    : networkConfig.accounts,\n            })\n        )\n    )\n\n/**\n * Helper utility to pick network configs by their names / object keys.\n *\n * Similar to TypeScript `Pick` helper type, but in runtime.\n *\n * @param {string[]} networks List of networks to pick\n */\nexport const pickNetworkConfigs = (networks: string[]) =>\n    R.filterWithIndex<string, NetworkConfig>((networkName: string) => networks.includes(networkName))\n\n/**\n * Little helper utility that checks whether a network config is not a hardhat network config\n *\n * @param {NetworkConfig} networkConfig\n * @returns {boolean}\n */\nconst isHttpNetworkConfig = (networkConfig: NetworkConfig): networkConfig is HttpNetworkConfig =>\n    'url' in networkConfig && typeof networkConfig.url === 'string'\n","import { formatOmniTransaction as formatOmniTransactionBase, type OmniTransaction } from '@layerzerolabs/devtools'\nimport { getNetworkNameForEidMaybe } from '@/runtime'\n\nexport const formatOmniTransaction = (\n    transaction: OmniTransaction\n): Record<string, string | number | bigint | undefined> => ({\n    Network: getNetworkNameForEidMaybe(transaction.point.eid) ?? '[Not defined in hardhat config]',\n    ...formatOmniTransactionBase(transaction),\n})\n","import pMemoize from 'p-memoize'\nimport { formatEid, type EndpointBasedFactory, type OmniSignerFactory } from '@layerzerolabs/devtools'\nimport { GnosisOmniSignerEVM, OmniSignerEVM } from '@layerzerolabs/devtools-evm'\nimport { createProviderFactory } from '@/provider'\nimport { createGetHreByEid } from '@/runtime'\nimport { ConnectSafeConfigWithSafeAddress } from '@safe-global/protocol-kit'\nimport type { SignerDefinition } from '@layerzerolabs/devtools-evm'\nimport assert from 'assert'\n\nexport const createSignerFactory = (\n    definition?: SignerDefinition,\n    networkEnvironmentFactory = createGetHreByEid(),\n    providerFactory = createProviderFactory(networkEnvironmentFactory),\n    signerAddressorIndexFactory = createSignerAddressOrIndexFactory(definition, networkEnvironmentFactory)\n): OmniSignerFactory<OmniSignerEVM> => {\n    return pMemoize(async (eid) => {\n        const provider = await providerFactory(eid)\n        const addressOrIndex = await signerAddressorIndexFactory(eid)\n        const signer = provider.getSigner(addressOrIndex)\n\n        return new OmniSignerEVM(eid, signer)\n    })\n}\n\nexport const createGnosisSignerFactory = (\n    definition?: SignerDefinition,\n    networkEnvironmentFactory = createGetHreByEid(),\n    providerFactory = createProviderFactory(networkEnvironmentFactory),\n    signerAddressorIndexFactory = createSignerAddressOrIndexFactory(definition, networkEnvironmentFactory)\n): OmniSignerFactory<GnosisOmniSignerEVM<ConnectSafeConfigWithSafeAddress>> => {\n    return pMemoize(async (eid) => {\n        const provider = await providerFactory(eid)\n        const addressOrIndex = await signerAddressorIndexFactory(eid)\n        const signer = provider.getSigner(addressOrIndex)\n\n        const env = await networkEnvironmentFactory(eid)\n        const safeConfig = env.network.config.safeConfig\n        if (!safeConfig) {\n            throw new Error('No safe config found for the current network')\n        }\n        return new GnosisOmniSignerEVM<ConnectSafeConfigWithSafeAddress>(eid, signer, safeConfig.safeUrl, safeConfig)\n    })\n}\n\n/**\n * Factory for signer address/index for a specific eid.\n *\n * Will take an optional signer definition and either:\n *\n * - Return static signer address or index for static signer configuration\n * - Look up named signer account in hardhat config and return its address\n *\n * @param {SignerDefinition} [definition]\n * @param {EndpointBasedFactory<HardhatRuntimeEnvironment>} [networkEnvironmentFactory]\n * @returns\n */\nexport const createSignerAddressOrIndexFactory =\n    (\n        definition?: SignerDefinition,\n        networkEnvironmentFactory = createGetHreByEid()\n    ): EndpointBasedFactory<string | number | undefined> =>\n    async (eid) => {\n        // If there is no definition provided, we return nothing\n        if (definition == null) {\n            return undefined\n        }\n\n        // The hardcoded address and/or index definitions are easy,\n        // they need no resolution and can be used as they are\n        if (definition.type === 'address') {\n            return definition.address\n        }\n\n        if (definition.type === 'index') {\n            return definition.index\n        }\n\n        // The named definitions need to be resolved using hre\n        const hre = await networkEnvironmentFactory(eid)\n        const accounts = await hre.getNamedAccounts()\n        const account = accounts[definition.name]\n\n        assert(account != null, `Missing named account '${definition.name}' for eid ${formatEid(eid)}`)\n\n        return account\n    }\n"]}