import { EndpointId } from '@layerzerolabs/lz-definitions';
import { ConnectSafeConfigWithSafeAddress } from '@safe-global/protocol-kit';
import { AnvilOptions } from '@layerzerolabs/devtools-evm';

interface SimulationUserConfig {
    /**
     * Simulation works by creating local forks of networks specified
     * in hardhat config. These networks are containerized and not accessible
     * from the developer machine - instead, a simple proxy server
     * listening on this port proxies requests to the individual networks.
     *
     * For example, a hardhat configuration with networks `fuji` and `mainnet`
     * will result in two forks being created. These networks will then be accessible
     * on `http://localhost:<port>/fuji` and `http://localhost:<port>/mainnet`
     *
     * @default 8545
     */
    port?: number;
    /**
     * Simulation task stores its artifacts on the local filesystem.
     *
     * To customize the path, set this property to a relative or absolute path
     * (relative path will be resolved against the root path of your hardhat project)
     *
     * @default .layerzero
     */
    directory?: string;
    /**
     * Simulation will by default overwrite the network accounts by values
     * provided in Anvil config (or defaults if not present).
     *
     * The mnemonic will default to "test test test test test test test test test test test junk"
     * and the number of funded accounts to 10.
     *
     * @default true
     */
    overwriteAccounts?: boolean;
    /**
     * Anvil overrides for the underlying EVM nodes.
     */
    anvil?: SimulationAnvilUserConfig;
}
/**
 * Resolved simulation config
 */
interface SimulationConfig {
    port: number;
    directory: string;
    overwriteAccounts: boolean;
    anvil: SimulationAnvilConfig;
}
/**
 * Resolved simulation config for anvil.
 *
 * This config is created by taking the user config
 * and applying defaults.
 */
type SimulationAnvilConfig = AnvilOptions & {
    mnemonic: NonNullable<AnvilOptions['mnemonic']>;
};
/**
 * User facing simulation config for anvil.
 *
 * This config cannot override several system attributes for anvil
 * (since it would not really make sense seeing that anvil is being run in containers):
 *
 * - host & port: this would break the docker port bindings
 * - state: state is kept within the container and is not accessible from the outside
 * - forkUrl: this is set based on the hardhat config and points to the hardhat network url
 */
type SimulationAnvilUserConfig = Omit<AnvilOptions, 'host' | 'port' | 'state' | 'forkUrl'>;

/**
 * Packages containing external artifacts can be specified either
 *
 * - By just their package name, in which case the artifacts will be loaded from the `./artifacts` path
 * - By their package name and a specific path to the artifacts directory
 * - By a filesystem path
 */
type ArtifactPackage = ArtifactPackageName | ArtifactPackageWithPath | ArtifactPackagePath;
type ArtifactPackageName = string;
interface ArtifactPackageWithPath {
    name: ArtifactPackageName;
    path?: string;
}
interface ArtifactPackagePath {
    name?: never;
    path: string;
}
declare module 'hardhat/types/config' {
    interface HardhatNetworkUserConfig {
        eid?: never;
        safeConfig?: never;
    }
    interface HardhatNetworkConfig {
        eid?: never;
        safeConfig?: never;
    }
    interface HttpNetworkUserConfig {
        /**
         * Specifies the mapping between the network
         * defined in your hardhat config and the LayerZero endpoint ID
         * on this network.
         *
         * This allows you to use arbitrary network names while maintaining
         * allowing you to easily find deployment and artifact information
         * for LayerZero protocol contracts using the standard hardhat deploy methods
         */
        eid?: EndpointId;
        /**
         * Use a "local" LayerZero environment for the network.
         *
         * Local environments are postfixed with `-local` in the deployment directories
         * and represent contracts deployed to ephemerous development networks.
         *
         * Local environments cannot coexists with their non-local counterparts
         * in hardhat configs since they share the same `eid`
         */
        isLocalEid?: boolean;
        /**
         * Optional gnosis safe config.
         */
        safeConfig?: SafeConfig;
    }
    interface HttpNetworkConfig {
        /**
         * Specifies the mapping between the network
         * defined in your hardhat config and the LayerZero endpoint ID
         * on this network.
         *
         * This allows you to use arbitrary network names while maintaining
         * allowing you to easily find deployment and artifact information
         * for LayerZero protocol contracts using the standard hardhat deploy methods
         */
        eid?: EndpointId;
        /**
         * Use a "local" LayerZero environment for the network.
         *
         * Local environments are postfixed with `-local` in the deployment directories
         * and represent contracts deployed to ephemerous development networks
         *
         * Local environments cannot coexists with their non-local counterparts
         * in hardhat configs since they share the same `eid`
         */
        isLocalEid?: boolean;
        /**
         * Optional gnosis safe config.
         */
        safeConfig?: SafeConfig;
    }
    interface SafeConfig extends ConnectSafeConfigWithSafeAddress {
        safeUrl: string;
        safeAddress: string;
    }
    interface HardhatUserConfig {
        /**
         * LayerZero advanced configuration
         */
        layerZero?: LayerZeroHardhatUserConfig;
    }
    interface LayerZeroHardhatUserConfig {
        /**
         * Defines the names of @layerzerolabs packages
         * that will be added to your hardhat config under external deployments.
         *
         * By default, the protocol deployments from `@layerzerolabs/lz-evm-sdk-v2`
         * will be added which allows your scripts to reference deployments
         * of protocol contracts such as `EndpointV2`:
         *
         * ```
         * // In your deploy script or task
         * const { address, abi } = hre.deployments.get('EndpointV2')
         * ```
         *
         * @default ['@layerzerolabs/lz-evm-sdk-v2']
         */
        deploymentSourcePackages?: string[];
        /**
         * Defines the names of @layerzerolabs packages
         * that will be added to your hardhat config under external artifacts.
         *
         * By default, the protocol artifacts from `@layerzerolabs/lz-evm-sdk-v2`
         * will be added which allows your scripts to reference artifacts
         * of protocol contracts such as `EndpointV2`:
         *
         * ```
         * // In your deploy script or task
         * const { address, abi } = hre.deployments.get('EndpointV2')
         * ```
         *
         * For testing purposes, artifacts from `@layerzerolabs/test-devtools-evm-hardhat`
         * will also be added. This allows your tests to reference contracts such as `EndpointV2Mock`:
         *
         * ```
         * // In your hardhat test
         * const EndpointV2MockArtifact = await hre.deployments.getArtifact('EndpointV2Mock')
         * ```
         *
         * @default ['@layerzerolabs/lz-evm-sdk-v2','@layerzerolabs/test-devtools-evm-hardhat']
         */
        artifactSourcePackages?: ArtifactPackage[];
        /**
         * Configuration of features that are not considered stable yet
         */
        experimental?: {
            /**
             * Configuration for omnichain simulation
             *
             * Omnichain simulation allows developers to easily setup
             * local environment forked from live networks without
             * having to adjust the `hardhat.config.ts` file
             */
            simulation?: SimulationUserConfig;
        };
    }
}

export type { ArtifactPackage as A, SimulationConfig as S, SimulationUserConfig as a, SimulationAnvilConfig as b, SimulationAnvilUserConfig as c, ArtifactPackageName as d, ArtifactPackageWithPath as e, ArtifactPackagePath as f };
