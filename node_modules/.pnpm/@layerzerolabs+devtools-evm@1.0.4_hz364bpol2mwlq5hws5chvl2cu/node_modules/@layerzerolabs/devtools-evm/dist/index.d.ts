import { OmniAddress, WithEid, OmniPoint, Factory, IOmniSDK as IOmniSDK$1, EndpointBasedFactory, OmniTransaction, RpcUrlFactory, OmniSignerBase, OmniSigner, OmniTransactionResponse } from '@layerzerolabs/devtools';
export { RpcUrlFactory } from '@layerzerolabs/devtools';
import { isAddress } from '@ethersproject/address';
import { Contract } from '@ethersproject/contracts';
import { LogDescription } from '@ethersproject/abi';
import { TransactionReceipt, BaseProvider, JsonRpcProvider } from '@ethersproject/providers';
import { Logger } from '@layerzerolabs/io-devtools';
import { z } from 'zod';
import { BigNumberish, BigNumber } from '@ethersproject/bignumber/lib/bignumber';
import { TransactionReceipt as TransactionReceipt$1 } from '@ethersproject/abstract-provider';
import { Signer } from '@ethersproject/abstract-signer';
import Safe, { ConnectSafeConfig, EthersAdapter } from '@safe-global/protocol-kit';
import SafeApiKit from '@safe-global/api-kit';
import { EndpointId } from '@layerzerolabs/lz-definitions';

/**
 * Turns a nullish value (`null` or `undefined`) into a zero address
 *
 * @param {OmniAddress | null | undefined} address
 *
 * @returns {string}
 */
declare const makeZeroAddress: (address?: OmniAddress | null | undefined) => string;
/**
 * Applies checksum to a given address, lower/uppercasing
 * necessary characters
 *
 * @param {OmniAddress} address
 * @returns {OmniAddress}
 */
declare const addChecksum: (address: OmniAddress) => OmniAddress;
/**
 * Re-export of `isAddress` from `@ethersporject/address`
 *
 * @param {OmniAddress} address
 * @returns {boolean}
 */
declare const isEVMAddress: typeof isAddress;

declare abstract class ContractError<TReason = unknown> extends Error {
    abstract readonly reason: TReason;
}
declare class UnknownError extends ContractError<undefined> {
    readonly reason: undefined;
    constructor(message?: string);
}
declare class PanicError extends ContractError<bigint> {
    readonly reason: bigint;
    constructor(reason: bigint, message?: string);
    toString(): string;
}
declare class RevertError extends ContractError<string> {
    readonly reason: string;
    constructor(reason: string, message?: string);
    toString(): string;
}
declare class CustomError extends ContractError<string> {
    readonly reason: string;
    readonly args: unknown[];
    constructor(reason: string, args: unknown[], message?: string);
    toString(): string;
}

type OmniContract<TContract extends Contract = Contract> = WithEid<{
    contract: TContract;
}>;
type OmniContractFactory<TOmniPoint = OmniPoint> = Factory<[TOmniPoint], OmniContract>;
/**
 * Base interface for all EVM SDKs, adding the EVM specific attributes
 */
interface IOmniSDK extends IOmniSDK$1 {
    contract: OmniContract;
}

type OmniContractErrorParser = Factory<[error: unknown], ContractError>;
type OmniContractErrorParserFactory = Factory<[
    contract: OmniContract | null | undefined
], OmniContractErrorParser>;

/**
 * Creates an error parser based on a specific `OmniContract`
 *
 * This call will never fail and will always return an instance of `ContractError`
 *
 * @param {OmniContract | null | undefined} contract
 * @returns {OmniContractErrorParser}
 */
declare const createContractErrorParser: OmniContractErrorParserFactory;
declare const parseContractError: (error: unknown, contract: Contract) => ContractError | undefined;
declare const parseGenericError: (error: unknown) => ContractError | undefined;

/**
 * Parse event logs.
 * @param {TransactionReceipt} receipt
 * @param {Contract} contract
 * @returns {LogDescription[]}
 */
declare const parseLogs: (receipt: TransactionReceipt, contract: Contract) => LogDescription[];
/**
 * Parse event logs with a specific name.
 * @param {TransactionReceipt} receipt
 * @param {Contract} contract
 * @param {string} name
 * @returns {LogDescription[]}
 */
declare const parseLogsWithName: (receipt: TransactionReceipt, contract: Contract, name: string) => LogDescription[];

type Provider = BaseProvider;

type ProviderFactory<TProvider extends Provider = Provider> = EndpointBasedFactory<TProvider>;

declare const omniContractToPoint: ({ eid, contract }: OmniContract) => OmniPoint;
declare const connectOmniContract: ({ eid, contract }: OmniContract, provider: Provider) => OmniContract;

declare const formatOmniContract: (contract: OmniContract) => string;

/**
 * Base class for all EVM SDKs, providing some common functionality
 * to reduce the boilerplate
 */
declare abstract class OmniSDK implements IOmniSDK {
    readonly contract: OmniContract;
    protected readonly logger: Logger;
    static errorParserFactory: OmniContractErrorParserFactory;
    /**
     * Registers a `OmniContractErrorParserFactory` function to be used when
     * an SDK needs to get an instance of `OmniContractErrorParser`.
     *
     * This enables us to use environment-specific error parsers
     * while maintaining separation of concerns. For example, `hardhat`-specific
     * environments can create error parsers based on all available errors from the build artifacts.
     *
     * @param {OmniContractErrorParserFactory | undefined} factory
     * @returns {void}
     */
    static registerErrorParserFactory(factory: OmniContractErrorParserFactory | undefined): void;
    /**
     * Creates an instance of `OmniContractErrorParser` based on the registered
     * `OmniContractErrorParserFactory`
     *
     * @param {OmniContract | null | undefined} contract
     * @returns {OmniContractErrorParser}
     */
    static createErrorParser(contract: OmniContract | null | undefined): OmniContractErrorParser | Promise<OmniContractErrorParser>;
    constructor(contract: OmniContract, logger?: Logger);
    /**
     * Human radable label for this SDK
     */
    get label(): string;
    get point(): OmniPoint;
    protected createTransaction(data: string): OmniTransaction;
    protected parseError(error: unknown): Promise<ContractError>;
}

declare const createProviderFactory: (urlFactory: RpcUrlFactory) => ProviderFactory<JsonRpcProvider>;

declare const BigNumberishSchema: z.ZodType<BigNumberish, z.ZodTypeDef, BigNumberish>;
declare const BigNumberishBigIntSchema: z.ZodEffects<z.ZodEffects<z.ZodType<BigNumberish, z.ZodTypeDef, BigNumberish>, BigNumber, BigNumberish>, bigint, BigNumberish>;
declare const BigNumberishNumberSchema: z.ZodEffects<z.ZodEffects<z.ZodType<BigNumberish, z.ZodTypeDef, BigNumberish>, BigNumber, BigNumberish>, number, BigNumberish>;

declare abstract class OmniSignerEVMBase extends OmniSignerBase implements OmniSigner {
    readonly signer: Signer;
    protected constructor(eid: EndpointId, signer: Signer);
    getPoint(): Promise<OmniPoint>;
}
/**
 * Implements an OmniSigner interface for EVM-compatible chains
 */
declare class OmniSignerEVM extends OmniSignerEVMBase {
    #private;
    constructor(eid: EndpointId, signer: Signer);
    sign(transaction: OmniTransaction): Promise<string>;
    signAndSend(transaction: OmniTransaction): Promise<OmniTransactionResponse<TransactionReceipt$1>>;
}
/**
 * Implements an OmniSigner interface for EVM-compatible chains using Gnosis Safe.
 */
declare class GnosisOmniSignerEVM<TSafeConfig extends ConnectSafeConfig> extends OmniSignerEVMBase {
    #private;
    protected readonly safeUrl: string;
    protected readonly safeConfig: TSafeConfig;
    protected readonly ethAdapter: EthersAdapter;
    protected readonly apiKit: SafeApiKit;
    protected readonly safeSdkPromise: Safe | Promise<Safe>;
    constructor(eid: EndpointId, signer: Signer, safeUrl: string, safeConfig: TSafeConfig, ethAdapter?: EthersAdapter, apiKit?: SafeApiKit, safeSdkPromise?: Safe | Promise<Safe>);
    sign(_: OmniTransaction): Promise<string>;
    signAndSend(transaction: OmniTransaction): Promise<OmniTransactionResponse>;
    signAndSendBatch(transactions: OmniTransaction[]): Promise<OmniTransactionResponse>;
}

interface SignerIndex {
    type: 'index';
    address?: never;
    index: number;
    name?: never;
}
interface SignerAddress {
    type: 'address';
    address: OmniAddress;
    index?: never;
    name?: never;
}
interface SignerName {
    type: 'named';
    address?: never;
    index?: never;
    name: string;
}
type SignerDefinition = SignerIndex | SignerAddress | SignerName;

interface AnvilOptions {
    host?: string;
    port?: number;
    mnemonic?: string;
    count?: number;
    derivationPath?: string;
    forkUrl?: string;
    forkBlockNumber?: number;
    retries?: number;
    timeout?: number;
    blockTime?: number;
    state?: string;
    stateInterval?: number;
    pruneHistory?: boolean;
}
/**
 * Creates a list of CLI arguments for `anvil` command
 * to be used with e.g. `spawn` command
 *
 * @param {AnvilOptions} options
 * @returns {string[]} `anvil` CLI arguments
 */
declare const createAnvilCliOptions: ({ host, port, mnemonic, forkUrl, forkBlockNumber, retries, timeout, blockTime, count, derivationPath, state, stateInterval, pruneHistory, }: AnvilOptions) => string[];

export { type AnvilOptions, BigNumberishBigIntSchema, BigNumberishNumberSchema, BigNumberishSchema, ContractError, CustomError, GnosisOmniSignerEVM, type IOmniSDK, type OmniContract, type OmniContractFactory, OmniSDK, OmniSignerEVM, OmniSignerEVMBase, PanicError, type Provider, type ProviderFactory, RevertError, type SignerAddress, type SignerDefinition, type SignerIndex, type SignerName, UnknownError, addChecksum, connectOmniContract, createAnvilCliOptions, createContractErrorParser, createProviderFactory, formatOmniContract, isEVMAddress, makeZeroAddress, omniContractToPoint, parseContractError, parseGenericError, parseLogs, parseLogsWithName };
