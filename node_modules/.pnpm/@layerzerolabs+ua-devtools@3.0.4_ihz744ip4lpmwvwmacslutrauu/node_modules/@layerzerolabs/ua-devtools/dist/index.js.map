{"version":3,"sources":["../src/lzapp/config.ts","../src/oapp/check.ts","../src/oapp/config.ts","../src/oapp/schema.ts","../src/ownable/schema.ts","../src/ownable/config.ts","../src/oapp-read/config.ts","../src/oapp-read/schema.ts","../src/oapp-read/check.ts","../src/read/commandResolver/sdk.ts","../src/read/errors.ts","../src/read/timeMarker-utils.ts","../src/read/timeMarkerResolver/sdk.ts","../src/read/timeMarkerValidator/sdk.ts"],"names":["formatOmniVector","createConfigureMultiple","createModuleLogger","printBoolean","ExecutorOptionType","config","z","AddressSchema","flattenTransactions","formatOmniPoint","createConfigureNodes","createWithAsyncLogger","assert","Options","enforcedOptionsReducer","createOmniEdgeSchema","createOmniGraphSchema","createOmniNodeSchema","UIntNumberSchema","ComputeType","ResolverType"],"mappings":"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","sourcesContent":["import {\n    flattenTransactions,\n    formatOmniVector,\n    type OmniTransaction,\n    createConfigureMultiple,\n} from '@layerzerolabs/devtools'\nimport { LzAppConfigurator } from './types'\nimport { createModuleLogger, printBoolean } from '@layerzerolabs/io-devtools'\n\nexport const configureLzAppTrustedRemotes: LzAppConfigurator = async (graph, createSdk) => {\n    const logger = createModuleLogger('LzApp')\n\n    return flattenTransactions(\n        await Promise.all(\n            graph.connections.map(async ({ vector: { from, to } }): Promise<OmniTransaction[]> => {\n                logger.verbose(`Checking connection ${formatOmniVector({ from, to })}`)\n\n                const sdk = await createSdk(from)\n                const hasPeer = await sdk.hasTrustedRemote(to.eid, to.address)\n\n                logger.verbose(`Checked connection ${formatOmniVector({ from, to })}: ${printBoolean(hasPeer)}`)\n                if (hasPeer) {\n                    return []\n                }\n\n                logger.verbose(`Creating a connection ${formatOmniVector({ from, to })}`)\n                return [await sdk.setTrustedRemote(to.eid, to.address)]\n            })\n        )\n    )\n}\n\nexport const configureLzApp: LzAppConfigurator = createConfigureMultiple(configureLzAppTrustedRemotes)\n","import { EncodedOption, OAppEnforcedOptions, OAppFactory, OAppOmniGraph, OAppPeers } from '@/oapp/types'\nimport { ExecutorOptionType } from '@layerzerolabs/lz-v2-utilities'\n\nexport type OAppCheckPeers = (graph: OAppOmniGraph, createSdk: OAppFactory) => Promise<OAppPeers[]>\nexport type OAppCheckEnforcedOptions = (graph: OAppOmniGraph, createSdk: OAppFactory) => Promise<OAppEnforcedOptions[]>\n\nconst EnforcedOptions: ExecutorOptionType[] = [\n    ExecutorOptionType.LZ_RECEIVE,\n    ExecutorOptionType.NATIVE_DROP,\n    ExecutorOptionType.COMPOSE,\n    ExecutorOptionType.ORDERED,\n    ExecutorOptionType.LZ_READ,\n]\n\nexport const checkOAppPeers: OAppCheckPeers = async (graph, createSdk): Promise<OAppPeers[]> => {\n    return await Promise.all(\n        graph.connections.map(async ({ vector }): Promise<OAppPeers> => {\n            const sdk = await createSdk(vector.from)\n            const hasPeer = await sdk.hasPeer(vector.to.eid, vector.to.address)\n            return { vector: vector, hasPeer }\n        })\n    )\n}\n\nexport const checkOAppEnforcedOptions: OAppCheckEnforcedOptions = async (\n    graph,\n    createSdk\n): Promise<OAppEnforcedOptions[]> => {\n    return await Promise.all(\n        graph.connections.map(async ({ vector }): Promise<OAppEnforcedOptions> => {\n            const enforcedOptionsRead: EncodedOption[] = []\n            const oappSdk = await createSdk(vector.from)\n            for (const enforcedOption of EnforcedOptions) {\n                enforcedOptionsRead.push({\n                    msgType: enforcedOption,\n                    options: await oappSdk.getEnforcedOptions(vector.to.eid, enforcedOption),\n                })\n            }\n            return { vector: vector, enforcedOptions: enforcedOptionsRead }\n        })\n    )\n}\n","import {\n    type Bytes,\n    formatOmniVector,\n    isDeepEqual,\n    type OmniAddress,\n    OmniPointMap,\n    type OmniTransaction,\n    formatOmniPoint,\n    createConfigureMultiple,\n    createConfigureNodes,\n    createConfigureEdges,\n} from '@layerzerolabs/devtools'\nimport type { OAppConfigurator, OAppEnforcedOption, OAppEnforcedOptionParam, OAppFactory } from './types'\nimport { createModuleLogger, createWithAsyncLogger, printBoolean } from '@layerzerolabs/io-devtools'\nimport { Uln302ConfigType, type SetConfigParam } from '@layerzerolabs/protocol-devtools'\nimport assert from 'assert'\nimport { ExecutorOptionType, Options } from '@layerzerolabs/lz-v2-utilities'\n\nconst createOAppLogger = () => createModuleLogger('OApp')\nconst withOAppLogger = createWithAsyncLogger(createOAppLogger)\n\nexport const configureOAppDelegates: OAppConfigurator = withOAppLogger(\n    createConfigureNodes(\n        withOAppLogger(\n            async ({ config, point }, sdk) => {\n                const logger = createOAppLogger()\n                const label = formatOmniPoint(point)\n\n                // Don't do anything if delegate is not set\n                if (config?.delegate == null) {\n                    return logger.verbose(`Delegate not set for ${label}, skipping`), []\n                }\n\n                const isDelegate = await sdk.isDelegate(config.delegate)\n\n                logger.verbose(`Delegate ${config.delegate} set for ${label}: ${printBoolean(isDelegate)}`)\n                if (isDelegate) {\n                    return logger.verbose(`Delegate ${config.delegate} already set for ${label}`), []\n                }\n\n                logger.verbose(`Setting delegate ${config.delegate} for ${label}`)\n                return [await sdk.setDelegate(config.delegate)]\n            },\n            {\n                onStart: (logger, [{ point }]) =>\n                    logger.verbose(`Checking OApp delegate configuration for ${formatOmniPoint(point)}`),\n                onSuccess: (logger, [{ point }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked OApp delegate for ${formatOmniPoint(point)}`),\n                onError: (logger, [{ point }], error) =>\n                    logger.error(`Failed to check OApp delegate for ${formatOmniPoint(point)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking OApp delegates configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp delegates`),\n    }\n)\n\nexport const configureOAppPeers: OAppConfigurator = withOAppLogger(\n    createConfigureEdges(\n        withOAppLogger(\n            async ({ vector: { from, to } }, sdk): Promise<OmniTransaction[]> => {\n                const logger = createOAppLogger()\n\n                logger.verbose(`Checking connection ${formatOmniVector({ from, to })}`)\n\n                const hasPeer = await sdk.hasPeer(to.eid, to.address)\n\n                logger.verbose(`Checked connection ${formatOmniVector({ from, to })}: ${printBoolean(hasPeer)}`)\n                if (hasPeer) {\n                    return []\n                }\n\n                logger.verbose(`Creating a connection ${formatOmniVector({ from, to })}`)\n                return [await sdk.setPeer(to.eid, to.address)]\n            },\n            {\n                onStart: (logger, [{ vector }]) =>\n                    logger.verbose(`Checking OApp peers for ${formatOmniVector(vector)}`),\n                onSuccess: (logger, [{ vector }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked OApp peers for ${formatOmniVector(vector)}`),\n                onError: (logger, [{ vector }], error) =>\n                    logger.error(`Failed to check OApp peers for ${formatOmniVector(vector)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking OApp peers configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp peers configuration`),\n    }\n)\n\nexport const configureSendLibraries: OAppConfigurator = withOAppLogger(\n    createConfigureEdges(\n        withOAppLogger(\n            async ({ vector: { from, to }, config }, sdk): Promise<OmniTransaction[]> => {\n                const logger = createOAppLogger()\n\n                if (!config?.sendLibrary) {\n                    logger.verbose(`sendLibrary configuration not set for ${formatOmniVector({ from, to })}, skipping`)\n                    return []\n                }\n\n                const endpointSdk = await sdk.getEndpointSDK()\n                const isDefaultLibrary = await endpointSdk.isDefaultSendLibrary(from.address, to.eid)\n                const currentSendLibrary = await endpointSdk.getSendLibrary(from.address, to.eid)\n\n                if (!isDefaultLibrary && currentSendLibrary === config.sendLibrary) {\n                    logger.verbose(\n                        `Current sendLibrary is not default library and is already set to ${config.sendLibrary} for ${formatOmniVector({ from, to })}, skipping`\n                    )\n                    return []\n                }\n\n                logger.verbose(`Setting sendLibrary ${config.sendLibrary} for ${formatOmniVector({ from, to })}`)\n                return [await endpointSdk.setSendLibrary(from.address, to.eid, config.sendLibrary)]\n            },\n            {\n                onStart: (logger, [{ vector }]) =>\n                    logger.verbose(`Checking send libraries for ${formatOmniVector(vector)}`),\n                onSuccess: (logger, [{ vector }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked send libraries for ${formatOmniVector(vector)}`),\n                onError: (logger, [{ vector }], error) =>\n                    logger.error(`Failed to check send libraries for ${formatOmniVector(vector)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking send libraries configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked send libraries configuration`),\n    }\n)\n\nexport const configureReceiveLibraries: OAppConfigurator = withOAppLogger(\n    createConfigureEdges(\n        withOAppLogger(\n            async ({ vector: { from, to }, config }, sdk): Promise<OmniTransaction[]> => {\n                const logger = createOAppLogger()\n\n                if (config?.receiveLibraryConfig == null) {\n                    logger.verbose(`receiveLibraryConfig not set for ${formatOmniVector({ from, to })}, skipping`)\n                    return []\n                }\n\n                const endpointSdk = await sdk.getEndpointSDK()\n                const [currentReceiveLibrary, isDefaultLibrary] = await endpointSdk.getReceiveLibrary(\n                    from.address,\n                    to.eid\n                )\n\n                if (!isDefaultLibrary && currentReceiveLibrary === config.receiveLibraryConfig.receiveLibrary) {\n                    logger.verbose(\n                        `Current recieveLibrary is not default and is already set to ${config.receiveLibraryConfig.receiveLibrary} for ${formatOmniVector({ from, to })}, skipping`\n                    )\n                    return []\n                }\n\n                logger.verbose(\n                    `Setting recieveLibrary ${config.receiveLibraryConfig.receiveLibrary} for ${formatOmniVector({ from, to })}`\n                )\n\n                return [\n                    await endpointSdk.setReceiveLibrary(\n                        from.address,\n                        to.eid,\n                        config.receiveLibraryConfig.receiveLibrary,\n                        config.receiveLibraryConfig.gracePeriod\n                    ),\n                ]\n            },\n            {\n                onStart: (logger, [{ vector }]) =>\n                    logger.verbose(`Checking receive libraries for ${formatOmniVector(vector)}`),\n                onSuccess: (logger, [{ vector }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked receive libraries for ${formatOmniVector(vector)}`),\n                onError: (logger, [{ vector }], error) =>\n                    logger.error(`Failed to check receive libraries for ${formatOmniVector(vector)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking receive libraries configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked receive libraries configuration`),\n    }\n)\n\nexport const configureReceiveLibraryTimeouts: OAppConfigurator = withOAppLogger(\n    createConfigureEdges(\n        withOAppLogger(\n            async ({ vector: { from, to }, config }, sdk): Promise<OmniTransaction[]> => {\n                const logger = createOAppLogger()\n\n                if (config?.receiveLibraryTimeoutConfig == null) {\n                    logger.verbose(\n                        `receiveLibraryTimeoutConfig not set for ${formatOmniVector({ from, to })}, skipping`\n                    )\n                    return []\n                }\n\n                const { receiveLibraryTimeoutConfig } = config\n\n                const endpointSdk = await sdk.getEndpointSDK()\n                const timeout = await endpointSdk.getReceiveLibraryTimeout(from.address, to.eid)\n\n                if (isDeepEqual(timeout, receiveLibraryTimeoutConfig)) {\n                    logger.verbose(\n                        `Current timeout for ${receiveLibraryTimeoutConfig.lib} is already set to ${receiveLibraryTimeoutConfig.expiry} for ${formatOmniVector({ from, to })}, skipping`\n                    )\n                    return []\n                }\n\n                logger.verbose(\n                    `Setting timeout for ${receiveLibraryTimeoutConfig.lib} to ${receiveLibraryTimeoutConfig.expiry} for ${formatOmniVector({ from, to })}`\n                )\n\n                return [\n                    await endpointSdk.setReceiveLibraryTimeout(\n                        from.address,\n                        to.eid,\n                        receiveLibraryTimeoutConfig.lib,\n                        receiveLibraryTimeoutConfig.expiry\n                    ),\n                ]\n            },\n            {\n                onStart: (logger, [{ vector }]) =>\n                    logger.verbose(`Checking receive library timeouts for ${formatOmniVector(vector)}`),\n                onSuccess: (logger, [{ vector }]) =>\n                    logger.verbose(\n                        `${printBoolean(true)} Checked receive library timeouts for ${formatOmniVector(vector)}`\n                    ),\n                onError: (logger, [{ vector }], error) =>\n                    logger.error(`Failed to check receive library timeouts for ${formatOmniVector(vector)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking receive library timeout configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked receive library timeout configuration`),\n    }\n)\n\nexport const configureSendConfig: OAppConfigurator = withOAppLogger(\n    async (graph, createSdk) => {\n        const logger = createOAppLogger()\n\n        // This function builds a map to find all SetConfigParam[] to execute for a given OApp and SendLibrary\n        const setConfigsByEndpointAndLibrary: OmniPointMap<Map<OmniAddress, SetConfigParam[]>> = new OmniPointMap()\n\n        for (const {\n            vector: { from, to },\n            config,\n        } of graph.connections) {\n            const connectionName = formatOmniVector({ from, to })\n\n            if (config?.sendConfig?.executorConfig == null && config?.sendConfig?.ulnConfig == null) {\n                logger.verbose(`executorConfig and ulnConfig not set for ${connectionName}, skipping`)\n                continue\n            }\n\n            const oappSdk = await createSdk(from)\n            const endpointSdk = await oappSdk.getEndpointSDK()\n            const currentSendLibrary = config.sendLibrary ?? (await endpointSdk.getSendLibrary(from.address, to.eid))\n            assert(\n                currentSendLibrary !== undefined,\n                'sendLibrary has not been set in your config and no default value exists'\n            )\n\n            if (config.sendConfig.executorConfig != null) {\n                // We ask the endpoint SDK whether this config has already been applied\n                //\n                // We need to ask not for the final config formed of the default config and the app config,\n                // we only need to check the app config\n                const hasExecutorConfig = await endpointSdk.hasAppExecutorConfig(\n                    from.address,\n                    currentSendLibrary,\n                    to.eid,\n                    config.sendConfig.executorConfig\n                )\n\n                logger.verbose(\n                    `Checked executor configuration for ${connectionName}: ${printBoolean(hasExecutorConfig)}`\n                )\n\n                if (!hasExecutorConfig) {\n                    const newSetConfigs: SetConfigParam[] = await endpointSdk.getExecutorConfigParams(\n                        currentSendLibrary,\n                        [{ eid: to.eid, executorConfig: config.sendConfig.executorConfig }]\n                    )\n\n                    // Updates map with nw configs for that OApp and Send Library\n                    const setConfigsByLibrary = setConfigsByEndpointAndLibrary.getOrElse(from, () => new Map())\n                    const existingSetConfigs = setConfigsByLibrary.get(currentSendLibrary) ?? []\n                    setConfigsByEndpointAndLibrary.set(\n                        from,\n                        setConfigsByLibrary.set(currentSendLibrary, [...existingSetConfigs, ...newSetConfigs])\n                    )\n\n                    const updatedConfigList =\n                        setConfigsByEndpointAndLibrary.getOrElse(from, () => new Map()).get(currentSendLibrary) ?? []\n                    const updatedConfigListCsv = updatedConfigList\n                        .map(({ configType, config }) => `{configType: ${configType}, config: ${config}}`)\n                        .join(', ')\n\n                    logger.verbose(`Set executor configuration ${updatedConfigListCsv} for ${connectionName}`)\n                }\n            }\n\n            if (config.sendConfig.ulnConfig != null) {\n                // We ask the endpoint SDK whether this config has already been applied\n                //\n                // We need to ask not for the final config formed of the default config and the app config,\n                // we only need to check the app config\n                const hasUlnConfig = await endpointSdk.hasAppUlnConfig(\n                    from.address,\n                    currentSendLibrary,\n                    to.eid,\n                    config.sendConfig.ulnConfig,\n                    Uln302ConfigType.Send\n                )\n\n                logger.verbose(\n                    `Checked ULN configuration for ${formatOmniVector({ from, to })}: ${printBoolean(hasUlnConfig)}`\n                )\n\n                if (!hasUlnConfig) {\n                    const newSetConfigs: SetConfigParam[] = await endpointSdk.getUlnConfigParams(currentSendLibrary, [\n                        { eid: to.eid, ulnConfig: config.sendConfig.ulnConfig, type: Uln302ConfigType.Send },\n                    ])\n\n                    // Updates map with new configs for that OApp and Send Library\n                    const setConfigsByLibrary = setConfigsByEndpointAndLibrary.getOrElse(from, () => new Map())\n                    const existingSetConfigs = setConfigsByLibrary.get(currentSendLibrary) ?? []\n                    setConfigsByEndpointAndLibrary.set(\n                        from,\n                        setConfigsByLibrary.set(currentSendLibrary, [...existingSetConfigs, ...newSetConfigs])\n                    )\n\n                    const updatedConfigList =\n                        setConfigsByEndpointAndLibrary.getOrElse(from, () => new Map()).get(currentSendLibrary) ?? []\n                    const updatedConfigListCsv = updatedConfigList\n                        .map(({ configType, config }) => `{configType: ${configType}, config: ${config}}`)\n                        .join(', ')\n                    logger.verbose(\n                        `Set ULN configuration ${updatedConfigListCsv} for ${formatOmniVector({ from, to })}`\n                    )\n                }\n            }\n        }\n\n        // This function iterates over the map (OApp -> SendLibrary -> SetConfigParam[]) to execute setConfig\n        return buildOmniTransactions(setConfigsByEndpointAndLibrary, createSdk)\n    },\n    {\n        onStart: (logger) => logger.info(`Checking send configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked send configuration`),\n    }\n)\n\nexport const configureReceiveConfig: OAppConfigurator = withOAppLogger(\n    async (graph, createSdk) => {\n        const logger = createOAppLogger()\n\n        // This function builds a map to find all SetConfigParam[] to execute for a given OApp and ReceiveLibrary\n        const setConfigsByEndpointAndLibrary: OmniPointMap<Map<OmniAddress, SetConfigParam[]>> = new OmniPointMap()\n        for (const {\n            vector: { from, to },\n            config,\n        } of graph.connections) {\n            const connectionName = formatOmniVector({ from, to })\n\n            if (config?.receiveConfig?.ulnConfig == null) {\n                logger.verbose(`ULN receive config not set for ${connectionName}, skipping`)\n                continue\n            }\n\n            const oappSdk = await createSdk(from)\n            const endpointSdk = await oappSdk.getEndpointSDK()\n            const [currentReceiveLibrary] = config?.receiveLibraryConfig?.receiveLibrary\n                ? [config.receiveLibraryConfig?.receiveLibrary, false]\n                : await endpointSdk.getReceiveLibrary(from.address, to.eid)\n            assert(\n                currentReceiveLibrary !== undefined,\n                `${connectionName}: receiveLibrary has not been set in your config and no default value exists`\n            )\n\n            // We ask the endpoint SDK whether this config has already been applied\n            //\n            // We need to ask not for the final config formed of the default config and the app config,\n            // we only need to check the app config\n            const hasUlnConfig = await endpointSdk.hasAppUlnConfig(\n                from.address,\n                currentReceiveLibrary,\n                to.eid,\n                config.receiveConfig.ulnConfig,\n                Uln302ConfigType.Receive\n            )\n\n            logger.verbose(`Checked ULN receive configuration for ${connectionName}: ${printBoolean(hasUlnConfig)}`)\n\n            if (!hasUlnConfig) {\n                const newSetConfigs: SetConfigParam[] = await endpointSdk.getUlnConfigParams(currentReceiveLibrary, [\n                    { eid: to.eid, ulnConfig: config.receiveConfig.ulnConfig, type: Uln302ConfigType.Receive },\n                ])\n\n                // Updates map with new configs for that OApp and Receive Library\n                const setConfigsByLibrary = setConfigsByEndpointAndLibrary.getOrElse(from, () => new Map())\n                const existingSetConfigs = setConfigsByLibrary.get(currentReceiveLibrary) ?? []\n                setConfigsByEndpointAndLibrary.set(\n                    from,\n                    setConfigsByLibrary.set(currentReceiveLibrary, [...existingSetConfigs, ...newSetConfigs])\n                )\n\n                const updatedConfigList =\n                    setConfigsByEndpointAndLibrary.getOrElse(from, () => new Map()).get(currentReceiveLibrary) ?? []\n                const updatedConfigListCsv = updatedConfigList\n                    .map(({ configType, config }) => `{configType: ${configType}, config: ${config}}`)\n                    .join(', ')\n\n                logger.verbose(`Set ULN receive configuration ${updatedConfigListCsv} for ${connectionName}`)\n            }\n        }\n\n        // This function iterates over the map (OApp -> ReceiveLibrary -> SetConfigParam[]) to execute setConfig\n        return buildOmniTransactions(setConfigsByEndpointAndLibrary, createSdk)\n    },\n    {\n        onStart: (logger) => logger.info(`Checking receive configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked receive configuration`),\n    }\n)\n\nexport const configureEnforcedOptions: OAppConfigurator = withOAppLogger(\n    async (graph, createSdk) => {\n        const logger = createOAppLogger()\n        // This function builds a map to find all OAppEnforcedOptionParam[] to execute for a given OApp\n        const setEnforcedOptionsByEndpoint: OmniPointMap<OAppEnforcedOptionParam[]> = new OmniPointMap()\n\n        for (const {\n            vector: { from, to },\n            config,\n        } of graph.connections) {\n            const connectionName = formatOmniVector({ from, to })\n\n            if (config?.enforcedOptions == null) {\n                logger.verbose(`Enforced options not set for ${connectionName}, skipping`)\n                continue\n            }\n            const oappSdk = await createSdk(from)\n\n            // combines enforced options together by msgType\n            const enforcedOptionsByMsgType = config.enforcedOptions.reduce(\n                enforcedOptionsReducer,\n                new Map<number, Options>()\n            )\n\n            // We ask the oapp SDK whether this config has already been applied\n            for (const [msgType, options] of enforcedOptionsByMsgType) {\n                const currentEnforcedOption: Bytes = await oappSdk.getEnforcedOptions(to.eid, msgType)\n                logger.verbose(`Checked current enforced options for ${connectionName}: ${currentEnforcedOption}`)\n\n                if (currentEnforcedOption !== options.toHex()) {\n                    // Updates map with new configs for that OApp and OAppEnforcedOptionParam[]\n                    const setConfigsByLibrary = setEnforcedOptionsByEndpoint.getOrElse(from, () => [])\n                    setConfigsByLibrary.push({\n                        eid: to.eid,\n                        option: {\n                            msgType,\n                            options: options.toHex(),\n                        },\n                    })\n                    setEnforcedOptionsByEndpoint.set(from, setConfigsByLibrary)\n\n                    const updatedEnforcedOptionsCsv = setEnforcedOptionsByEndpoint\n                        .getOrElse(from, () => [])\n                        .map(({ option }) => `{msgType: ${option.msgType}, options: ${option.options}}`)\n                        .join(', ')\n\n                    logger.verbose(`Set enforced options ${updatedEnforcedOptionsCsv} for ${connectionName}`)\n                }\n            }\n        }\n\n        // This function iterates over the map (OApp -> OAppEnforcedOptionParam[]) to execute setEnforcedOptions\n        return buildEnforcedOptionsOmniTransactions(setEnforcedOptionsByEndpoint, createSdk)\n    },\n    {\n        onStart: (logger) => logger.info(`Checking enforced options`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked enforced options`),\n    }\n)\n\nexport const configureCallerBpsCap: OAppConfigurator = withOAppLogger(\n    createConfigureNodes(\n        withOAppLogger(\n            async ({ config, point }, sdk) => {\n                const logger = createOAppLogger()\n                const label = formatOmniPoint(point)\n\n                if (config?.callerBpsCap == null) {\n                    return logger.verbose(`callerBpsCap not set for ${label}, skipping`), []\n                }\n\n                const callerBpsCap = await sdk.getCallerBpsCap()\n                if (callerBpsCap === config.callerBpsCap) {\n                    return logger.verbose(`callerBpsCap ${callerBpsCap} already set for ${label}, skipping`), []\n                }\n\n                return await sdk.setCallerBpsCap(config.callerBpsCap)\n            },\n            {\n                onStart: (logger, [{ point }]) =>\n                    logger.verbose(`Checking OApp callerBpsCap configuration for ${formatOmniPoint(point)}`),\n                onSuccess: (logger, [{ point }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked OApp callerBpsCap for ${formatOmniPoint(point)}`),\n                onError: (logger, [{ point }], error) =>\n                    logger.error(`Failed to check OApp callerBpsCap for ${formatOmniPoint(point)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking OApp callerBpsCap configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp callerBpsCap configuration`),\n    }\n)\n\nconst buildOmniTransactions = async (\n    setConfigsByEndpointAndLibrary: OmniPointMap<Map<OmniAddress, SetConfigParam[]>>,\n    createSdk: OAppFactory\n): Promise<OmniTransaction[]> => {\n    const logger = createOAppLogger()\n    const omniTransaction: OmniTransaction[] = []\n    for (const [from, configsByLibrary] of setConfigsByEndpointAndLibrary) {\n        const oapp = await createSdk(from)\n        const endpoint = await oapp.getEndpointSDK()\n        for (const [library, setConfigParams] of configsByLibrary) {\n            /**\n             * The older versions of devtools returned only one transaction from setConfig\n             * whereas the new versions might decide to split the transaction if it exceeds network size limits\n             *\n             * We'll handle the legacy versions gracefully and display a warning to the user about needing to update the dependencies\n             */\n            const transactionOrTransactions: OmniTransaction | OmniTransaction[] = await endpoint.setConfig(\n                from.address,\n                library,\n                setConfigParams\n            )\n            const transactions = Array.isArray(transactionOrTransactions)\n                ? transactionOrTransactions\n                : (logger.warn(\n                      `You are using an outdated version of @layerzerolabs/protocol-devtools (and/or @layerzerolabs/protocol-devtools-solana, @layerzerolabs/protocol-devtools-evm). Please update your dependencies to the newest version`\n                  ),\n                  [transactionOrTransactions])\n\n            omniTransaction.push(...transactions)\n        }\n    }\n    return omniTransaction\n}\n\nconst buildEnforcedOptionsOmniTransactions = async (\n    setEnforcedOptionsByEndpoint: OmniPointMap<OAppEnforcedOptionParam[]>,\n    createSdk: OAppFactory\n): Promise<OmniTransaction[]> => {\n    const omniTransaction: OmniTransaction[] = []\n    for (const [from, enforcedOptionsConfig] of setEnforcedOptionsByEndpoint) {\n        const oappSdk = await createSdk(from)\n        omniTransaction.push(await oappSdk.setEnforcedOptions(enforcedOptionsConfig))\n    }\n    return omniTransaction\n}\n\n/**\n * Reduces enforced options based on passed in enforced option configuration.\n * @param {Map<number, Options>} enforcedOptionsByMsgType - The map of enforced options by message type.\n * @param {OAppEnforcedOption} enforcedOptionsConfig - The passed in enforced option configuration.\n * @returns {Map<number, Options>} The reduced map of enforced options by message type.\n */\nconst enforcedOptionsReducer = (\n    enforcedOptionsByMsgType: Map<number, Options>,\n    enforcedOptionsConfig: OAppEnforcedOption\n): Map<number, Options> => {\n    /**\n     * optionType - ExecutorOptionType (LZ_RECEIVE, NATIVE_DROP, COMPOSE, ORDERED)\n     * msgType - OApp defined msgType\n     */\n    const { optionType, msgType } = enforcedOptionsConfig\n    const currentOptions = enforcedOptionsByMsgType.get(msgType) ?? Options.newOptions()\n\n    switch (optionType) {\n        case ExecutorOptionType.LZ_RECEIVE:\n            return enforcedOptionsByMsgType.set(\n                msgType,\n                currentOptions.addExecutorLzReceiveOption(enforcedOptionsConfig.gas, enforcedOptionsConfig.value)\n            )\n\n        case ExecutorOptionType.NATIVE_DROP:\n            return enforcedOptionsByMsgType.set(\n                msgType,\n                currentOptions.addExecutorNativeDropOption(enforcedOptionsConfig.amount, enforcedOptionsConfig.receiver)\n            )\n\n        case ExecutorOptionType.COMPOSE:\n            return enforcedOptionsByMsgType.set(\n                msgType,\n                currentOptions.addExecutorComposeOption(\n                    enforcedOptionsConfig.index,\n                    enforcedOptionsConfig.gas,\n                    enforcedOptionsConfig.value\n                )\n            )\n\n        case ExecutorOptionType.ORDERED:\n            return enforcedOptionsByMsgType.set(msgType, currentOptions.addExecutorOrderedExecutionOption())\n    }\n}\n\nexport const configureOApp: OAppConfigurator = withOAppLogger(\n    createConfigureMultiple(\n        configureOAppPeers,\n        configureSendLibraries,\n        configureReceiveLibraries,\n        configureReceiveLibraryTimeouts,\n        configureSendConfig,\n        configureReceiveConfig,\n        configureEnforcedOptions,\n        configureCallerBpsCap,\n        configureOAppDelegates\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking OApp configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp configuration`),\n        onError: (logger, args, error) => logger.error(`Failed to check OApp configuration: ${error}`),\n    }\n)\n","import { z } from 'zod'\nimport {\n    AddressSchema,\n    createOmniEdgeSchema,\n    createOmniGraphSchema,\n    createOmniNodeSchema,\n    UIntBigIntSchema,\n    UIntNumberSchema,\n} from '@layerzerolabs/devtools'\nimport { Uln302ExecutorConfigSchema, Uln302UlnUserConfigSchema, TimeoutSchema } from '@layerzerolabs/protocol-devtools'\nimport {\n    ExecutorComposeOption,\n    ExecutorLzReceiveOption,\n    ExecutorNativeDropOption,\n    ExecutorOrderedExecutionOption,\n    OAppEdgeConfig,\n    OAppEnforcedOption,\n    OAppNodeConfig,\n    OAppReceiveConfig,\n    OAppReceiveLibraryConfig,\n    OAppSendConfig,\n} from './types'\nimport { ExecutorOptionType } from '@layerzerolabs/lz-v2-utilities'\nimport { OwnableNodeConfigSchema } from '@/ownable/schema'\n\nexport const OAppReceiveLibraryConfigSchema = z.object({\n    gracePeriod: UIntBigIntSchema,\n    receiveLibrary: AddressSchema,\n}) satisfies z.ZodSchema<OAppReceiveLibraryConfig, z.ZodTypeDef, unknown>\n\nexport const OAppSendConfigSchema = z.object({\n    executorConfig: Uln302ExecutorConfigSchema.optional(),\n    ulnConfig: Uln302UlnUserConfigSchema.optional(),\n}) satisfies z.ZodSchema<OAppSendConfig, z.ZodTypeDef, unknown>\n\nexport const OAppReceiveConfigSchema = z.object({\n    ulnConfig: Uln302UlnUserConfigSchema.optional(),\n}) satisfies z.ZodSchema<OAppReceiveConfig, z.ZodTypeDef, unknown>\n\nexport const ExecutorLzReceiveOptionSchema = z.object({\n    msgType: UIntNumberSchema,\n    optionType: z.literal(ExecutorOptionType.LZ_RECEIVE),\n    gas: UIntNumberSchema,\n    value: UIntNumberSchema.optional(),\n}) satisfies z.ZodSchema<ExecutorLzReceiveOption, z.ZodTypeDef, unknown>\n\nexport const ExecutorNativeDropOptionSchema = z.object({\n    msgType: UIntNumberSchema,\n    optionType: z.literal(ExecutorOptionType.NATIVE_DROP),\n    amount: UIntNumberSchema,\n    receiver: AddressSchema,\n}) satisfies z.ZodSchema<ExecutorNativeDropOption, z.ZodTypeDef, unknown>\n\nexport const ExecutorComposeOptionSchema = z.object({\n    msgType: UIntNumberSchema,\n    optionType: z.literal(ExecutorOptionType.COMPOSE),\n    index: UIntNumberSchema,\n    gas: UIntNumberSchema,\n    value: UIntNumberSchema.optional(),\n}) satisfies z.ZodSchema<ExecutorComposeOption, z.ZodTypeDef, unknown>\n\nexport const ExecutorOrderedExecutionOptionSchema = z.object({\n    msgType: UIntNumberSchema,\n    optionType: z.literal(ExecutorOptionType.ORDERED),\n}) satisfies z.ZodSchema<ExecutorOrderedExecutionOption, z.ZodTypeDef, unknown>\n\nexport const OAppEnforcedOptionConfigSchema = z.union([\n    ExecutorLzReceiveOptionSchema,\n    ExecutorNativeDropOptionSchema,\n    ExecutorComposeOptionSchema,\n    ExecutorOrderedExecutionOptionSchema,\n]) satisfies z.ZodSchema<OAppEnforcedOption, z.ZodTypeDef, unknown>\n\nexport const OAppEnforcedOptionsSchema = z.array(OAppEnforcedOptionConfigSchema) satisfies z.ZodSchema<\n    OAppEnforcedOption[],\n    z.ZodTypeDef,\n    unknown\n>\n\nexport const OAppNodeConfigSchema = OwnableNodeConfigSchema.extend({\n    delegate: AddressSchema.nullish(),\n})\n    // We'll pass all unknown properties through without validating them\n    .passthrough() satisfies z.ZodSchema<OAppNodeConfig, z.ZodTypeDef, unknown>\n\nexport const OAppEdgeConfigSchema = z\n    .object({\n        sendLibrary: AddressSchema,\n        receiveLibraryConfig: OAppReceiveLibraryConfigSchema,\n        receiveLibraryTimeoutConfig: TimeoutSchema,\n        sendConfig: OAppSendConfigSchema,\n        receiveConfig: OAppReceiveConfigSchema,\n        enforcedOptions: OAppEnforcedOptionsSchema,\n    })\n    // We'll pass all unknown properties through without validating them\n    .passthrough()\n    .partial() satisfies z.ZodSchema<OAppEdgeConfig, z.ZodTypeDef, unknown>\n\nexport const OAppOmniGraphSchema = createOmniGraphSchema(\n    createOmniNodeSchema(OAppNodeConfigSchema),\n    createOmniEdgeSchema(OAppEdgeConfigSchema)\n)\n","import { AddressSchema } from '@layerzerolabs/devtools'\nimport { z } from 'zod'\n\nexport const OwnableNodeConfigSchema = z\n    .object({\n        owner: AddressSchema.nullish(),\n    })\n    // We'll pass all unknown properties through without validating them\n    .passthrough()\n","import { createModuleLogger } from '@layerzerolabs/io-devtools'\nimport type { OwnableConfigurator } from './types'\nimport { flattenTransactions, formatOmniPoint } from '@layerzerolabs/devtools'\n\nexport const configureOwnable: OwnableConfigurator = async (graph, createSdk) => {\n    const logger = createModuleLogger('Ownable')\n\n    return flattenTransactions(\n        await Promise.all(\n            graph.contracts.map(async ({ point, config }) => {\n                const formattedPoint = formatOmniPoint(point)\n\n                if (config?.owner == null) {\n                    return logger.verbose(`No owner specified for ${formattedPoint}`), undefined\n                }\n\n                logger.verbose(`Checking whether the owner of ${formattedPoint} is ${config.owner}`)\n\n                const sdk = await createSdk(point)\n                const hasOwner = await sdk.hasOwner(config.owner)\n                if (hasOwner) {\n                    return logger.verbose(`The owner of ${formattedPoint} already is ${config.owner}`), undefined\n                }\n\n                return (\n                    logger.verbose(`Setting the owner of ${formattedPoint} to ${config.owner}`),\n                    sdk.setOwner(config.owner)\n                )\n            })\n        )\n    )\n}\n","import {\n    type Bytes,\n    type OmniTransaction,\n    formatOmniPoint,\n    createConfigureMultiple,\n    createConfigureNodes,\n} from '@layerzerolabs/devtools'\nimport type { OAppReadConfigurator, OAppReadEnforcedOption } from './types'\nimport { createModuleLogger, createWithAsyncLogger, printBoolean } from '@layerzerolabs/io-devtools'\nimport type { SetConfigParam } from '@layerzerolabs/protocol-devtools'\nimport assert from 'assert'\nimport { ExecutorOptionType, Options } from '@layerzerolabs/lz-v2-utilities'\nimport {\n    configureCallerBpsCap,\n    configureEnforcedOptions,\n    configureOAppDelegates,\n    configureOAppPeers,\n    configureReceiveConfig,\n    configureReceiveLibraries,\n    configureReceiveLibraryTimeouts,\n    configureSendConfig,\n    configureSendLibraries,\n    type OAppEnforcedOptionParam,\n} from '@/oapp'\n\nconst createOAppReadLogger = () => createModuleLogger('OAppRead')\nconst withOAppReadLogger = createWithAsyncLogger(createOAppReadLogger)\n\nexport const configureOAppReadChannels: OAppReadConfigurator = withOAppReadLogger(\n    createConfigureNodes(\n        withOAppReadLogger(\n            async ({ config, point }, sdk): Promise<OmniTransaction[]> => {\n                const logger = createOAppReadLogger()\n                const label = formatOmniPoint(point)\n\n                const omniTransactions: OmniTransaction[] = []\n\n                if (!config?.readChannelConfigs) {\n                    logger.verbose(`readChannel configuration not set for ${label}, skipping`)\n                    return []\n                }\n\n                logger.verbose(`Checking read channels ${label}`)\n\n                for (const { channelId, active: activeConfig } of config.readChannelConfigs) {\n                    // Default active to true\n                    const active = activeConfig ?? true\n                    const isActive = await sdk.isReadChannelActive(channelId)\n                    logger.verbose(`Checking read channel ${channelId} for ${label}: ${printBoolean(isActive)}`)\n\n                    if (isActive !== active) {\n                        logger.verbose(`Setting read channel ${channelId} to ${active}`)\n                        omniTransactions.push(await sdk.setReadChannel(channelId, active))\n                    }\n                }\n\n                return omniTransactions\n            },\n            {\n                onStart: (logger, [{ point }]) =>\n                    logger.verbose(`Checking OApp read channels for ${formatOmniPoint(point)}`),\n                onSuccess: (logger, [{ point }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked OApp read channels for ${formatOmniPoint(point)}`),\n                onError: (logger, [{ point }], error) =>\n                    logger.error(`Failed to check OApp read channels for ${formatOmniPoint(point)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking OApp read channels configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp read channels configuration`),\n    }\n)\n\nexport const configureReadLibraries: OAppReadConfigurator = withOAppReadLogger(\n    createConfigureNodes(\n        withOAppReadLogger(\n            async ({ config, point }, sdk): Promise<OmniTransaction[]> => {\n                const logger = createOAppReadLogger()\n                const label = formatOmniPoint(point)\n\n                if (!config?.readChannelConfigs) {\n                    logger.verbose(`readChannel configuration not set for ${label}, skipping`)\n                    return []\n                }\n\n                const omniTransactions: OmniTransaction[] = []\n\n                const endpointSdk = await sdk.getEndpointSDK()\n\n                for (const { channelId, active, readLibrary } of config.readChannelConfigs) {\n                    if (active === false) {\n                        logger.verbose(\n                            `readLibrary won't be set for inactive channelId ${channelId} for ${label}, skipping`\n                        )\n                        continue\n                    }\n\n                    if (!readLibrary) {\n                        logger.verbose(\n                            `readLibrary configuration not set for channelId ${channelId} for ${label}, skipping`\n                        )\n                        continue\n                    }\n\n                    const isDefaultSendLibrary = await endpointSdk.isDefaultSendLibrary(point.address, channelId)\n                    const currentSendLibrary = await endpointSdk.getSendLibrary(point.address, channelId)\n\n                    if (!isDefaultSendLibrary && currentSendLibrary === readLibrary) {\n                        logger.verbose(\n                            `Current sendlibrary of channelId ${channelId} is already set to ${readLibrary} for ${label}, skipping`\n                        )\n                    } else {\n                        logger.verbose(`Setting sendLibrary ${readLibrary} to channelId ${channelId} for ${label}`)\n                        omniTransactions.push(await endpointSdk.setSendLibrary(point.address, channelId, readLibrary))\n                    }\n\n                    const [currentReceiveLibrary, isDefaultReceiveLibrary] = await endpointSdk.getReceiveLibrary(\n                        point.address,\n                        channelId\n                    )\n\n                    if (!isDefaultReceiveLibrary && currentReceiveLibrary === readLibrary) {\n                        logger.verbose(\n                            `Current receiveLibrary of channelId ${channelId} is already set to ${readLibrary} for ${label}, skipping`\n                        )\n                    } else {\n                        logger.verbose(`Setting receiveLibrary ${readLibrary} to channelId ${channelId} for ${label}`)\n                        omniTransactions.push(\n                            await endpointSdk.setReceiveLibrary(\n                                point.address,\n                                channelId,\n                                readLibrary,\n                                // TODO READ: Grace period should be configurable\n                                BigInt(0)\n                            )\n                        )\n                    }\n                }\n\n                return omniTransactions\n            },\n            {\n                onStart: (logger, [{ point }]) =>\n                    logger.verbose(`Checking read libraries for ${formatOmniPoint(point)}`),\n                onSuccess: (logger, [{ point }]) =>\n                    logger.verbose(`${printBoolean(true)} Checked read libraries for ${formatOmniPoint(point)}`),\n                onError: (logger, [{ point }], error) =>\n                    logger.error(`Failed to check read libraries for ${formatOmniPoint(point)}: ${error}`),\n            }\n        )\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking read libraries configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked read libraries configuration`),\n    }\n)\n\nexport const configureReadConfig: OAppReadConfigurator = createConfigureNodes(\n    withOAppReadLogger(\n        async ({ config, point }, sdk): Promise<OmniTransaction[]> => {\n            const logger = createOAppReadLogger()\n\n            const label = formatOmniPoint(point)\n\n            if (!config?.readChannelConfigs) {\n                logger.verbose(`readChannel configuration not set for ${label}, skipping`)\n                return []\n            }\n\n            const endpointSdk = await sdk.getEndpointSDK()\n\n            const omniTransactions: OmniTransaction[] = []\n\n            for (const { channelId, active, readLibrary, ulnConfig } of config.readChannelConfigs) {\n                if (active === false) {\n                    logger.verbose(`readLibrary not set for inactive channelId ${channelId} for ${label}, skipping`)\n                    continue\n                }\n\n                if (!ulnConfig) {\n                    logger.verbose(`ulnConfig not set for channelId ${channelId} for ${label}, skipping`)\n                    continue\n                }\n\n                // We ask the endpoint SDK whether this config has already been applied\n                //\n                // We need to ask not for the final config formed of the default config and the app config,\n                // we only need to check the app config\n\n                const currentSendLibrary = readLibrary ?? (await endpointSdk.getSendLibrary(point.address, channelId))\n                assert(\n                    currentSendLibrary !== undefined,\n                    'sendLibrary has not been set in your config and no default value exists'\n                )\n\n                const hasUlnConfig = await endpointSdk.hasAppUlnReadConfig(\n                    point.address,\n                    currentSendLibrary,\n                    channelId,\n                    ulnConfig\n                )\n\n                logger.verbose(`Checked ULN configuration for ${label}: ${printBoolean(hasUlnConfig)}`)\n\n                if (!hasUlnConfig) {\n                    const newSetConfigs: SetConfigParam[] = await endpointSdk.getUlnReadConfigParams(\n                        currentSendLibrary,\n                        [\n                            {\n                                channelId: channelId,\n                                ulnConfig: ulnConfig,\n                            },\n                        ]\n                    )\n\n                    // Updates map with new configs for that OApp and Send Library\n                    const transactions = await endpointSdk.setConfig(point.address, currentSendLibrary, newSetConfigs)\n\n                    logger.verbose(`Set ULN configuration  for ${formatOmniPoint(point)}`)\n\n                    const updatedConfigListCsv = newSetConfigs\n                        .map(({ configType, config }) => `{configType: ${configType}, config: ${config}}`)\n                        .join(', ')\n                    logger.verbose(`Set ULN configuration ${updatedConfigListCsv} for ${label}`)\n                    omniTransactions.push(...transactions)\n                }\n            }\n\n            return omniTransactions\n        },\n        {\n            onStart: (logger) => logger.info(`Checking read configuration`),\n            onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked read configuration`),\n        }\n    )\n)\n\nexport const configureReadEnforcedOptions: OAppReadConfigurator = createConfigureNodes(\n    withOAppReadLogger(\n        async ({ config, point }, sdk): Promise<OmniTransaction[]> => {\n            const logger = createOAppReadLogger()\n\n            const label = formatOmniPoint(point)\n\n            if (!config?.readChannelConfigs) {\n                logger.verbose(`readChannel configuration not set for ${label}, skipping`)\n                return []\n            }\n\n            const omniTransactions: OmniTransaction[] = []\n\n            const oappEnforcedOptions: OAppEnforcedOptionParam[] = []\n\n            for (const { channelId, active, enforcedOptions } of config.readChannelConfigs) {\n                if (active === false) {\n                    logger.verbose(`readLibrary not set for inactive channelId ${channelId} for ${label}, skipping`)\n                    continue\n                }\n\n                if (!enforcedOptions) {\n                    logger.verbose(`Enforced options not set for channelId ${channelId} for ${label}, skipping`)\n                    continue\n                }\n\n                // combines enforced options together by msgType\n                const enforcedOptionsByMsgType = enforcedOptions.reduce(\n                    enforcedOptionsReducer,\n                    new Map<number, Options>()\n                )\n\n                // We ask the oapp SDK whether this config has already been applied\n                for (const [msgType, options] of enforcedOptionsByMsgType) {\n                    const currentEnforcedOption: Bytes = await sdk.getEnforcedOptions(channelId, msgType)\n                    logger.verbose(\n                        `Checked current enforced options for channelId ${channelId} for ${label}: ${currentEnforcedOption}`\n                    )\n\n                    if (currentEnforcedOption !== options.toHex()) {\n                        oappEnforcedOptions.push({\n                            eid: channelId,\n                            option: {\n                                msgType,\n                                options: options.toHex(),\n                            },\n                        })\n\n                        logger.verbose(\n                            `Set enforced options {msgType: ${msgType}, options: ${options}} for channelId ${channelId} for ${label}`\n                        )\n                    }\n                }\n            }\n\n            if (oappEnforcedOptions.length > 0) {\n                logger.verbose(`Set enforced options for ${label}`)\n                omniTransactions.push(await sdk.setEnforcedOptions(oappEnforcedOptions))\n            }\n            return omniTransactions\n        },\n        {\n            onStart: (logger) => logger.info(`Checking enforced options`),\n            onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked enforced options`),\n        }\n    )\n)\n\n/**\n * Reduces enforced options based on passed in enforced option configuration.\n * @param {Map<number, Options>} enforcedOptionsByMsgType - The map of enforced options by message type.\n * @param {OAppReadEnforcedOption} enforcedOptionsConfig - The passed in enforced option configuration.\n * @returns {Map<number, Options>} The reduced map of enforced options by message type.\n */\nconst enforcedOptionsReducer = (\n    enforcedOptionsByMsgType: Map<number, Options>,\n    enforcedOptionsConfig: OAppReadEnforcedOption\n): Map<number, Options> => {\n    /**\n     * optionType - ExecutorOptionType (LZ_READ, COMPOSE, ORDERED)\n     * msgType - OApp defined msgType\n     */\n    const { optionType, msgType } = enforcedOptionsConfig\n    const currentOptions = enforcedOptionsByMsgType.get(msgType) ?? Options.newOptions()\n\n    switch (optionType) {\n        case ExecutorOptionType.COMPOSE:\n            return enforcedOptionsByMsgType.set(\n                msgType,\n                currentOptions.addExecutorComposeOption(\n                    enforcedOptionsConfig.index,\n                    enforcedOptionsConfig.gas,\n                    enforcedOptionsConfig.value\n                )\n            )\n\n        case ExecutorOptionType.ORDERED:\n            return enforcedOptionsByMsgType.set(msgType, currentOptions.addExecutorOrderedExecutionOption())\n\n        case ExecutorOptionType.LZ_READ:\n            return enforcedOptionsByMsgType.set(\n                msgType,\n                currentOptions.addExecutorLzReadOption(\n                    enforcedOptionsConfig.gas,\n                    enforcedOptionsConfig.size,\n                    enforcedOptionsConfig.value\n                )\n            )\n    }\n}\n\nexport const configureOAppRead: OAppReadConfigurator = withOAppReadLogger(\n    createConfigureMultiple(\n        configureOAppDelegates as OAppReadConfigurator,\n        configureOAppPeers as OAppReadConfigurator,\n        configureOAppReadChannels,\n        configureSendLibraries as OAppReadConfigurator,\n        configureReceiveLibraries as OAppReadConfigurator,\n        configureReceiveLibraryTimeouts as OAppReadConfigurator,\n        configureReadLibraries,\n        configureSendConfig as OAppReadConfigurator,\n        configureReceiveConfig as OAppReadConfigurator,\n        configureReadConfig,\n        configureEnforcedOptions as OAppReadConfigurator,\n        configureReadEnforcedOptions,\n        configureCallerBpsCap as OAppReadConfigurator\n    ),\n    {\n        onStart: (logger) => logger.info(`Checking OApp Read configuration`),\n        onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp Read configuration`),\n        onError: (logger, args, error) => logger.error(`Failed to check OApp Read configuration: ${error}`),\n    }\n)\n","import { z } from 'zod'\nimport {\n    AddressSchema,\n    createOmniEdgeSchema,\n    createOmniGraphSchema,\n    createOmniNodeSchema,\n    UIntNumberSchema,\n} from '@layerzerolabs/devtools'\nimport { UlnReadUlnUserConfigSchema } from '@layerzerolabs/protocol-devtools'\nimport { ExecutorLzReadOption, OAppReadNodeConfig, OAppReadChannelConfig, OAppReadEnforcedOption } from './types'\nimport { ExecutorOptionType } from '@layerzerolabs/lz-v2-utilities'\nimport { OwnableNodeConfigSchema } from '@/ownable/schema'\nimport { ExecutorComposeOptionSchema, ExecutorOrderedExecutionOptionSchema, OAppEdgeConfigSchema } from '@/oapp'\n\nexport const ExecutorLzReadOptionSchema = z.object({\n    msgType: UIntNumberSchema,\n    optionType: z.literal(ExecutorOptionType.LZ_READ),\n    gas: UIntNumberSchema,\n    size: UIntNumberSchema,\n    value: UIntNumberSchema.optional(),\n}) satisfies z.ZodSchema<ExecutorLzReadOption, z.ZodTypeDef, unknown>\n\nexport const OAppReadEnforcedOptionConfigSchema = z.union([\n    ExecutorLzReadOptionSchema,\n    ExecutorComposeOptionSchema,\n    ExecutorOrderedExecutionOptionSchema,\n]) satisfies z.ZodSchema<OAppReadEnforcedOption, z.ZodTypeDef, unknown>\n\nexport const OAppReadChannelConfigSchema = z.object({\n    channelId: UIntNumberSchema,\n    active: z.boolean().optional(),\n    readLibrary: AddressSchema.optional(),\n    ulnConfig: UlnReadUlnUserConfigSchema.optional(),\n    enforcedOptions: z.array(OAppReadEnforcedOptionConfigSchema).optional(),\n}) satisfies z.ZodSchema<OAppReadChannelConfig, z.ZodTypeDef, unknown>\n\nexport const OAppReadChannelSchema = z.array(OAppReadChannelConfigSchema) satisfies z.ZodSchema<\n    OAppReadChannelConfig[],\n    z.ZodTypeDef,\n    unknown\n>\n\nexport const OAppReadNodeConfigSchema = OwnableNodeConfigSchema.extend({\n    delegate: AddressSchema.nullish(),\n    readChannelConfigs: z.array(OAppReadChannelConfigSchema).optional(),\n})\n    // We'll pass all unknown properties through without validating them\n    .passthrough() satisfies z.ZodSchema<OAppReadNodeConfig, z.ZodTypeDef, unknown>\n\nexport const OAppReadOmniGraphSchema = createOmniGraphSchema(\n    createOmniNodeSchema(OAppReadNodeConfigSchema),\n    createOmniEdgeSchema(OAppEdgeConfigSchema)\n)\n","import { OAppReadFactory, OAppReadOmniGraph, OAppReadChannels } from '@/oapp-read/types'\n\nexport type OAppCheckReadChannels = (\n    graph: OAppReadOmniGraph,\n    createSdk: OAppReadFactory\n) => Promise<OAppReadChannels[]>\n\nexport const checkOAppReadChannels: OAppCheckReadChannels = async (graph, createSdk) => {\n    const promises = graph.contracts.flatMap(({ point, config }) => {\n        return (config?.readChannelConfigs || []).map(async ({ channelId }) => {\n            const sdk = await createSdk(point)\n            const isActive = await sdk.isReadChannelActive(channelId)\n            return { contract: point, channelId, isActive }\n        })\n    })\n\n    return await Promise.all(promises)\n}\n","import { EndpointBasedFactory } from '@layerzerolabs/devtools'\nimport { createModuleLogger, Logger } from '@layerzerolabs/io-devtools'\nimport {\n    Command,\n    CommandRequest,\n    Compute,\n    ComputeEVM,\n    ComputeType,\n    ResolverType,\n    SingleViewFunctionEVMCall,\n} from '@layerzerolabs/lz-v2-utilities'\n\nimport {\n    type BlockNumberTimeMarker,\n    dedupTimeMarkers,\n    extractTimeMarker,\n    findComputeResolvedTimeMarker,\n    findRequestResolvedTimeMarker,\n    type ResolvedTimeMarker,\n    type ResolvedTimestampTimeMarker,\n    type TimeMarker,\n    type TimestampTimeMarker,\n} from '@/read'\n\nimport type { ICommandResolver, RequestResponsePair, IComputerEVM, ISingleViewFunctionCallerEVM } from './types'\n\nexport class CommandResolver implements ICommandResolver {\n    constructor(\n        protected readonly singleViewFunctionEVMCallFactory: EndpointBasedFactory<ISingleViewFunctionCallerEVM>,\n        protected readonly computerEVMFactory: EndpointBasedFactory<IComputerEVM>\n    ) {}\n\n    public decodeCommand(command: string): Command {\n        return Command.decode(command.replace('0x', ''))\n    }\n\n    public async extractTimeMarkers(command: string): Promise<{\n        blockNumberTimeMarkers: BlockNumberTimeMarker[]\n        timestampTimeMarkers: TimestampTimeMarker[]\n    }> {\n        const decodedCommand = Command.decode(command.replace('0x', ''))\n\n        const timeMarkers: TimeMarker[] = []\n\n        for (const request of decodedCommand.requests) {\n            switch (request.requestHeader.resolverType) {\n                case ResolverType.SingleViewFunctionEVMCall:\n                    timeMarkers.push(extractTimeMarker(request as SingleViewFunctionEVMCall))\n                    break\n                default:\n                    throw new Error(`Unsupported resolver type: ${request.requestHeader.resolverType}`)\n            }\n        }\n        if (decodedCommand.compute) {\n            switch (decodedCommand.compute.computeHeader.computeType) {\n                case ComputeType.SingleViewFunctionEVMCall:\n                    timeMarkers.push(extractTimeMarker(decodedCommand.compute as ComputeEVM))\n                    break\n                default:\n                    throw new Error(`Unsupported compute type: ${decodedCommand.compute.computeHeader.computeType}`)\n            }\n        }\n\n        const dedupedTimeMarkers = dedupTimeMarkers(timeMarkers)\n        return {\n            blockNumberTimeMarkers: dedupedTimeMarkers.filter((tm) => tm.isBlockNumber),\n            timestampTimeMarkers: dedupedTimeMarkers.filter((tm) => !tm.isBlockNumber),\n        }\n    }\n\n    public async resolveCommand(command: string, timeMarkers: ResolvedTimestampTimeMarker[]): Promise<string> {\n        const logger = createModuleLogger('CommandResolverSdk')\n        const decodedCommand = Command.decode(command.replace('0x', ''))\n\n        logger.info(`Resolving requests`)\n        const responses = await Promise.all(\n            decodedCommand.requests.map(async (request) =>\n                this.resolveRequest(request, findRequestResolvedTimeMarker(request, timeMarkers), logger)\n            )\n        )\n\n        if (!decodedCommand.compute) {\n            logger.info('No compute information in command, returning concatenated responses')\n            return responses.map((lr) => lr.response).join('')\n        }\n\n        return await this.resolveCompute(\n            command,\n            decodedCommand.compute,\n            findComputeResolvedTimeMarker(decodedCommand.compute, timeMarkers),\n            responses\n        )\n    }\n\n    private async resolveRequest(\n        request: CommandRequest,\n        timeMarker: ResolvedTimeMarker,\n        logger: Logger\n    ): Promise<RequestResponsePair> {\n        switch (request.requestHeader.resolverType) {\n            case ResolverType.SingleViewFunctionEVMCall: {\n                const requestEvm = request as SingleViewFunctionEVMCall\n                const response = await (\n                    await this.singleViewFunctionEVMCallFactory(requestEvm.targetEid)\n                ).resolve(requestEvm, timeMarker)\n                logger.debug(`Resolved request ${requestEvm.encode()}: ${response}`)\n                return { request: requestEvm.encode(), response }\n            }\n            default:\n                throw new Error(`Unsupported resolver type: ${request.requestHeader.resolverType}`)\n        }\n    }\n\n    private async resolveCompute(\n        command: string,\n        compute: Compute,\n        timeMarker: ResolvedTimeMarker,\n        responses: RequestResponsePair[]\n    ): Promise<string> {\n        switch (compute.computeHeader.computeType) {\n            case ComputeType.SingleViewFunctionEVMCall: {\n                const computeEvm = compute as ComputeEVM\n                return await (\n                    await this.computerEVMFactory(computeEvm.targetEid)\n                ).resolve(command, computeEvm, timeMarker, responses)\n            }\n            default:\n                throw new Error(`Unsupported compute type: ${compute.computeHeader.computeType}`)\n        }\n    }\n}\n","export class UnresolvableCommandError extends Error {\n    constructor() {\n        super(`Unresolvable command`)\n    }\n}\n","import {\n    CommandRequest,\n    Compute,\n    ComputeEVM,\n    ComputeType,\n    ResolverType,\n    SingleViewFunctionEVMCall,\n    TimestampBlockConfiguration,\n} from '@layerzerolabs/lz-v2-utilities'\nimport type { EndpointId } from '@layerzerolabs/lz-definitions'\nimport type {\n    BlockTime,\n    ResolvedTimeMarker,\n    ResolvedTimestampTimeMarker,\n    TimeMarker,\n    TimestampTimeMarker,\n} from './types'\n\nexport const dedup =\n    <T>(isEqual: (a: T, b: T) => boolean) =>\n    (arr: T[]): T[] => {\n        return arr.reduce<T[]>((acc, item) => {\n            if (!acc.some((existingItem) => isEqual(existingItem, item))) {\n                acc.push(item)\n            }\n            return acc\n        }, [])\n    }\n\nexport const isEqualTimeMarker = (a: TimeMarker, b: TimeMarker): boolean => {\n    return (\n        a.eid === b.eid &&\n        a.isBlockNumber === b.isBlockNumber &&\n        a.blockNumber === b.blockNumber &&\n        a.timestamp === b.timestamp &&\n        a.blockConfirmation === b.blockConfirmation\n    )\n}\n\nexport const dedupTimeMarkers = dedup<TimeMarker>(isEqualTimeMarker)\n\nexport const extractTimeMarker = (req: SingleViewFunctionEVMCall | ComputeEVM): TimeMarker => {\n    const baseTimeMarker = {\n        blockConfirmation: req.blockConfirmations,\n        eid: req.targetEid,\n    }\n    if (req.timestampBlockFlag === TimestampBlockConfiguration.Timestamp) {\n        return {\n            ...baseTimeMarker,\n            isBlockNumber: false,\n            timestamp: Number(req.timestamp!),\n        }\n    }\n    return {\n        ...baseTimeMarker,\n        isBlockNumber: true,\n        blockNumber: Number(req.blockNumber!),\n    }\n}\n\nconst findResolvedTimeMarker = (\n    timeMarker: TimestampTimeMarker,\n    resolvedTimeMarkers: ResolvedTimestampTimeMarker[]\n): ResolvedTimestampTimeMarker => {\n    const resolvedTimeMarker = resolvedTimeMarkers.find(\n        (tm) =>\n            tm.eid === timeMarker.eid &&\n            tm.timestamp === timeMarker.timestamp &&\n            tm.blockConfirmation === timeMarker.blockConfirmation\n    )\n\n    if (!resolvedTimeMarker) {\n        throw new Error(`Could not find resolved time marker for ${JSON.stringify(timeMarker)}`)\n    }\n    return resolvedTimeMarker\n}\n\nexport const applyResolvedTimestampTimeMarkers = (\n    tms: TimestampTimeMarker[],\n    rtms: ResolvedTimestampTimeMarker[]\n): ResolvedTimestampTimeMarker[] => {\n    return tms.map((tm) => {\n        return findResolvedTimeMarker(tm, rtms)\n    })\n}\n\nexport const findRequestResolvedTimeMarker = (\n    request: CommandRequest,\n    timeMarkers: ResolvedTimestampTimeMarker[]\n): ResolvedTimeMarker => {\n    switch (request.requestHeader.resolverType) {\n        case ResolverType.SingleViewFunctionEVMCall: {\n            const timeMarker = extractTimeMarker(request as SingleViewFunctionEVMCall)\n            if (timeMarker.isBlockNumber) {\n                return timeMarker\n            }\n            return findResolvedTimeMarker(timeMarker, timeMarkers)\n        }\n        default:\n            throw new Error(`Unsupported resolver type: ${request.requestHeader.resolverType}`)\n    }\n}\n\nexport const findComputeResolvedTimeMarker = (\n    compute: Compute,\n    timeMarkers: ResolvedTimestampTimeMarker[]\n): ResolvedTimeMarker => {\n    switch (compute.computeHeader.computeType) {\n        case ComputeType.SingleViewFunctionEVMCall: {\n            const timeMarker = extractTimeMarker(compute as ComputeEVM)\n            if (timeMarker.isBlockNumber) {\n                return timeMarker\n            }\n            return findResolvedTimeMarker(timeMarker, timeMarkers)\n        }\n        default:\n            throw new Error(`Unsupported compute type: ${compute.computeHeader.computeType}`)\n    }\n}\n\nexport const groupByEid = <T extends { eid: EndpointId }>(arr: T[]): Map<number, T[]> => {\n    return arr.reduce((acc, item) => {\n        if (!acc.has(item.eid)) {\n            acc.set(item.eid, [])\n        }\n        acc.get(item.eid)!.push(item)\n        return acc\n    }, new Map<number, T[]>())\n}\n\nexport const isBlockMatchingTimestamp = (\n    block: BlockTime,\n    previousBlock: BlockTime | null,\n    targetTimestamp: number\n): boolean => {\n    return block.number === 1\n        ? block.timestamp == targetTimestamp\n        : block.timestamp >= targetTimestamp && previousBlock!.timestamp < targetTimestamp\n}\n","import { EndpointBasedFactory } from '@layerzerolabs/devtools'\nimport type { ResolvedTimestampTimeMarker, TimestampTimeMarker } from '@/read'\n\nimport type { ITimeMarkerResolver, ITimeMarkerResolverChain } from './types'\n\nexport class TimeMarkerResolver implements ITimeMarkerResolver {\n    constructor(protected readonly timeMarkerResolverChainFactory: EndpointBasedFactory<ITimeMarkerResolverChain>) {}\n\n    public async resolveTimestampTimeMarkers(\n        timeMarkers: TimestampTimeMarker[]\n    ): Promise<ResolvedTimestampTimeMarker[]> {\n        const resolvedTimeMarkers: ResolvedTimestampTimeMarker[] = []\n\n        // Grouping by chainName (keeping ordering)\n        const groupedTimeMarkers = timeMarkers.reduce((acc, timeMarker, id) => {\n            if (!acc.has(timeMarker.eid)) {\n                acc.set(timeMarker.eid, [])\n            }\n            acc.get(timeMarker.eid)!.push({ timeMarker, id })\n            return acc\n        }, new Map<number, { timeMarker: TimestampTimeMarker; id: number }[]>())\n\n        // Process each group of timeMarkers for each chain\n        await Promise.all(\n            Array.from(groupedTimeMarkers.entries()).map(async ([eid, markers]) => {\n                const sdk = await this.timeMarkerResolverChainFactory(eid)\n\n                // Resolving timestamps to blockNumbers\n                const timestamps = markers\n                    .map((m) => m.timeMarker)\n                    .filter((timeMarker) => !timeMarker.isBlockNumber)\n                    .map((timeMarker) => timeMarker.timestamp)\n\n                const resolvedTimestamps = await sdk.resolveTimestamps(timestamps)\n\n                // putting back the item in the right order\n                markers.forEach((marker) => {\n                    resolvedTimeMarkers[marker.id] = {\n                        ...marker.timeMarker,\n                        blockNumber: resolvedTimestamps[marker.timeMarker.timestamp]!,\n                    }\n                })\n            })\n        )\n\n        return resolvedTimeMarkers\n    }\n}\n","import { EndpointBasedFactory } from '@layerzerolabs/devtools'\nimport { groupByEid, type ResolvedTimeMarker, type ResolvedTimestampTimeMarker } from '@/read'\n\nimport { ITimeMarkerValidator, ITimeMarkerValidatorChain } from './types'\n\nexport class TimeMarkerValidator implements ITimeMarkerValidator {\n    constructor(protected readonly timeMarkerValidatorChainFactory: EndpointBasedFactory<ITimeMarkerValidatorChain>) {}\n\n    public async checkResolvedTimeMarkerValidity(tms: ResolvedTimestampTimeMarker[]): Promise<void> {\n        const groupedTimeMarkers = groupByEid(tms)\n\n        await Promise.all(\n            Array.from(groupedTimeMarkers.entries()).map(async ([eid, markers]) => {\n                const sdk = await this.timeMarkerValidatorChainFactory(eid)\n                await sdk.checkResolvedTimeMarkerValidity(markers)\n            })\n        )\n    }\n\n    public async assertTimeMarkerBlockConfirmations(tms: ResolvedTimeMarker[]): Promise<void> {\n        const groupedTimeMarkers = groupByEid(tms)\n\n        await Promise.all(\n            Array.from(groupedTimeMarkers.entries()).map(async ([eid, markers]) => {\n                const sdk = await this.timeMarkerValidatorChainFactory(eid)\n                await sdk.assertTimeMarkerBlockConfirmations(markers)\n            })\n        )\n    }\n}\n"]}