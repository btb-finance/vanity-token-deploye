import { createConfigureMultiple, createConfigureNodes, formatOmniPoint, createConfigureEdges, formatOmniVector, isDeepEqual, OmniPointMap, AddressSchema, UIntBigIntSchema, UIntNumberSchema, createOmniGraphSchema, createOmniNodeSchema, createOmniEdgeSchema, flattenTransactions } from '@layerzerolabs/devtools';
import { createWithAsyncLogger, printBoolean, createModuleLogger } from '@layerzerolabs/io-devtools';
import { ExecutorOptionType, Options, Command, ResolverType, ComputeType, TimestampBlockConfiguration } from '@layerzerolabs/lz-v2-utilities';
import { Uln302ConfigType, Uln302ExecutorConfigSchema, Uln302UlnUserConfigSchema, TimeoutSchema, UlnReadUlnUserConfigSchema } from '@layerzerolabs/protocol-devtools';
import assert from 'assert';
import { z } from 'zod';

// src/lzapp/config.ts
var configureLzAppTrustedRemotes = async (graph, createSdk) => {
  const logger = createModuleLogger("LzApp");
  return flattenTransactions(
    await Promise.all(
      graph.connections.map(async ({ vector: { from, to } }) => {
        logger.verbose(`Checking connection ${formatOmniVector({ from, to })}`);
        const sdk = await createSdk(from);
        const hasPeer = await sdk.hasTrustedRemote(to.eid, to.address);
        logger.verbose(`Checked connection ${formatOmniVector({ from, to })}: ${printBoolean(hasPeer)}`);
        if (hasPeer) {
          return [];
        }
        logger.verbose(`Creating a connection ${formatOmniVector({ from, to })}`);
        return [await sdk.setTrustedRemote(to.eid, to.address)];
      })
    )
  );
};
var configureLzApp = createConfigureMultiple(configureLzAppTrustedRemotes);
var EnforcedOptions = [
  ExecutorOptionType.LZ_RECEIVE,
  ExecutorOptionType.NATIVE_DROP,
  ExecutorOptionType.COMPOSE,
  ExecutorOptionType.ORDERED,
  ExecutorOptionType.LZ_READ
];
var checkOAppPeers = async (graph, createSdk) => {
  return await Promise.all(
    graph.connections.map(async ({ vector }) => {
      const sdk = await createSdk(vector.from);
      const hasPeer = await sdk.hasPeer(vector.to.eid, vector.to.address);
      return { vector, hasPeer };
    })
  );
};
var checkOAppEnforcedOptions = async (graph, createSdk) => {
  return await Promise.all(
    graph.connections.map(async ({ vector }) => {
      const enforcedOptionsRead = [];
      const oappSdk = await createSdk(vector.from);
      for (const enforcedOption of EnforcedOptions) {
        enforcedOptionsRead.push({
          msgType: enforcedOption,
          options: await oappSdk.getEnforcedOptions(vector.to.eid, enforcedOption)
        });
      }
      return { vector, enforcedOptions: enforcedOptionsRead };
    })
  );
};
var createOAppLogger = () => createModuleLogger("OApp");
var withOAppLogger = createWithAsyncLogger(createOAppLogger);
var configureOAppDelegates = withOAppLogger(
  createConfigureNodes(
    withOAppLogger(
      async ({ config, point }, sdk) => {
        const logger = createOAppLogger();
        const label = formatOmniPoint(point);
        if ((config == null ? void 0 : config.delegate) == null) {
          return logger.verbose(`Delegate not set for ${label}, skipping`), [];
        }
        const isDelegate = await sdk.isDelegate(config.delegate);
        logger.verbose(`Delegate ${config.delegate} set for ${label}: ${printBoolean(isDelegate)}`);
        if (isDelegate) {
          return logger.verbose(`Delegate ${config.delegate} already set for ${label}`), [];
        }
        logger.verbose(`Setting delegate ${config.delegate} for ${label}`);
        return [await sdk.setDelegate(config.delegate)];
      },
      {
        onStart: (logger, [{ point }]) => logger.verbose(`Checking OApp delegate configuration for ${formatOmniPoint(point)}`),
        onSuccess: (logger, [{ point }]) => logger.verbose(`${printBoolean(true)} Checked OApp delegate for ${formatOmniPoint(point)}`),
        onError: (logger, [{ point }], error) => logger.error(`Failed to check OApp delegate for ${formatOmniPoint(point)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking OApp delegates configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp delegates`)
  }
);
var configureOAppPeers = withOAppLogger(
  createConfigureEdges(
    withOAppLogger(
      async ({ vector: { from, to } }, sdk) => {
        const logger = createOAppLogger();
        logger.verbose(`Checking connection ${formatOmniVector({ from, to })}`);
        const hasPeer = await sdk.hasPeer(to.eid, to.address);
        logger.verbose(`Checked connection ${formatOmniVector({ from, to })}: ${printBoolean(hasPeer)}`);
        if (hasPeer) {
          return [];
        }
        logger.verbose(`Creating a connection ${formatOmniVector({ from, to })}`);
        return [await sdk.setPeer(to.eid, to.address)];
      },
      {
        onStart: (logger, [{ vector }]) => logger.verbose(`Checking OApp peers for ${formatOmniVector(vector)}`),
        onSuccess: (logger, [{ vector }]) => logger.verbose(`${printBoolean(true)} Checked OApp peers for ${formatOmniVector(vector)}`),
        onError: (logger, [{ vector }], error) => logger.error(`Failed to check OApp peers for ${formatOmniVector(vector)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking OApp peers configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp peers configuration`)
  }
);
var configureSendLibraries = withOAppLogger(
  createConfigureEdges(
    withOAppLogger(
      async ({ vector: { from, to }, config }, sdk) => {
        const logger = createOAppLogger();
        if (!(config == null ? void 0 : config.sendLibrary)) {
          logger.verbose(`sendLibrary configuration not set for ${formatOmniVector({ from, to })}, skipping`);
          return [];
        }
        const endpointSdk = await sdk.getEndpointSDK();
        const isDefaultLibrary = await endpointSdk.isDefaultSendLibrary(from.address, to.eid);
        const currentSendLibrary = await endpointSdk.getSendLibrary(from.address, to.eid);
        if (!isDefaultLibrary && currentSendLibrary === config.sendLibrary) {
          logger.verbose(
            `Current sendLibrary is not default library and is already set to ${config.sendLibrary} for ${formatOmniVector({ from, to })}, skipping`
          );
          return [];
        }
        logger.verbose(`Setting sendLibrary ${config.sendLibrary} for ${formatOmniVector({ from, to })}`);
        return [await endpointSdk.setSendLibrary(from.address, to.eid, config.sendLibrary)];
      },
      {
        onStart: (logger, [{ vector }]) => logger.verbose(`Checking send libraries for ${formatOmniVector(vector)}`),
        onSuccess: (logger, [{ vector }]) => logger.verbose(`${printBoolean(true)} Checked send libraries for ${formatOmniVector(vector)}`),
        onError: (logger, [{ vector }], error) => logger.error(`Failed to check send libraries for ${formatOmniVector(vector)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking send libraries configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked send libraries configuration`)
  }
);
var configureReceiveLibraries = withOAppLogger(
  createConfigureEdges(
    withOAppLogger(
      async ({ vector: { from, to }, config }, sdk) => {
        const logger = createOAppLogger();
        if ((config == null ? void 0 : config.receiveLibraryConfig) == null) {
          logger.verbose(`receiveLibraryConfig not set for ${formatOmniVector({ from, to })}, skipping`);
          return [];
        }
        const endpointSdk = await sdk.getEndpointSDK();
        const [currentReceiveLibrary, isDefaultLibrary] = await endpointSdk.getReceiveLibrary(
          from.address,
          to.eid
        );
        if (!isDefaultLibrary && currentReceiveLibrary === config.receiveLibraryConfig.receiveLibrary) {
          logger.verbose(
            `Current recieveLibrary is not default and is already set to ${config.receiveLibraryConfig.receiveLibrary} for ${formatOmniVector({ from, to })}, skipping`
          );
          return [];
        }
        logger.verbose(
          `Setting recieveLibrary ${config.receiveLibraryConfig.receiveLibrary} for ${formatOmniVector({ from, to })}`
        );
        return [
          await endpointSdk.setReceiveLibrary(
            from.address,
            to.eid,
            config.receiveLibraryConfig.receiveLibrary,
            config.receiveLibraryConfig.gracePeriod
          )
        ];
      },
      {
        onStart: (logger, [{ vector }]) => logger.verbose(`Checking receive libraries for ${formatOmniVector(vector)}`),
        onSuccess: (logger, [{ vector }]) => logger.verbose(`${printBoolean(true)} Checked receive libraries for ${formatOmniVector(vector)}`),
        onError: (logger, [{ vector }], error) => logger.error(`Failed to check receive libraries for ${formatOmniVector(vector)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking receive libraries configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked receive libraries configuration`)
  }
);
var configureReceiveLibraryTimeouts = withOAppLogger(
  createConfigureEdges(
    withOAppLogger(
      async ({ vector: { from, to }, config }, sdk) => {
        const logger = createOAppLogger();
        if ((config == null ? void 0 : config.receiveLibraryTimeoutConfig) == null) {
          logger.verbose(
            `receiveLibraryTimeoutConfig not set for ${formatOmniVector({ from, to })}, skipping`
          );
          return [];
        }
        const { receiveLibraryTimeoutConfig } = config;
        const endpointSdk = await sdk.getEndpointSDK();
        const timeout = await endpointSdk.getReceiveLibraryTimeout(from.address, to.eid);
        if (isDeepEqual(timeout, receiveLibraryTimeoutConfig)) {
          logger.verbose(
            `Current timeout for ${receiveLibraryTimeoutConfig.lib} is already set to ${receiveLibraryTimeoutConfig.expiry} for ${formatOmniVector({ from, to })}, skipping`
          );
          return [];
        }
        logger.verbose(
          `Setting timeout for ${receiveLibraryTimeoutConfig.lib} to ${receiveLibraryTimeoutConfig.expiry} for ${formatOmniVector({ from, to })}`
        );
        return [
          await endpointSdk.setReceiveLibraryTimeout(
            from.address,
            to.eid,
            receiveLibraryTimeoutConfig.lib,
            receiveLibraryTimeoutConfig.expiry
          )
        ];
      },
      {
        onStart: (logger, [{ vector }]) => logger.verbose(`Checking receive library timeouts for ${formatOmniVector(vector)}`),
        onSuccess: (logger, [{ vector }]) => logger.verbose(
          `${printBoolean(true)} Checked receive library timeouts for ${formatOmniVector(vector)}`
        ),
        onError: (logger, [{ vector }], error) => logger.error(`Failed to check receive library timeouts for ${formatOmniVector(vector)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking receive library timeout configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked receive library timeout configuration`)
  }
);
var configureSendConfig = withOAppLogger(
  async (graph, createSdk) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const logger = createOAppLogger();
    const setConfigsByEndpointAndLibrary = new OmniPointMap();
    for (const {
      vector: { from, to },
      config
    } of graph.connections) {
      const connectionName = formatOmniVector({ from, to });
      if (((_a = config == null ? void 0 : config.sendConfig) == null ? void 0 : _a.executorConfig) == null && ((_b = config == null ? void 0 : config.sendConfig) == null ? void 0 : _b.ulnConfig) == null) {
        logger.verbose(`executorConfig and ulnConfig not set for ${connectionName}, skipping`);
        continue;
      }
      const oappSdk = await createSdk(from);
      const endpointSdk = await oappSdk.getEndpointSDK();
      const currentSendLibrary = (_c = config.sendLibrary) != null ? _c : await endpointSdk.getSendLibrary(from.address, to.eid);
      assert(
        currentSendLibrary !== void 0,
        "sendLibrary has not been set in your config and no default value exists"
      );
      if (config.sendConfig.executorConfig != null) {
        const hasExecutorConfig = await endpointSdk.hasAppExecutorConfig(
          from.address,
          currentSendLibrary,
          to.eid,
          config.sendConfig.executorConfig
        );
        logger.verbose(
          `Checked executor configuration for ${connectionName}: ${printBoolean(hasExecutorConfig)}`
        );
        if (!hasExecutorConfig) {
          const newSetConfigs = await endpointSdk.getExecutorConfigParams(
            currentSendLibrary,
            [{ eid: to.eid, executorConfig: config.sendConfig.executorConfig }]
          );
          const setConfigsByLibrary = setConfigsByEndpointAndLibrary.getOrElse(from, () => /* @__PURE__ */ new Map());
          const existingSetConfigs = (_d = setConfigsByLibrary.get(currentSendLibrary)) != null ? _d : [];
          setConfigsByEndpointAndLibrary.set(
            from,
            setConfigsByLibrary.set(currentSendLibrary, [...existingSetConfigs, ...newSetConfigs])
          );
          const updatedConfigList = (_e = setConfigsByEndpointAndLibrary.getOrElse(from, () => /* @__PURE__ */ new Map()).get(currentSendLibrary)) != null ? _e : [];
          const updatedConfigListCsv = updatedConfigList.map(({ configType, config: config2 }) => `{configType: ${configType}, config: ${config2}}`).join(", ");
          logger.verbose(`Set executor configuration ${updatedConfigListCsv} for ${connectionName}`);
        }
      }
      if (config.sendConfig.ulnConfig != null) {
        const hasUlnConfig = await endpointSdk.hasAppUlnConfig(
          from.address,
          currentSendLibrary,
          to.eid,
          config.sendConfig.ulnConfig,
          Uln302ConfigType.Send
        );
        logger.verbose(
          `Checked ULN configuration for ${formatOmniVector({ from, to })}: ${printBoolean(hasUlnConfig)}`
        );
        if (!hasUlnConfig) {
          const newSetConfigs = await endpointSdk.getUlnConfigParams(currentSendLibrary, [
            { eid: to.eid, ulnConfig: config.sendConfig.ulnConfig, type: Uln302ConfigType.Send }
          ]);
          const setConfigsByLibrary = setConfigsByEndpointAndLibrary.getOrElse(from, () => /* @__PURE__ */ new Map());
          const existingSetConfigs = (_f = setConfigsByLibrary.get(currentSendLibrary)) != null ? _f : [];
          setConfigsByEndpointAndLibrary.set(
            from,
            setConfigsByLibrary.set(currentSendLibrary, [...existingSetConfigs, ...newSetConfigs])
          );
          const updatedConfigList = (_g = setConfigsByEndpointAndLibrary.getOrElse(from, () => /* @__PURE__ */ new Map()).get(currentSendLibrary)) != null ? _g : [];
          const updatedConfigListCsv = updatedConfigList.map(({ configType, config: config2 }) => `{configType: ${configType}, config: ${config2}}`).join(", ");
          logger.verbose(
            `Set ULN configuration ${updatedConfigListCsv} for ${formatOmniVector({ from, to })}`
          );
        }
      }
    }
    return buildOmniTransactions(setConfigsByEndpointAndLibrary, createSdk);
  },
  {
    onStart: (logger) => logger.info(`Checking send configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked send configuration`)
  }
);
var configureReceiveConfig = withOAppLogger(
  async (graph, createSdk) => {
    var _a, _b, _c, _d, _e;
    const logger = createOAppLogger();
    const setConfigsByEndpointAndLibrary = new OmniPointMap();
    for (const {
      vector: { from, to },
      config
    } of graph.connections) {
      const connectionName = formatOmniVector({ from, to });
      if (((_a = config == null ? void 0 : config.receiveConfig) == null ? void 0 : _a.ulnConfig) == null) {
        logger.verbose(`ULN receive config not set for ${connectionName}, skipping`);
        continue;
      }
      const oappSdk = await createSdk(from);
      const endpointSdk = await oappSdk.getEndpointSDK();
      const [currentReceiveLibrary] = ((_b = config == null ? void 0 : config.receiveLibraryConfig) == null ? void 0 : _b.receiveLibrary) ? [(_c = config.receiveLibraryConfig) == null ? void 0 : _c.receiveLibrary, false] : await endpointSdk.getReceiveLibrary(from.address, to.eid);
      assert(
        currentReceiveLibrary !== void 0,
        `${connectionName}: receiveLibrary has not been set in your config and no default value exists`
      );
      const hasUlnConfig = await endpointSdk.hasAppUlnConfig(
        from.address,
        currentReceiveLibrary,
        to.eid,
        config.receiveConfig.ulnConfig,
        Uln302ConfigType.Receive
      );
      logger.verbose(`Checked ULN receive configuration for ${connectionName}: ${printBoolean(hasUlnConfig)}`);
      if (!hasUlnConfig) {
        const newSetConfigs = await endpointSdk.getUlnConfigParams(currentReceiveLibrary, [
          { eid: to.eid, ulnConfig: config.receiveConfig.ulnConfig, type: Uln302ConfigType.Receive }
        ]);
        const setConfigsByLibrary = setConfigsByEndpointAndLibrary.getOrElse(from, () => /* @__PURE__ */ new Map());
        const existingSetConfigs = (_d = setConfigsByLibrary.get(currentReceiveLibrary)) != null ? _d : [];
        setConfigsByEndpointAndLibrary.set(
          from,
          setConfigsByLibrary.set(currentReceiveLibrary, [...existingSetConfigs, ...newSetConfigs])
        );
        const updatedConfigList = (_e = setConfigsByEndpointAndLibrary.getOrElse(from, () => /* @__PURE__ */ new Map()).get(currentReceiveLibrary)) != null ? _e : [];
        const updatedConfigListCsv = updatedConfigList.map(({ configType, config: config2 }) => `{configType: ${configType}, config: ${config2}}`).join(", ");
        logger.verbose(`Set ULN receive configuration ${updatedConfigListCsv} for ${connectionName}`);
      }
    }
    return buildOmniTransactions(setConfigsByEndpointAndLibrary, createSdk);
  },
  {
    onStart: (logger) => logger.info(`Checking receive configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked receive configuration`)
  }
);
var configureEnforcedOptions = withOAppLogger(
  async (graph, createSdk) => {
    const logger = createOAppLogger();
    const setEnforcedOptionsByEndpoint = new OmniPointMap();
    for (const {
      vector: { from, to },
      config
    } of graph.connections) {
      const connectionName = formatOmniVector({ from, to });
      if ((config == null ? void 0 : config.enforcedOptions) == null) {
        logger.verbose(`Enforced options not set for ${connectionName}, skipping`);
        continue;
      }
      const oappSdk = await createSdk(from);
      const enforcedOptionsByMsgType = config.enforcedOptions.reduce(
        enforcedOptionsReducer,
        /* @__PURE__ */ new Map()
      );
      for (const [msgType, options] of enforcedOptionsByMsgType) {
        const currentEnforcedOption = await oappSdk.getEnforcedOptions(to.eid, msgType);
        logger.verbose(`Checked current enforced options for ${connectionName}: ${currentEnforcedOption}`);
        if (currentEnforcedOption !== options.toHex()) {
          const setConfigsByLibrary = setEnforcedOptionsByEndpoint.getOrElse(from, () => []);
          setConfigsByLibrary.push({
            eid: to.eid,
            option: {
              msgType,
              options: options.toHex()
            }
          });
          setEnforcedOptionsByEndpoint.set(from, setConfigsByLibrary);
          const updatedEnforcedOptionsCsv = setEnforcedOptionsByEndpoint.getOrElse(from, () => []).map(({ option }) => `{msgType: ${option.msgType}, options: ${option.options}}`).join(", ");
          logger.verbose(`Set enforced options ${updatedEnforcedOptionsCsv} for ${connectionName}`);
        }
      }
    }
    return buildEnforcedOptionsOmniTransactions(setEnforcedOptionsByEndpoint, createSdk);
  },
  {
    onStart: (logger) => logger.info(`Checking enforced options`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked enforced options`)
  }
);
var configureCallerBpsCap = withOAppLogger(
  createConfigureNodes(
    withOAppLogger(
      async ({ config, point }, sdk) => {
        const logger = createOAppLogger();
        const label = formatOmniPoint(point);
        if ((config == null ? void 0 : config.callerBpsCap) == null) {
          return logger.verbose(`callerBpsCap not set for ${label}, skipping`), [];
        }
        const callerBpsCap = await sdk.getCallerBpsCap();
        if (callerBpsCap === config.callerBpsCap) {
          return logger.verbose(`callerBpsCap ${callerBpsCap} already set for ${label}, skipping`), [];
        }
        return await sdk.setCallerBpsCap(config.callerBpsCap);
      },
      {
        onStart: (logger, [{ point }]) => logger.verbose(`Checking OApp callerBpsCap configuration for ${formatOmniPoint(point)}`),
        onSuccess: (logger, [{ point }]) => logger.verbose(`${printBoolean(true)} Checked OApp callerBpsCap for ${formatOmniPoint(point)}`),
        onError: (logger, [{ point }], error) => logger.error(`Failed to check OApp callerBpsCap for ${formatOmniPoint(point)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking OApp callerBpsCap configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp callerBpsCap configuration`)
  }
);
var buildOmniTransactions = async (setConfigsByEndpointAndLibrary, createSdk) => {
  const logger = createOAppLogger();
  const omniTransaction = [];
  for (const [from, configsByLibrary] of setConfigsByEndpointAndLibrary) {
    const oapp = await createSdk(from);
    const endpoint = await oapp.getEndpointSDK();
    for (const [library, setConfigParams] of configsByLibrary) {
      const transactionOrTransactions = await endpoint.setConfig(
        from.address,
        library,
        setConfigParams
      );
      const transactions = Array.isArray(transactionOrTransactions) ? transactionOrTransactions : (logger.warn(
        `You are using an outdated version of @layerzerolabs/protocol-devtools (and/or @layerzerolabs/protocol-devtools-solana, @layerzerolabs/protocol-devtools-evm). Please update your dependencies to the newest version`
      ), [transactionOrTransactions]);
      omniTransaction.push(...transactions);
    }
  }
  return omniTransaction;
};
var buildEnforcedOptionsOmniTransactions = async (setEnforcedOptionsByEndpoint, createSdk) => {
  const omniTransaction = [];
  for (const [from, enforcedOptionsConfig] of setEnforcedOptionsByEndpoint) {
    const oappSdk = await createSdk(from);
    omniTransaction.push(await oappSdk.setEnforcedOptions(enforcedOptionsConfig));
  }
  return omniTransaction;
};
var enforcedOptionsReducer = (enforcedOptionsByMsgType, enforcedOptionsConfig) => {
  var _a;
  const { optionType, msgType } = enforcedOptionsConfig;
  const currentOptions = (_a = enforcedOptionsByMsgType.get(msgType)) != null ? _a : Options.newOptions();
  switch (optionType) {
    case ExecutorOptionType.LZ_RECEIVE:
      return enforcedOptionsByMsgType.set(
        msgType,
        currentOptions.addExecutorLzReceiveOption(enforcedOptionsConfig.gas, enforcedOptionsConfig.value)
      );
    case ExecutorOptionType.NATIVE_DROP:
      return enforcedOptionsByMsgType.set(
        msgType,
        currentOptions.addExecutorNativeDropOption(enforcedOptionsConfig.amount, enforcedOptionsConfig.receiver)
      );
    case ExecutorOptionType.COMPOSE:
      return enforcedOptionsByMsgType.set(
        msgType,
        currentOptions.addExecutorComposeOption(
          enforcedOptionsConfig.index,
          enforcedOptionsConfig.gas,
          enforcedOptionsConfig.value
        )
      );
    case ExecutorOptionType.ORDERED:
      return enforcedOptionsByMsgType.set(msgType, currentOptions.addExecutorOrderedExecutionOption());
  }
};
var configureOApp = withOAppLogger(
  createConfigureMultiple(
    configureOAppPeers,
    configureSendLibraries,
    configureReceiveLibraries,
    configureReceiveLibraryTimeouts,
    configureSendConfig,
    configureReceiveConfig,
    configureEnforcedOptions,
    configureCallerBpsCap,
    configureOAppDelegates
  ),
  {
    onStart: (logger) => logger.info(`Checking OApp configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp configuration`),
    onError: (logger, args, error) => logger.error(`Failed to check OApp configuration: ${error}`)
  }
);
var OwnableNodeConfigSchema = z.object({
  owner: AddressSchema.nullish()
}).passthrough();

// src/oapp/schema.ts
var OAppReceiveLibraryConfigSchema = z.object({
  gracePeriod: UIntBigIntSchema,
  receiveLibrary: AddressSchema
});
var OAppSendConfigSchema = z.object({
  executorConfig: Uln302ExecutorConfigSchema.optional(),
  ulnConfig: Uln302UlnUserConfigSchema.optional()
});
var OAppReceiveConfigSchema = z.object({
  ulnConfig: Uln302UlnUserConfigSchema.optional()
});
var ExecutorLzReceiveOptionSchema = z.object({
  msgType: UIntNumberSchema,
  optionType: z.literal(ExecutorOptionType.LZ_RECEIVE),
  gas: UIntNumberSchema,
  value: UIntNumberSchema.optional()
});
var ExecutorNativeDropOptionSchema = z.object({
  msgType: UIntNumberSchema,
  optionType: z.literal(ExecutorOptionType.NATIVE_DROP),
  amount: UIntNumberSchema,
  receiver: AddressSchema
});
var ExecutorComposeOptionSchema = z.object({
  msgType: UIntNumberSchema,
  optionType: z.literal(ExecutorOptionType.COMPOSE),
  index: UIntNumberSchema,
  gas: UIntNumberSchema,
  value: UIntNumberSchema.optional()
});
var ExecutorOrderedExecutionOptionSchema = z.object({
  msgType: UIntNumberSchema,
  optionType: z.literal(ExecutorOptionType.ORDERED)
});
var OAppEnforcedOptionConfigSchema = z.union([
  ExecutorLzReceiveOptionSchema,
  ExecutorNativeDropOptionSchema,
  ExecutorComposeOptionSchema,
  ExecutorOrderedExecutionOptionSchema
]);
var OAppEnforcedOptionsSchema = z.array(OAppEnforcedOptionConfigSchema);
var OAppNodeConfigSchema = OwnableNodeConfigSchema.extend({
  delegate: AddressSchema.nullish()
}).passthrough();
var OAppEdgeConfigSchema = z.object({
  sendLibrary: AddressSchema,
  receiveLibraryConfig: OAppReceiveLibraryConfigSchema,
  receiveLibraryTimeoutConfig: TimeoutSchema,
  sendConfig: OAppSendConfigSchema,
  receiveConfig: OAppReceiveConfigSchema,
  enforcedOptions: OAppEnforcedOptionsSchema
}).passthrough().partial();
var OAppOmniGraphSchema = createOmniGraphSchema(
  createOmniNodeSchema(OAppNodeConfigSchema),
  createOmniEdgeSchema(OAppEdgeConfigSchema)
);
var configureOwnable = async (graph, createSdk) => {
  const logger = createModuleLogger("Ownable");
  return flattenTransactions(
    await Promise.all(
      graph.contracts.map(async ({ point, config }) => {
        const formattedPoint = formatOmniPoint(point);
        if ((config == null ? void 0 : config.owner) == null) {
          return logger.verbose(`No owner specified for ${formattedPoint}`), void 0;
        }
        logger.verbose(`Checking whether the owner of ${formattedPoint} is ${config.owner}`);
        const sdk = await createSdk(point);
        const hasOwner = await sdk.hasOwner(config.owner);
        if (hasOwner) {
          return logger.verbose(`The owner of ${formattedPoint} already is ${config.owner}`), void 0;
        }
        return logger.verbose(`Setting the owner of ${formattedPoint} to ${config.owner}`), sdk.setOwner(config.owner);
      })
    )
  );
};
var createOAppReadLogger = () => createModuleLogger("OAppRead");
var withOAppReadLogger = createWithAsyncLogger(createOAppReadLogger);
var configureOAppReadChannels = withOAppReadLogger(
  createConfigureNodes(
    withOAppReadLogger(
      async ({ config, point }, sdk) => {
        const logger = createOAppReadLogger();
        const label = formatOmniPoint(point);
        const omniTransactions = [];
        if (!(config == null ? void 0 : config.readChannelConfigs)) {
          logger.verbose(`readChannel configuration not set for ${label}, skipping`);
          return [];
        }
        logger.verbose(`Checking read channels ${label}`);
        for (const { channelId, active: activeConfig } of config.readChannelConfigs) {
          const active = activeConfig != null ? activeConfig : true;
          const isActive = await sdk.isReadChannelActive(channelId);
          logger.verbose(`Checking read channel ${channelId} for ${label}: ${printBoolean(isActive)}`);
          if (isActive !== active) {
            logger.verbose(`Setting read channel ${channelId} to ${active}`);
            omniTransactions.push(await sdk.setReadChannel(channelId, active));
          }
        }
        return omniTransactions;
      },
      {
        onStart: (logger, [{ point }]) => logger.verbose(`Checking OApp read channels for ${formatOmniPoint(point)}`),
        onSuccess: (logger, [{ point }]) => logger.verbose(`${printBoolean(true)} Checked OApp read channels for ${formatOmniPoint(point)}`),
        onError: (logger, [{ point }], error) => logger.error(`Failed to check OApp read channels for ${formatOmniPoint(point)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking OApp read channels configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp read channels configuration`)
  }
);
var configureReadLibraries = withOAppReadLogger(
  createConfigureNodes(
    withOAppReadLogger(
      async ({ config, point }, sdk) => {
        const logger = createOAppReadLogger();
        const label = formatOmniPoint(point);
        if (!(config == null ? void 0 : config.readChannelConfigs)) {
          logger.verbose(`readChannel configuration not set for ${label}, skipping`);
          return [];
        }
        const omniTransactions = [];
        const endpointSdk = await sdk.getEndpointSDK();
        for (const { channelId, active, readLibrary } of config.readChannelConfigs) {
          if (active === false) {
            logger.verbose(
              `readLibrary won't be set for inactive channelId ${channelId} for ${label}, skipping`
            );
            continue;
          }
          if (!readLibrary) {
            logger.verbose(
              `readLibrary configuration not set for channelId ${channelId} for ${label}, skipping`
            );
            continue;
          }
          const isDefaultSendLibrary = await endpointSdk.isDefaultSendLibrary(point.address, channelId);
          const currentSendLibrary = await endpointSdk.getSendLibrary(point.address, channelId);
          if (!isDefaultSendLibrary && currentSendLibrary === readLibrary) {
            logger.verbose(
              `Current sendlibrary of channelId ${channelId} is already set to ${readLibrary} for ${label}, skipping`
            );
          } else {
            logger.verbose(`Setting sendLibrary ${readLibrary} to channelId ${channelId} for ${label}`);
            omniTransactions.push(await endpointSdk.setSendLibrary(point.address, channelId, readLibrary));
          }
          const [currentReceiveLibrary, isDefaultReceiveLibrary] = await endpointSdk.getReceiveLibrary(
            point.address,
            channelId
          );
          if (!isDefaultReceiveLibrary && currentReceiveLibrary === readLibrary) {
            logger.verbose(
              `Current receiveLibrary of channelId ${channelId} is already set to ${readLibrary} for ${label}, skipping`
            );
          } else {
            logger.verbose(`Setting receiveLibrary ${readLibrary} to channelId ${channelId} for ${label}`);
            omniTransactions.push(
              await endpointSdk.setReceiveLibrary(
                point.address,
                channelId,
                readLibrary,
                // TODO READ: Grace period should be configurable
                BigInt(0)
              )
            );
          }
        }
        return omniTransactions;
      },
      {
        onStart: (logger, [{ point }]) => logger.verbose(`Checking read libraries for ${formatOmniPoint(point)}`),
        onSuccess: (logger, [{ point }]) => logger.verbose(`${printBoolean(true)} Checked read libraries for ${formatOmniPoint(point)}`),
        onError: (logger, [{ point }], error) => logger.error(`Failed to check read libraries for ${formatOmniPoint(point)}: ${error}`)
      }
    )
  ),
  {
    onStart: (logger) => logger.info(`Checking read libraries configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked read libraries configuration`)
  }
);
var configureReadConfig = createConfigureNodes(
  withOAppReadLogger(
    async ({ config, point }, sdk) => {
      const logger = createOAppReadLogger();
      const label = formatOmniPoint(point);
      if (!(config == null ? void 0 : config.readChannelConfigs)) {
        logger.verbose(`readChannel configuration not set for ${label}, skipping`);
        return [];
      }
      const endpointSdk = await sdk.getEndpointSDK();
      const omniTransactions = [];
      for (const { channelId, active, readLibrary, ulnConfig } of config.readChannelConfigs) {
        if (active === false) {
          logger.verbose(`readLibrary not set for inactive channelId ${channelId} for ${label}, skipping`);
          continue;
        }
        if (!ulnConfig) {
          logger.verbose(`ulnConfig not set for channelId ${channelId} for ${label}, skipping`);
          continue;
        }
        const currentSendLibrary = readLibrary != null ? readLibrary : await endpointSdk.getSendLibrary(point.address, channelId);
        assert(
          currentSendLibrary !== void 0,
          "sendLibrary has not been set in your config and no default value exists"
        );
        const hasUlnConfig = await endpointSdk.hasAppUlnReadConfig(
          point.address,
          currentSendLibrary,
          channelId,
          ulnConfig
        );
        logger.verbose(`Checked ULN configuration for ${label}: ${printBoolean(hasUlnConfig)}`);
        if (!hasUlnConfig) {
          const newSetConfigs = await endpointSdk.getUlnReadConfigParams(
            currentSendLibrary,
            [
              {
                channelId,
                ulnConfig
              }
            ]
          );
          const transactions = await endpointSdk.setConfig(point.address, currentSendLibrary, newSetConfigs);
          logger.verbose(`Set ULN configuration  for ${formatOmniPoint(point)}`);
          const updatedConfigListCsv = newSetConfigs.map(({ configType, config: config2 }) => `{configType: ${configType}, config: ${config2}}`).join(", ");
          logger.verbose(`Set ULN configuration ${updatedConfigListCsv} for ${label}`);
          omniTransactions.push(...transactions);
        }
      }
      return omniTransactions;
    },
    {
      onStart: (logger) => logger.info(`Checking read configuration`),
      onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked read configuration`)
    }
  )
);
var configureReadEnforcedOptions = createConfigureNodes(
  withOAppReadLogger(
    async ({ config, point }, sdk) => {
      const logger = createOAppReadLogger();
      const label = formatOmniPoint(point);
      if (!(config == null ? void 0 : config.readChannelConfigs)) {
        logger.verbose(`readChannel configuration not set for ${label}, skipping`);
        return [];
      }
      const omniTransactions = [];
      const oappEnforcedOptions = [];
      for (const { channelId, active, enforcedOptions } of config.readChannelConfigs) {
        if (active === false) {
          logger.verbose(`readLibrary not set for inactive channelId ${channelId} for ${label}, skipping`);
          continue;
        }
        if (!enforcedOptions) {
          logger.verbose(`Enforced options not set for channelId ${channelId} for ${label}, skipping`);
          continue;
        }
        const enforcedOptionsByMsgType = enforcedOptions.reduce(
          enforcedOptionsReducer2,
          /* @__PURE__ */ new Map()
        );
        for (const [msgType, options] of enforcedOptionsByMsgType) {
          const currentEnforcedOption = await sdk.getEnforcedOptions(channelId, msgType);
          logger.verbose(
            `Checked current enforced options for channelId ${channelId} for ${label}: ${currentEnforcedOption}`
          );
          if (currentEnforcedOption !== options.toHex()) {
            oappEnforcedOptions.push({
              eid: channelId,
              option: {
                msgType,
                options: options.toHex()
              }
            });
            logger.verbose(
              `Set enforced options {msgType: ${msgType}, options: ${options}} for channelId ${channelId} for ${label}`
            );
          }
        }
      }
      if (oappEnforcedOptions.length > 0) {
        logger.verbose(`Set enforced options for ${label}`);
        omniTransactions.push(await sdk.setEnforcedOptions(oappEnforcedOptions));
      }
      return omniTransactions;
    },
    {
      onStart: (logger) => logger.info(`Checking enforced options`),
      onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked enforced options`)
    }
  )
);
var enforcedOptionsReducer2 = (enforcedOptionsByMsgType, enforcedOptionsConfig) => {
  var _a;
  const { optionType, msgType } = enforcedOptionsConfig;
  const currentOptions = (_a = enforcedOptionsByMsgType.get(msgType)) != null ? _a : Options.newOptions();
  switch (optionType) {
    case ExecutorOptionType.COMPOSE:
      return enforcedOptionsByMsgType.set(
        msgType,
        currentOptions.addExecutorComposeOption(
          enforcedOptionsConfig.index,
          enforcedOptionsConfig.gas,
          enforcedOptionsConfig.value
        )
      );
    case ExecutorOptionType.ORDERED:
      return enforcedOptionsByMsgType.set(msgType, currentOptions.addExecutorOrderedExecutionOption());
    case ExecutorOptionType.LZ_READ:
      return enforcedOptionsByMsgType.set(
        msgType,
        currentOptions.addExecutorLzReadOption(
          enforcedOptionsConfig.gas,
          enforcedOptionsConfig.size,
          enforcedOptionsConfig.value
        )
      );
  }
};
var configureOAppRead = withOAppReadLogger(
  createConfigureMultiple(
    configureOAppDelegates,
    configureOAppPeers,
    configureOAppReadChannels,
    configureSendLibraries,
    configureReceiveLibraries,
    configureReceiveLibraryTimeouts,
    configureReadLibraries,
    configureSendConfig,
    configureReceiveConfig,
    configureReadConfig,
    configureEnforcedOptions,
    configureReadEnforcedOptions,
    configureCallerBpsCap
  ),
  {
    onStart: (logger) => logger.info(`Checking OApp Read configuration`),
    onSuccess: (logger) => logger.info(`${printBoolean(true)} Checked OApp Read configuration`),
    onError: (logger, args, error) => logger.error(`Failed to check OApp Read configuration: ${error}`)
  }
);
var ExecutorLzReadOptionSchema = z.object({
  msgType: UIntNumberSchema,
  optionType: z.literal(ExecutorOptionType.LZ_READ),
  gas: UIntNumberSchema,
  size: UIntNumberSchema,
  value: UIntNumberSchema.optional()
});
var OAppReadEnforcedOptionConfigSchema = z.union([
  ExecutorLzReadOptionSchema,
  ExecutorComposeOptionSchema,
  ExecutorOrderedExecutionOptionSchema
]);
var OAppReadChannelConfigSchema = z.object({
  channelId: UIntNumberSchema,
  active: z.boolean().optional(),
  readLibrary: AddressSchema.optional(),
  ulnConfig: UlnReadUlnUserConfigSchema.optional(),
  enforcedOptions: z.array(OAppReadEnforcedOptionConfigSchema).optional()
});
var OAppReadChannelSchema = z.array(OAppReadChannelConfigSchema);
var OAppReadNodeConfigSchema = OwnableNodeConfigSchema.extend({
  delegate: AddressSchema.nullish(),
  readChannelConfigs: z.array(OAppReadChannelConfigSchema).optional()
}).passthrough();
var OAppReadOmniGraphSchema = createOmniGraphSchema(
  createOmniNodeSchema(OAppReadNodeConfigSchema),
  createOmniEdgeSchema(OAppEdgeConfigSchema)
);

// src/oapp-read/check.ts
var checkOAppReadChannels = async (graph, createSdk) => {
  const promises = graph.contracts.flatMap(({ point, config }) => {
    return ((config == null ? void 0 : config.readChannelConfigs) || []).map(async ({ channelId }) => {
      const sdk = await createSdk(point);
      const isActive = await sdk.isReadChannelActive(channelId);
      return { contract: point, channelId, isActive };
    });
  });
  return await Promise.all(promises);
};
var CommandResolver = class {
  constructor(singleViewFunctionEVMCallFactory, computerEVMFactory) {
    this.singleViewFunctionEVMCallFactory = singleViewFunctionEVMCallFactory;
    this.computerEVMFactory = computerEVMFactory;
  }
  decodeCommand(command) {
    return Command.decode(command.replace("0x", ""));
  }
  async extractTimeMarkers(command) {
    const decodedCommand = Command.decode(command.replace("0x", ""));
    const timeMarkers = [];
    for (const request of decodedCommand.requests) {
      switch (request.requestHeader.resolverType) {
        case ResolverType.SingleViewFunctionEVMCall:
          timeMarkers.push(extractTimeMarker(request));
          break;
        default:
          throw new Error(`Unsupported resolver type: ${request.requestHeader.resolverType}`);
      }
    }
    if (decodedCommand.compute) {
      switch (decodedCommand.compute.computeHeader.computeType) {
        case ComputeType.SingleViewFunctionEVMCall:
          timeMarkers.push(extractTimeMarker(decodedCommand.compute));
          break;
        default:
          throw new Error(`Unsupported compute type: ${decodedCommand.compute.computeHeader.computeType}`);
      }
    }
    const dedupedTimeMarkers = dedupTimeMarkers(timeMarkers);
    return {
      blockNumberTimeMarkers: dedupedTimeMarkers.filter((tm) => tm.isBlockNumber),
      timestampTimeMarkers: dedupedTimeMarkers.filter((tm) => !tm.isBlockNumber)
    };
  }
  async resolveCommand(command, timeMarkers) {
    const logger = createModuleLogger("CommandResolverSdk");
    const decodedCommand = Command.decode(command.replace("0x", ""));
    logger.info(`Resolving requests`);
    const responses = await Promise.all(
      decodedCommand.requests.map(
        async (request) => this.resolveRequest(request, findRequestResolvedTimeMarker(request, timeMarkers), logger)
      )
    );
    if (!decodedCommand.compute) {
      logger.info("No compute information in command, returning concatenated responses");
      return responses.map((lr) => lr.response).join("");
    }
    return await this.resolveCompute(
      command,
      decodedCommand.compute,
      findComputeResolvedTimeMarker(decodedCommand.compute, timeMarkers),
      responses
    );
  }
  async resolveRequest(request, timeMarker, logger) {
    switch (request.requestHeader.resolverType) {
      case ResolverType.SingleViewFunctionEVMCall: {
        const requestEvm = request;
        const response = await (await this.singleViewFunctionEVMCallFactory(requestEvm.targetEid)).resolve(requestEvm, timeMarker);
        logger.debug(`Resolved request ${requestEvm.encode()}: ${response}`);
        return { request: requestEvm.encode(), response };
      }
      default:
        throw new Error(`Unsupported resolver type: ${request.requestHeader.resolverType}`);
    }
  }
  async resolveCompute(command, compute, timeMarker, responses) {
    switch (compute.computeHeader.computeType) {
      case ComputeType.SingleViewFunctionEVMCall: {
        const computeEvm = compute;
        return await (await this.computerEVMFactory(computeEvm.targetEid)).resolve(command, computeEvm, timeMarker, responses);
      }
      default:
        throw new Error(`Unsupported compute type: ${compute.computeHeader.computeType}`);
    }
  }
};

// src/read/errors.ts
var UnresolvableCommandError = class extends Error {
  constructor() {
    super(`Unresolvable command`);
  }
};
var dedup = (isEqual) => (arr) => {
  return arr.reduce((acc, item) => {
    if (!acc.some((existingItem) => isEqual(existingItem, item))) {
      acc.push(item);
    }
    return acc;
  }, []);
};
var isEqualTimeMarker = (a, b) => {
  return a.eid === b.eid && a.isBlockNumber === b.isBlockNumber && a.blockNumber === b.blockNumber && a.timestamp === b.timestamp && a.blockConfirmation === b.blockConfirmation;
};
var dedupTimeMarkers = dedup(isEqualTimeMarker);
var extractTimeMarker = (req) => {
  const baseTimeMarker = {
    blockConfirmation: req.blockConfirmations,
    eid: req.targetEid
  };
  if (req.timestampBlockFlag === TimestampBlockConfiguration.Timestamp) {
    return {
      ...baseTimeMarker,
      isBlockNumber: false,
      timestamp: Number(req.timestamp)
    };
  }
  return {
    ...baseTimeMarker,
    isBlockNumber: true,
    blockNumber: Number(req.blockNumber)
  };
};
var findResolvedTimeMarker = (timeMarker, resolvedTimeMarkers) => {
  const resolvedTimeMarker = resolvedTimeMarkers.find(
    (tm) => tm.eid === timeMarker.eid && tm.timestamp === timeMarker.timestamp && tm.blockConfirmation === timeMarker.blockConfirmation
  );
  if (!resolvedTimeMarker) {
    throw new Error(`Could not find resolved time marker for ${JSON.stringify(timeMarker)}`);
  }
  return resolvedTimeMarker;
};
var applyResolvedTimestampTimeMarkers = (tms, rtms) => {
  return tms.map((tm) => {
    return findResolvedTimeMarker(tm, rtms);
  });
};
var findRequestResolvedTimeMarker = (request, timeMarkers) => {
  switch (request.requestHeader.resolverType) {
    case ResolverType.SingleViewFunctionEVMCall: {
      const timeMarker = extractTimeMarker(request);
      if (timeMarker.isBlockNumber) {
        return timeMarker;
      }
      return findResolvedTimeMarker(timeMarker, timeMarkers);
    }
    default:
      throw new Error(`Unsupported resolver type: ${request.requestHeader.resolverType}`);
  }
};
var findComputeResolvedTimeMarker = (compute, timeMarkers) => {
  switch (compute.computeHeader.computeType) {
    case ComputeType.SingleViewFunctionEVMCall: {
      const timeMarker = extractTimeMarker(compute);
      if (timeMarker.isBlockNumber) {
        return timeMarker;
      }
      return findResolvedTimeMarker(timeMarker, timeMarkers);
    }
    default:
      throw new Error(`Unsupported compute type: ${compute.computeHeader.computeType}`);
  }
};
var groupByEid = (arr) => {
  return arr.reduce((acc, item) => {
    if (!acc.has(item.eid)) {
      acc.set(item.eid, []);
    }
    acc.get(item.eid).push(item);
    return acc;
  }, /* @__PURE__ */ new Map());
};
var isBlockMatchingTimestamp = (block, previousBlock, targetTimestamp) => {
  return block.number === 1 ? block.timestamp == targetTimestamp : block.timestamp >= targetTimestamp && previousBlock.timestamp < targetTimestamp;
};

// src/read/timeMarkerResolver/sdk.ts
var TimeMarkerResolver = class {
  constructor(timeMarkerResolverChainFactory) {
    this.timeMarkerResolverChainFactory = timeMarkerResolverChainFactory;
  }
  async resolveTimestampTimeMarkers(timeMarkers) {
    const resolvedTimeMarkers = [];
    const groupedTimeMarkers = timeMarkers.reduce((acc, timeMarker, id) => {
      if (!acc.has(timeMarker.eid)) {
        acc.set(timeMarker.eid, []);
      }
      acc.get(timeMarker.eid).push({ timeMarker, id });
      return acc;
    }, /* @__PURE__ */ new Map());
    await Promise.all(
      Array.from(groupedTimeMarkers.entries()).map(async ([eid, markers]) => {
        const sdk = await this.timeMarkerResolverChainFactory(eid);
        const timestamps = markers.map((m) => m.timeMarker).filter((timeMarker) => !timeMarker.isBlockNumber).map((timeMarker) => timeMarker.timestamp);
        const resolvedTimestamps = await sdk.resolveTimestamps(timestamps);
        markers.forEach((marker) => {
          resolvedTimeMarkers[marker.id] = {
            ...marker.timeMarker,
            blockNumber: resolvedTimestamps[marker.timeMarker.timestamp]
          };
        });
      })
    );
    return resolvedTimeMarkers;
  }
};

// src/read/timeMarkerValidator/sdk.ts
var TimeMarkerValidator = class {
  constructor(timeMarkerValidatorChainFactory) {
    this.timeMarkerValidatorChainFactory = timeMarkerValidatorChainFactory;
  }
  async checkResolvedTimeMarkerValidity(tms) {
    const groupedTimeMarkers = groupByEid(tms);
    await Promise.all(
      Array.from(groupedTimeMarkers.entries()).map(async ([eid, markers]) => {
        const sdk = await this.timeMarkerValidatorChainFactory(eid);
        await sdk.checkResolvedTimeMarkerValidity(markers);
      })
    );
  }
  async assertTimeMarkerBlockConfirmations(tms) {
    const groupedTimeMarkers = groupByEid(tms);
    await Promise.all(
      Array.from(groupedTimeMarkers.entries()).map(async ([eid, markers]) => {
        const sdk = await this.timeMarkerValidatorChainFactory(eid);
        await sdk.assertTimeMarkerBlockConfirmations(markers);
      })
    );
  }
};

export { CommandResolver, ExecutorComposeOptionSchema, ExecutorLzReadOptionSchema, ExecutorLzReceiveOptionSchema, ExecutorNativeDropOptionSchema, ExecutorOrderedExecutionOptionSchema, OAppEdgeConfigSchema, OAppEnforcedOptionConfigSchema, OAppEnforcedOptionsSchema, OAppNodeConfigSchema, OAppOmniGraphSchema, OAppReadChannelConfigSchema, OAppReadChannelSchema, OAppReadEnforcedOptionConfigSchema, OAppReadNodeConfigSchema, OAppReadOmniGraphSchema, OAppReceiveConfigSchema, OAppReceiveLibraryConfigSchema, OAppSendConfigSchema, OwnableNodeConfigSchema, TimeMarkerResolver, TimeMarkerValidator, UnresolvableCommandError, applyResolvedTimestampTimeMarkers, checkOAppEnforcedOptions, checkOAppPeers, checkOAppReadChannels, configureCallerBpsCap, configureEnforcedOptions, configureLzApp, configureLzAppTrustedRemotes, configureOApp, configureOAppDelegates, configureOAppPeers, configureOAppRead, configureOAppReadChannels, configureOwnable, configureReadConfig, configureReadEnforcedOptions, configureReadLibraries, configureReceiveConfig, configureReceiveLibraries, configureReceiveLibraryTimeouts, configureSendConfig, configureSendLibraries, dedup, dedupTimeMarkers, extractTimeMarker, findComputeResolvedTimeMarker, findRequestResolvedTimeMarker, groupByEid, isBlockMatchingTimestamp, isEqualTimeMarker };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map